<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 3 - Testing with Jest</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
</head>
<body>
    <header>
        <nav>
            <div class="logo">Web Unit 4 Sprint 15</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module-1-auth/index.html">Module 1: Authentication</a>
                        <a href="../module-2-jwt/index.html">Module 2: JWT</a>
                        <a href="../module-3-testing/index.html" class="active">Module 3: Testing</a>
                        <a href="../module-4-backend-testing/index.html">Module 4: Backend Testing</a>
                    </div>
                </li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            <h1>Module 3: Testing with Jest</h1>
           
            <div class="content-box module3-accent">
              <h2>Configure Jest</h2>
              <p>Testing is an essential skill for a web developer to have. It's hard to anticipate every way that a user might interact with your site, not to mention it is incredibly time-consuming to test all of those options manually. That's where automated testing comes in. Any major company will use automated testing on its websites as a safety net to prevent regressions and get a better overall understanding of how an application works. As such, testing is a great thing to have on your resume!</p>

              <p>We'll quickly review what testing is before jumping into tooling we can use for automated testing. Generally speaking, testing is a code that checks if the application code is correct.</p>

              <p>If we don't have tests, it's safe to assume the following:</p>

              <ul>
                <li>application code has to be tested manually</li>
                <li>there is no way to know if a change broke another piece of code</li>
                <li>you cannot be sure if the code is correct</li>
                <li>manually testing takes a lot of unnecessary time</li>
                <li>adding new features becomes slow</li>
              </ul>

              <h3>Advantages of Testing</h3>
              <ul>
                <li>verifies edge cases</li>
                <li>developer can concentrate on current changes (safety net)</li>
              </ul>

              <h3>Drawbacks of Testing</h3>
              <ul>
                <li>more code to write and maintain</li>
                <li>more tooling</li>
                <li>additional dependencies</li>
                <li>may provide a false sense of security</li>
                <li>trivial test failures may break the build</li>
                <li>regressions (when a new feature breaks existing code)</li>
              </ul>

              <h3>What tools do we use for testing?</h3>
              <p>Hopefully, you're convinced that testing is essential and want to start using it in your projects by now. In this course, you've already used React testing library to write tests for React components, but there are other tools available. Examples of those tools are Jest, Mocha/Chai, Jasmine, Qunit, Enzyme, Supertest, Istambul, Karma, and Cypress.</p>

              <p>How do you even begin to set up custom testing for a project with so many testing tools available? First, it helps to know why you want to test so that you can pick the tool most suited to your needs.</p>

              <h3>Jest</h3>
              <p>We'll use the testing library Jest to start setting up our tests. Jest runs under the hood in React testing library, so a lot of what we do moving forward should look somewhat familiar. With create-react-app and React testing library, there was no need to install and set up Jest, but as you grow as a web developer, you will likely run into a need to install and use Jest on its own.</p>

              <p>Jest is a test runner and command-line interface npm package. It was originally made by Facebook and is included out-of-the-box with create-react-app. Jest is a very general-purpose testing tool, and it works best with React applications, though it works with other frameworks. In addition to the types of tests we've seen, Jest can run asynchronous tests, snapshot testing, and produce coverage reports.</p>

              <h3>Watch Mode</h3>
              <p>You'll learn how to install and configure Jest in the tutorial below, but first, let's talk briefly about watch mode. Instead of running tests manually, Jest has a built-in watch mode feature that will run tests automatically as files change. Thus, Jest detects these changes automatically and only runs the tests about the changes. This is one of the reasons developers love Jest so much and hopefully one that you'll find equally compelling.</p>

              <div class="note-box">
                <h3>How to Build It</h3>
                <ol>
                  <li>
                    <p><strong>Install jest with npm</strong></p>
                    <p>We first need to install Jest as a development dependency. As soon as we do, Jest dependencies will show up in our package.json file.</p>
                    <pre><code>npm install -D jest</code></pre>
                  </li>

                  <li>
                    <p><strong>Add test script</strong></p>
                    <p>In package.json we'll need to indicate that we're using jest for testing. This can be done by simply adding "test": "jest --watch", to your "scripts" object.</p>
                  </li>

                  <li>
                    <p><strong>Run Tests</strong></p>
                    <p>We can start Jest by typing npm test in a terminal window at the root of the project. However, since there are no tests written, it will return an error "No tests found" because we haven't actually written any tests yet, so let's move on.</p>
                  </li>

                  <li>
                    <p><strong>Create test files</strong></p>
                    <p>By convention, Jest will find your tests in two ways:</p>
                    <ol>
                      <li>by placing .js files inside a folder called __tests__</li>
                      <li>by ending the name of a file in .test.js or .spec.js</li>
                    </ol>
                    <p>Technically, you could give the __tests__ folder a different name, but then you'd need to manually change where Jest looks for test files.</p>
                    <p>Here we aren't going to write tests, but at this point you are all set up to do so.</p>
                  </li>
                </ol>
                <div class="video-container">
                  <iframe src="https://fast.wistia.net/embed/iframe/6yy8xxrfyk" allow="autoplay; fullscreen" loading="lazy"></iframe>
                </div>
              </div>
              <h3>Using Jest</h3>
              <p>In the last objective, we configured Jest in a project. Now we want to write and run unit tests.</p>

              <h3>Unit Tests</h3>
              <p>You'll recall from unit 3 that unit tests are where we isolate smaller units of software (often functions or methods). There are usually many unit tests in a codebase, and because these tests are meant to be run often, they need to run fast. As a result, unit tests are fast, they're simple to write and execute, and they're the preferred tool for test driven development (TDD) and behavior driven development (BDD). In addition, developers regularly use them to test correctness in units of code (usually functions).</p>

              <h3>What makes a good test?</h3>
              <p>A good unit test is independent, focused, and, as you might assume, tests only one unit of code. This type of test focuses on one behavior or functionality (even if you have to make multiple assertions), therefore testing what needs to be tested and no more.</p>

              <p>Another important consideration with testing is that you should try to avoid unnecessary preconditions. For example, if your test relies on outside dependencies or other tests running first, you should factor to isolate the test (much like a pure function).</p>

              <h3>Jest Globals</h3>
              <p>The <code>it</code> global is a method you pass a function to; that function is executed as a block of tests by the test runner.</p>
              <p>The <code>describe</code> is optional for grouping several related <code>it</code> statements; this is also known as a test suite.</p>

              <h3>Hello World Test</h3>
              <p>Let's consider a constant function. We'll use the ever-so-simple hello function for testing purposes.</p>

              <pre><code>export const hello = () => "hello world!";</code></pre>

              <p>Next we'd move into our tests folder and set up a test asserting that we expect the return value of this function to be hello world.</p>

              <pre><code>import { hello } from "./App";
//arrange
describe("hello", () => {
  //act
  it("should return hello world!", () => {
    //assert
    expect(hello()).toBe("hello world!");
  });
});</code></pre>

              <p>Thanks to our watcher, the test should run automatically in the terminal, and you'd see that the test passed. Hopefully, this looks familiar to you from our work with React testing library.</p>

              <p>Before we dive into writing our tests with Jest, let's look at a few more details.</p>

              <h3>Important Globals in Jest</h3>
              <p>A few objects exist in the global scope like <code>describe</code> and <code>it</code>. You are already familiar with their use cases. When writing custom tests you may find that some tests need to be run more than once, like a test to render without crashing, for example. Jest has built in globals for this use case:</p>

              <table>
                <tr>
                  <th>Global</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td><code>beforeAll</code></td>
                  <td>runs once before the first test</td>
                </tr>
                <tr>
                  <td><code>beforeEach</code></td>
                  <td>runs before the tests, good for setup code</td>
                </tr>
                <tr>
                  <td><code>afterEach</code></td>
                  <td>runs after the tests, good for clean up</td>
                </tr>
                <tr>
                  <td><code>afterAll</code></td>
                  <td>runs once after the last test</td>
                </tr>
              </table>

              <p>If there's ever a scenario in which you want to skip or isolate a test, use the following globals:</p>

              <table>
                <tr>
                  <th>Global</th>
                  <th>Description</th>
                </tr>
                <tr>
                  <td><code>it.skip()</code></td>
                  <td>skips the test</td>
                </tr>
                <tr>
                  <td><code>it.only()</code></td>
                  <td>isolates a test</td>
                </tr>
              </table>

              <p>The remaining globals can be found in the <a href="https://jestjs.io/docs/getting-started" target="_blank">Jest documentation</a></p>
              <div class="note-box">
                <h3>How to Build It</h3>
              <p>Let's walk through building a unit test for a JavaScript function. We'll create a function called <code>averageTestScore</code> that calculates the average of an array of test scores.</p>

              <p>First, create a file called <code>mathHelpers.js</code> with this function:</p>

              <pre><code>const averageTestScore = testScores => {
  if (!Array.isArray(testScores)) throw new Error('Not array!')
  let totalSumScores = 0;
  for (let i = 0; i < testScores.length; i++) {
    totalSumScores += testScores[i];
  }
  return totalSumScores / testScores.length;
};

module.exports = averageTestScore;</code></pre>

              <p>Next, create <code>mathHelpers.test.js</code>. We'll start by writing placeholder tests using <code>it.todo()</code> to plan what we want to test:</p>

              <pre><code>describe('mathHelpers', () => {
  describe('averageTestScore', () => {
    it.todo('should calculate the average for an array of numbers');
    it.todo('should throw "Not array!" if the argument is not an array');
  });
});</code></pre>

              <p>Now let's implement the actual tests by replacing the <code>it.todo()</code>s with full test cases:</p>

              <pre><code>const { averageTestScore } = require("./mathHelpers.js");

describe('mathHelpers', () => {
  describe('averageTestScore', () => {
    it('should calculate the average for an array of numbers', () => {
      const scores = [2, 4, 6, 6, 2];
      const expected = 4
      const actual = averageTestScore(scores);
      expect(actual).toBe(expected);
    });
    it('should throw "Not array!" if the argument is not an array', () => {
      expect(() => averageTestScore(5)).toThrow('Not array!');
      expect(() => averageTestScore('five and two')).toThrow('Not array!');
      expect(() => averageTestScore({ number: 5 })).toThrow('Not array!');
      expect(() => averageTestScore(undefined)).toThrow('Not array!');
      // etc
    });
  });
});</code></pre>
              <div class="video-container">
                <iframe src="https://fast.wistia.net/embed/iframe/f8seisa4rh" allow="autoplay; fullscreen" loading="lazy"></iframe>
              </div>
              </div>
              <h3>Test Driven Development</h3>
              <p>Test-driven development is the process of writing tests before code. In theory, you can write much higher-quality code when you start with the end (the tests) in mind. You might be familiar with similar philosophies in teaching (backward planning) -- or from the famous book "7 Habits of Highly Effective People" (starting with the end in mind).</p>

              <p>Let's consider some units of code. First, we want this function to take two numbers and return the first number to the power of the second number.</p>

              <p>Some assertions we might want to check are:</p>

              <ul>
                <li>The function returns a number</li>
                <li>The function returns a to the power of b</li>
                <li>The function returns undefined if one parameter is not a number</li>
              </ul>

              <p>There's an endless amount of assertions we could check, but it helps to think of the most likely scenarios where the unit could fail for test-driven development.</p>

              <p>In this example, we'd write all of these tests in Jest. After that, we could start hacking away at the function. So as long as all the tests pass, you can be confident in what you've created.</p>
              <div class="note-box">
                <h3>How to Build It</h3>
                <p>Let's walk through an example of test-driven development using Jest. We'll build a function that filters salaries below $50,000.</p>

                <h4>Brainstorm</h4>
                <p>First, spend 3-5 minutes brainstorming test ideas. Consider:</p>
                <ul>
                  <li>Core functionality</li>
                  <li>Edge cases</li>
                  <li>Ways the function could be used incorrectly</li>
                </ul>

                <p>Your brainstorm might include tests for:</p>
                <ul>
                  <li>Throwing an error if passed a non-array argument</li>
                  <li>Throwing if array contains non-numbers</li>
                  <li>Confirming it returns an array</li>
                  <li>Removing salaries below 50,000</li>
                  <li>Keeping salaries equal to 50,000</li>
                </ul>

                <h4>TDD Cycle Part 1: Write a Failing Test</h4>
                <p>Start with one simple failing test:</p>
                <pre><code>it('throws if passed a non-array as the salaries argument', () => {
  const expected = 'You must pass an array of numbers'
  expect(() => removeSalaries('Definitely not an array')).toThrow(expected)
});</code></pre>

                <h4>TDD Cycle Part 2: Write Minimal Passing Code</h4>
                <p>Write just enough code to pass the test:</p>
                <pre><code>function removeSalaries(salaries) {
  if (!Array.isArray(salaries)) throw new Error('You must pass an array of numbers')
}</code></pre>

                <h4>TDD Cycle Part 3: Refactor</h4>
                <p>Clean up the code while keeping tests passing. Continue the Red-Green-Refactor cycle with more tests:</p>

                <pre><code>// Final Tests
it('throws if passed a non-array as the salaries argument', () => {
  const expected = 'You must pass an array of numbers';
  expect(() => removeSalaries('Definitely not an array')).toThrow(expected);
});

it('throws if any element inside the array is not a number', () => {
  const expected = 'You must pass an array of numbers';
  expect(() => removeSalaries([1, 2, 'Definitely not a number'])).toThrow(expected);
});

it('returns an array', () => {
  expect(Array.isArray(removeSalaries([1, 2, 3]))).toBe(true);
});

it('removes all salaries less than 50,000', () => {
  const salaries = [55000, 45000, 1, 60000];
  const expected = [55000, 60000];
  expect(removeSalaries(salaries)).toEqual(expected);
});

it('does not remove salaries equal to 50,000', () => {
  const salaries = [50000, 50000];
  const expected = [50000, 50000];
  expect(removeSalaries(salaries)).toEqual(expected);
});</code></pre>

                <p>Final implementation after completing TDD cycles:</p>
                <pre><code>function removeSalaries(salaries) {
  const errorMessage = 'You must pass an array of numbers';
  if (!Array.isArray(salaries)) throw new Error(errorMessage);
  let result = [];
  for (let salary of salaries) {
    if (typeof salary !== 'number') throw new Error(errorMessage);
    if (salary >= 50000) {
      result.push(salary);
    }
  }
  return result;
}</code></pre>

                <p>While strict TDD can be challenging to master, it's a proven method for writing quality code. You can start by writing tests up-front, then implement the code. The key is to write tests - they're essential for maintaining and improving code quality!</p>
              </div>
            </div>

            <div class="content-box module3-accent">
              <h2>Guided Project</h2>
            <p><a href="https://github.com/bloominstituteoftechnology/node-testing1-guided" target="_blank" rel="noopener">Unit Testing Starter Code</a></p>
            <p><a href="https://github.com/bloominstituteoftechnology/node-testing1-guided-solution" target="_blank" rel="noopener">Unit Testing Solution</a></p>
            <div class="video-container">
                <iframe src="https://fast.wistia.net/embed/iframe/5k23ogyxk5" title="Guided Project" allow="autoplay; fullscreen" loading="lazy"></iframe>
            </div>
            <div class="note-box">
              <h3>NOTE</h3>
              <p>The versions of project dependencies used in the recording are slightly different from the ones used in the starter and solution repositories, but this should not have any impact on the relevant code of the Guided Project.</p>

              <p>The versions used in the repositories are more recent, and thus more similar to the versions you will install if you create a project from scratch.</p>
            </div>
          </div>

          <div class="content-box module3-accent">
              <h3>Module 3 Project: Unit Testing</h3>

              <p>The module project contains advanced problems that will challenge and stretch your understanding of the module's content. The project has built-in tests for you to check your work, and the solution video is available in case you need help or want to see how we solved each challenge, but remember, there is always more than one way to solve a problem. Before reviewing the solution video, be sure to attempt the project and try solving the challenges yourself.</p>
              

              <h3>Instructions</h3>

              <p>The link below takes you to Bloom's code repository of the assignment. You'll need to fork the repo to your own GitHub account, and clone it down to your computer:</p>
              <p>Starter Repo: <a href="https://github.com/bloominstituteoftechnology/node-testing1-project" target="_blank">Unit Testing</a></p>

              <ul>
                  <li>Fork the repository,</li>
                  <li>clone it to your machine, and</li>
                  <li>open the README.md file in VSCode, where you will find instructions on completing this Project.</li>
                  <li>submit your completed project to the BloomTech Portal</li>
              </ul>

              <h3>Solution</h3>
              <div class="video-container">
                  <iframe src="https://fast.wistia.net/embed/iframe/5ylj9llq4c" title="Solution Video" allow="autoplay; fullscreen" loading="lazy"></iframe>
              </div>
          </div>
            <section class="resource-section">
                <h2 class="resource-section-title">Additional Resources</h2>
                <div class="resource-links">
                    <a href="https://jestjs.io/docs/getting-started" target="_blank" rel="noopener noreferrer" class="resource-link">
                        Jest Documentation
                    </a>
                    <a href="https://jestjs.io/docs/expect" target="_blank" rel="noopener noreferrer" class="resource-link">
                        Jest Matchers Reference
                    </a>
                    <a href="https://jestjs.io/docs/mock-functions" target="_blank" rel="noopener noreferrer" class="resource-link">
                        Jest Mock Functions
                    </a>
                    <a href="https://medium.com/@rickhanlonii/understanding-jest-mocks-f0046c68e53c" target="_blank" rel="noopener noreferrer" class="resource-link">
                        Understanding Jest Mocks
                    </a>
                </div>
            </section>

            
        </section>
    </main>
</body>
</html>