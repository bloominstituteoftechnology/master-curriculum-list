<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 4: Primitive Wrapper Classes - BD Unit 2 Sprint 6</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
</head>

<body>
    <header>
        <nav>
            <div class="logo">BD Unit 2 Sprint 6</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module1/index.html">Module 1: Encapsulation</a>
                        <a href="../module2/index.html">Module 2: Polymorphism and Interfaces</a>
                        <a href="../module3/index.html">Module 3: Generics</a>
                        <a href="../module4/index.html" class="active">Module 4: Primitive Wrapper Classes</a>
                    </div>
                </li>
                <li><a href="../../code-alongs/index.html">Code-Alongs</a></li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            <h1>Module 4: Primitive Wrapper Classes</h1>

            <div class="content-box">
                <h2>Module Overview</h2>
                <p>Learn about primitive wrapper classes, autoboxing, and unboxing in Java.</p>
            </div>

            <div class="video-container">
                <iframe class="wistia_embed" title="Sprint 6 Primitive Wrapper Classes Video"
                    src="https://fast.wistia.net/embed/iframe/upi2laj640" width="100%" height="360" name="wistia_embed"
                    allow="autoplay; fullscreen" loading="lazy"></iframe>
            </div>

            <div class="content-box">
                <h2>Learning Objectives</h2>
                <ul>
                    <li>Understand what Java collections are and when to use them</li>
                    <li>Learn the core interfaces of the Collections Framework</li>
                    <li>Explore implementation classes for Lists, Sets, and Maps</li>
                    <li>Utilize collection utility methods for common operations</li>
                </ul>
            </div>

            <div class="content-box">
                <h2>Key Concepts</h2>

                <h3>Java Collections Framework Overview</h3>
                <p>The Java Collections Framework (JCF) is a unified architecture for representing and manipulating
                    collections of objects. It provides standard data structures like lists, sets, and maps, along with
                    algorithms for searching, sorting, and manipulating these collections.</p>

                <h4>Core Collection Interfaces:</h4>
                <ul>
                    <li><strong>Collection</strong> - The root interface with basic methods like add(), remove(), and
                        contains()</li>
                    <li><strong>List</strong> - An ordered collection that allows duplicate elements</li>
                    <li><strong>Set</strong> - A collection that cannot contain duplicate elements</li>
                    <li><strong>Queue</strong> - A collection designed for holding elements prior to processing</li>
                    <li><strong>Map</strong> - An object that maps keys to values, with no duplicate keys allowed</li>
                </ul>
            </div>

            <div class="content-box">
                <h3>Primitive Wrapper Classes</h3>
                <h4>What are they?</h4>
                <p>There is a set of classes that we refer to as "primitive wrapper" classes that correspond to the
                    primitive types in Java. For example, the double primitive type has a corresponding Double class.
                </p>

                <p>They're classes that contain a member variable of the relevant primitive type and some helpful
                    additional methods.</p>

                <p>Note that primitive types are not objects and are thus stored by value. The wrapper types are objects
                    and are thus stored by reference. So a variable of type, Integer , actually contains a reference to
                    an Integer object. But a variable of type, int , simply contains the integer value of that int.
                    Because the wrapper classes are object types, remember to use equals() when comparing instances of
                    these wrapper classes: do NOT use == (which will make a reference comparison instead of a value
                    comparison!)</p>

                <h4>Primitive Types and Their Wrapper Classes:</h4>
                <table>
                    <tr>
                        <th>Primitive Type</th>
                        <th>Wrapper class</th>
                    </tr>
                    <tr>
                        <td>boolean</td>
                        <td>Boolean</td>
                    </tr>
                    <tr>
                        <td>byte</td>
                        <td>Byte</td>
                    </tr>
                    <tr>
                        <td>char</td>
                        <td>Character</td>
                    </tr>
                    <tr>
                        <td>short</td>
                        <td>Short</td>
                    </tr>
                    <tr>
                        <td>int</td>
                        <td>Integer</td>
                    </tr>
                    <tr>
                        <td>long</td>
                        <td>Long</td>
                    </tr>
                    <tr>
                        <td>float</td>
                        <td>Float</td>
                    </tr>
                    <tr>
                        <td>double</td>
                        <td>Double</td>
                    </tr>
                </table>

                <p>Notice that most of the wrapper class names match the primitive type names, but just with a capital
                    letter, denoting it as a class. The two exceptions are char / Character and int / Integer. These
                    primitive names are historical, coming from the C programming language, and you'll just need to
                    remember that their primitives have the shortened name and the wrapper class uses the full word name
                    for those two cases. But it probably won't be too hard as you're already familiar with int s and
                    probably won't use char / Character all that often.</p>

                <h4>Why do they exist?</h4>
                <p>These wrapper classes offer a few things:</p>
                <ul>
                    <li>You can set a wrapper object reference to null, but you cannot set a primitive to null</li>
                    <li>Some classes accept only objects, so they cannot accept an int/float/double... (e.g. ArrayList),
                        so to use them, you'll need to use the wrapper classes</li>
                    <li>The wrapper classes offer some helpful methods: converting between types, to/from String etc.
                    </li>
                </ul>

                <h4>Immutability</h4>
                <p>We may have discussed the concept of immutability--a class whose instances cannot be modified in any
                    way once they are constructed. If you want to "modify" the value/state of an immutable class
                    instance, you'll need to call a method or operation that creates a new instance. This applies to
                    each of these primitive wrapper classes: All primitive wrapper classes are immutable.</p>

                <h4>Some primitive wrapper methods for conversion</h4>
                <p>Explicitly converting between primitives, wrappers, String (using int/Integer as an example):</p>

                <h5>Between primitive/wrapper types:</h5>
                <ul>
                    <li><strong>int -> Integer:</strong> Integer's class method, valueOf(int), converts an int to an
                        Integer:
                        <pre><code>Integer wrapperInteger = Integer.valueOf(22);</code></pre>
                        This is done by Java behind the scenes in:
                        <pre><code>Integer wrapperInteger = 22;</code></pre>
                    </li>
                    <li><strong>Integer -> int:</strong> Integer's instance method, intValue(), converts an Integer to
                        an int:
                        <pre><code>Integer wrapperInteger = new Integer(22);
int primitiveInt = wrapperInteger.intValue();</code></pre>
                        This is done by Java behind the scenes in:
                        <pre><code>int primitiveInt = wrapperInteger;</code></pre>
                    </li>
                </ul>

                <h5>From String to different types:</h5>
                <ul>
                    <li><strong>String -> int:</strong> Use Integer's class method, parseInt(String):
                        <pre><code>int primitiveInt = Integer.parseInt("22");</code></pre>
                    </li>
                    <li><strong>String -> Integer:</strong> Use valueOf(String):
                        <pre><code>Integer wrapperInteger = Integer.valueOf("22");</code></pre>
                    </li>
                </ul>

                <h5>From different types to String:</h5>
                <ul>
                    <li><strong>int -> String:</strong> Use Integer.toString(int):
                        <pre><code>String intString = Integer.toString(22);</code></pre>
                    </li>
                    <li><strong>Integer -> String:</strong> Use toString() instance method:
                        <pre><code>Integer wrapperInteger = Integer.valueOf(22);
String integerString = wrapperInteger.toString();</code></pre>
                    </li>
                </ul>

                <h5>Summary of Conversions:</h5>
                <table>
                    <tr>
                        <th>From Type</th>
                        <th>To Type</th>
                        <th>method</th>
                        <th>Example</th>
                    </tr>
                    <tr>
                        <td>int</td>
                        <td>Integer</td>
                        <td>Integer.valueOf(int)</td>
                        <td>Integer wrapperInteger = Integer.valueOf(22);</td>
                    </tr>
                    <tr>
                        <td>Integer</td>
                        <td>int</td>
                        <td>Integer#intValue()</td>
                        <td>Integer wrapperInteger = new Integer(22); int primitiveInt = wrapperInteger.intValue();</td>
                    </tr>
                    <tr>
                        <td>String</td>
                        <td>int</td>
                        <td>Integer.parseInt(String)</td>
                        <td>int primitiveInt = Integer.parseInt("22");</td>
                    </tr>
                    <tr>
                        <td>String</td>
                        <td>Integer</td>
                        <td>Integer.valueOf(String)</td>
                        <td>Integer wrapperInteger = Integer.valueOf("22");</td>
                    </tr>
                    <tr>
                        <td>int</td>
                        <td>String</td>
                        <td>Integer.toString(int)</td>
                        <td>String intString = Integer.toString(22);</td>
                    </tr>
                    <tr>
                        <td>Integer</td>
                        <td>String</td>
                        <td>Integer#toString()</td>
                        <td>Integer wrapperInteger = Integer.valueOf(22); String integerString =
                            wrapperInteger.toString();</td>
                    </tr>
                </table>

                <p>There are analogous conversion methods for the other wrapper types. For example,
                    Double.valueOf(double), doublePrimitive.doubleValue()... search google for "Java Double class" or
                    "Java Boolean class" and you should quickly find the javadoc documentation from Oracle on the
                    relevant class.</p>
            </div>

            <div class="content-box">
                <h3>Lists</h3>
                <p>Lists are ordered collections that allow duplicate elements. Elements can be accessed by their
                    integer index.</p>

                <h4>Common List Implementations:</h4>
                <ul>
                    <li><strong>ArrayList</strong> - Resizable array implementation; fast for random access, slower for
                        insertions/deletions</li>
                    <li><strong>LinkedList</strong> - Doubly-linked list implementation; fast for insertions/deletions,
                        slower for random access</li>
                    <li><strong>Vector</strong> - Legacy synchronized list implementation (thread-safe)</li>
                    <li><strong>Stack</strong> - Legacy LIFO (Last-In-First-Out) stack implementation</li>
                </ul>

                <h4>Example:</h4>
                <pre><code>
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        // ArrayList example
        List<String> arrayList = new ArrayList<>();
        arrayList.add("Java");
        arrayList.add("Python");
        arrayList.add("JavaScript");
        arrayList.add("Java");  // Duplicates allowed
        
        System.out.println("ArrayList: " + arrayList);
        System.out.println("Element at index 1: " + arrayList.get(1));
        
        // LinkedList example
        List<String> linkedList = new LinkedList<>(arrayList);  // Initialize with another collection
        linkedList.add(0, "C++");  // Add at specific position
        linkedList.remove("Java");  // Remove first occurrence
        
        System.out.println("LinkedList: " + linkedList);
        
        // Common operations
        System.out.println("Size: " + linkedList.size());
        System.out.println("Contains 'Python'? " + linkedList.contains("Python"));
        System.out.println("Index of 'JavaScript': " + linkedList.indexOf("JavaScript"));
    }
}
                </code></pre>
            </div>

            <div class="content-box">
                <h3>Sets</h3>
                <p>Sets are collections that cannot contain duplicate elements. They model the mathematical set
                    abstraction.</p>

                <h4>Common Set Implementations:</h4>
                <ul>
                    <li><strong>HashSet</strong> - Uses hash table for storage; doesn't guarantee order, offers
                        constant-time performance</li>
                    <li><strong>LinkedHashSet</strong> - Hash table with linked list, maintains insertion order</li>
                    <li><strong>TreeSet</strong> - Based on TreeMap (Red-Black tree), elements stored in sorted order
                    </li>
                </ul>

                <h4>Example:</h4>
                <pre><code>
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.TreeSet;

public class SetExample {
    public static void main(String[] args) {
        // HashSet example
        Set<Integer> hashSet = new HashSet<>();
        hashSet.add(10);
        hashSet.add(5);
        hashSet.add(20);
        hashSet.add(10);  // Duplicate - will be ignored
        
        System.out.println("HashSet: " + hashSet);  // Order not guaranteed
        
        // LinkedHashSet example - maintains insertion order
        Set<Integer> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add(10);
        linkedHashSet.add(5);
        linkedHashSet.add(20);
        
        System.out.println("LinkedHashSet: " + linkedHashSet);  // Maintains insertion order
        
        // TreeSet example - maintains sorted order
        Set<Integer> treeSet = new TreeSet<>();
        treeSet.add(10);
        treeSet.add(5);
        treeSet.add(20);
        
        System.out.println("TreeSet: " + treeSet);  // Natural ordering (ascending)
        
        // Set operations
        Set<Integer> set1 = new HashSet<>(Set.of(1, 2, 3, 4, 5));
        Set<Integer> set2 = new HashSet<>(Set.of(4, 5, 6, 7, 8));
        
        // Union
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("Union: " + union);
        
        // Intersection
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("Intersection: " + intersection);
        
        // Difference
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("Difference (set1 - set2): " + difference);
    }
}
                </code></pre>
            </div>

            <div class="content-box">
                <h3>Maps</h3>
                <p>Maps are objects that map keys to values. A map cannot contain duplicate keys, and each key can map
                    to at most one value.</p>

                <h4>Common Map Implementations:</h4>
                <ul>
                    <li><strong>HashMap</strong> - General-purpose implementation based on a hash table</li>
                    <li><strong>LinkedHashMap</strong> - Hash table with linked list, maintains insertion order of keys
                    </li>
                    <li><strong>TreeMap</strong> - Based on a Red-Black tree, keys maintained in sorted order</li>
                    <li><strong>Hashtable</strong> - Legacy synchronized implementation (thread-safe)</li>
                </ul>

                <h4>Example:</h4>
                <pre><code>
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.TreeMap;

public class MapExample {
    public static void main(String[] args) {
        // HashMap example
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("John", 25);
        hashMap.put("Alice", 30);
        hashMap.put("Bob", 28);
        hashMap.put("John", 26);  // Overwrites previous value for "John"
        
        System.out.println("HashMap: " + hashMap);  // Order not guaranteed
        
        // LinkedHashMap example - maintains insertion order
        Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("John", 25);
        linkedHashMap.put("Alice", 30);
        linkedHashMap.put("Bob", 28);
        
        System.out.println("LinkedHashMap: " + linkedHashMap);  // Maintains insertion order
        
        // TreeMap example - maintains sorted key order
        Map<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("John", 25);
        treeMap.put("Alice", 30);
        treeMap.put("Bob", 28);
        
        System.out.println("TreeMap: " + treeMap);  // Sorted by keys
        
        // Common operations
        System.out.println("Value for 'Alice': " + hashMap.get("Alice"));
        System.out.println("Contains key 'David'? " + hashMap.containsKey("David"));
        System.out.println("Contains value 28? " + hashMap.containsValue(28));
        
        // Iterating over a Map
        System.out.println("Iterating over HashMap:");
        for (Map.Entry<String, Integer> entry : hashMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // Using forEach (Java 8+)
        System.out.println("Using forEach:");
        hashMap.forEach((key, value) -> System.out.println(key + ": " + value));
    }
}
                </code></pre>
            </div>

            <div class="content-box">
                <h2>Guided Projects</h2>

                <div class="video-container">
                    <iframe src="https://fast.wistia.net/embed/iframe/26gbzatl64"
                        title="Module 3 Guided Projects Video Content" allowfullscreen></iframe>
                </div>

                <div class="resource-links">
                    <a href="https://github.com/BloomTechBackend/bd-primitive-wrapper-classes-attendance"
                        target="_blank" rel="noopener noreferrer" class="resource-link">
                        Primitive Wrapper Classes
                    </a>
                </div>
            </div>

            <section class="resource-section">
                <h2 class="resource-section-title">Additional Resources</h2>
                <div class="resource-links">
                    <a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html" target="_blank"
                        rel="noopener noreferrer" class="resource-link">
                        Java Autoboxing and Unboxing Documentation
                    </a>
                    <a href="https://www.baeldung.com/java-wrapper-classes" target="_blank" rel="noopener noreferrer"
                        class="resource-link">
                        Guide to Java Wrapper Classes - Baeldung
                    </a>
                </div>
            </section>
        </section>
    </main>
</body>

</html>