<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 1 - Database Basics | Web Unit 4 Sprint 14</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
</head>

<body>
    <header>
        <nav>
            <div class="logo">Web Unit 4 Sprint 14</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module-1-db-basics/index.html" class="active">Module 1: Database Basics</a>
                        <a href="../module-2-schema-design/index.html">Module 2: Schema Design</a>
                        <a href="../module-3-multi-table/index.html">Module 3: Multi-Table Queries</a>
                        <a href="../module-4-data-modeling/index.html">Module 4: Data Modeling</a>
                    </div>
                </li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            <h1>Module 1: Database Basics</h1>

            <div class="content-box module1-accent">
                <h2>Intro to Relational Databases</h2>
                    <p>Databases are everywhere. They drive all businesses and our own livesâ€“from your mobile device's contact list to the appointments on your calendar.</p>

                    <p>A database is a collection of data organized for easy retrieval and manipulation. We're concerned only with digital databases, those that run on computers or other electronic devices.</p>

                    <p>Digital databases have been around since the 1960s. However, relational databases store "related" data and are the oldest and most common type of database in use today.</p>

                    <h3>Data Persistence</h3>
                    <p>A database is often necessary because our application or code requires data persistence. This term refers to data that is infrequently accessed and not likely to be modified. In less technical terms, the information will be safely stored and remain untouched unless intentionally modified.</p>

                    <p>A familiar example of non-persistent data would be JavaScript objects and arrays, which reset each time the code runs.</p>

                    <h3>Relational Databases</h3>
                    <p>In relational databases, the data is stored in tabular format grouped into rows and columns (similar to spreadsheets). A collection of rows is called a table. Each row represents a single record in the table and is made up of one or more columns.</p>

                    <p>These kinds of databases are relational because relation is a mathematical idea equivalent to a table. So relational databases are databases that store their data in tables.</p>

                    <h3>Tables</h3>
                    <p>Below are some basic facts about tables:</p>
                    <ul>
                        <li>Tables organize data in rows and columns.</li>
                        <li>Each row in a table represents one distinct record.</li>
                        <li>Each column represents a field or attribute that is common to all the records.</li>
                        <li>Fields should have a descriptive name and a data type appropriate for the attribute it represents.</li>
                        <li>Tables usually have more rows than columns.</li>
                        <li>Tables have primary keys that uniquely identify each row.</li>
                        <li>Foreign keys represent the relationships with other tables.</li>
                    </ul>
                    <div class="video-container">
                        <iframe src="https://www.youtube.com/embed/cd7Yio-D7qM" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                    <h2>What is SQL and it's advantages</h2>
                    <p>SQL is a standard language, which means that it will certainly be supported, no matter how your database is managed. That said, be aware that the SQL language can vary depending on database management tools. This lesson focuses on a set of core commands that never change. Learning the standard commands is an excellent introduction since the knowledge transfers between database products.</p>
                    <div class="note-box">
                        <h3>How to Build It</h3>
                        <p>The syntax for SQL is English-like and requires fewer symbols than programming languages like C, Java, and JavaScript. It is declarative and concise, which means there is much less to learn to use effectively.</p>

                        <p>When learning SQL, it is helpful to understand that each command is designed for a different purpose. If we classify the commands by purpose, we'll end up with the following sub-categories of SQL:</p>

                        <ul>
                            <li><strong>Data Definition Language (DDL)</strong>: used to modify database objects. Some examples are: CREATE TABLE, ALTER TABLE, and DROP TABLE.</li>
                            <li><strong>Data Manipulation Language (DML)</strong>: used to manipulate the data stored in the database. Some examples are: INSERT, UPDATE, and DELETE.</li>
                            <li><strong>Data Query Language (DQL)</strong>: used to ask questions about the data stored in the database. The most commonly used SQL command is SELECT, and it falls in this category.</li>
                            <li><strong>Data Control Language (DCL)</strong>: used to manage database security and user's access to data. These commands fall into the realm of Database Administrators. Some examples are GRANT and REVOKE.</li>
                            <li><strong>Transaction Control Commands</strong>: used for managing groups of statements that must execute as a unit or not execute at all. Examples are COMMIT and ROLLBACK.</li>
                        </ul>

                        <p>As a developer, you'll need to get familiar with DDL and become proficient in using DML and DQL. Therefore, this lesson will cover only DML and DQL commands.</p>
                        <div class="video-container">
                            <iframe src="https://fast.wistia.net/embed/iframe/k9m9knqkcy" allow="autoplay; fullscreen" loading="lazy"></iframe>
                        </div>
                    </div>
                    <h2>Query, Insert, Update, and Modify Data in SQL</h2>
                    <p>The four SQL operations covered in this section will allow users to query, insert, and modify a database table.</p>

                    <h3>Query</h3>
                    <p>A query is an SQL statement used to retrieve data from a database. The command used to write queries is SELECT, and it is one of the most commonly used SQL commands.</p>

                    <p>The basic syntax for a SELECT statement is this:</p>
                    <pre><code>select &lt;selection&gt; from &lt;table name&gt;;</code></pre>

                    <p>To see all the fields on a table, we can use a * as the selection.</p>
                    <pre><code>select * from employees;</code></pre>

                    <p>The preceding statement would show all the records and columns for each record in the employee's table.</p>

                    <p>To pick the fields we want to see, we use a comma-separated list:</p>
                    <pre><code>select first_name, last_name, salary from employees;</code></pre>

                    <p>The return of that statement would hold all records from the listed fields.</p>

                    <p>We can extend the SELECT command's capabilities using clauses for things like filtering, sorting, pagination, and more.</p>

                    <p>It is possible to query multiple tables in a single query. But, in this section, we only perform queries on a single table. We will cover performing queries on multiple tables in another section.</p>

                    <h3>Insert</h3>
                    <p>To insert new data into a table, we'll use the INSERT command. The basic syntax for an INSERT statement is this:</p>
                    <pre><code>insert into &lt;table name&gt; (&lt;selection&gt;) values (&lt;values&gt;)</code></pre>

                    <p>Using this formula, we can specify which values will be inserted into which fields like so:</p>
                    <pre><code>insert into Customers (Country, CustomerName, ContactName, Address, City, PostalCode)
values ('USA', 'BloomTech', 'Austen Allred', '1 Bloom Court', 'Provo', '84601');</code></pre>

                    <h3>Modify</h3>
                    <p>Modifying a database consists of updating and removing records. For these operations, we'll use UPDATE and DELETE commands, respectively.</p>

                    <p>The basic syntax for an UPDATE statement is:</p>
                    <pre><code>update &lt;table name&gt; set &lt;field&gt; = &lt;value&gt; where &lt;condition&gt;;</code></pre>

                    <p>The basic syntax for a DELETE statement is:</p>
                    <pre><code>delete from &lt;table name&gt; where &lt;condition&gt;;</code></pre>
                    <div class="note-box">
                        <h3>How to Build It</h3>
                        <h4>Filtering results using WHERE clause</h4>
                        <p>When querying a database, the default result will be every entry in the given table. However, often, we are looking for a specific record or a set of records that meets certain criteria.</p>

                        <p>A WHERE clause can help in both cases.</p>

                        <p>Here's an example where we might only want to find customers living in Berlin.</p>

                        <pre><code>select City, CustomerName, ContactName
from Customers
where City = 'Berlin'</code></pre>

                        <p>We can also chain together WHERE clauses using OR and AND to limit our results further.</p>

                        <p>The following query includes only records that match both criteria.</p>

                        <pre><code>select City, CustomerName, ContactName
from Customers
where Country = 'France' and City = 'Paris'</code></pre>

                        <p>And this query includes records that match either criteria.</p>

                        <pre><code>select City, CustomerName, ContactName
from Customers
where Country = 'France' or City = 'Paris'</code></pre>

                        <p>These operators can be combined and grouped with parentheses to add complex selection logic. They behave similarly to what you're used to in programming languages.</p>

                        <p>You can read more about SQLite operators from <a href="https://www.w3resource.com/sqlite/sqlite-operators.php" target="_blank" rel="noopener noreferrer">w3resource</a>.</p>

                        <p>To select a single record, we can use a WHERE statement with a uniquely identifying field, like an id:</p>

                        <pre><code>select * from Customers
where CustomerId=3;</code></pre>

                        <p>Other comparison operators also work in WHERE conditions, such as >, <, <=, and >=.</p>

                        <pre><code>select * from employees where salary >= 50000</code></pre>

                        <h4>Ordering results using the ORDER BY clause</h4>
                        <p>Query results are shown in the same order the data was inserted. To control how the data is sorted, we can use the ORDER BY clause. Let's see an example.</p>

                        <pre><code>-- sorts the results first by salary in descending order, then by the last name in ascending order
select * from employees order by salary desc, last_name;</code></pre>

                        <p>We can pass a list of field names to order by and optionally choose asc or desc for the sort direction. The default is asc, so it doesn't need to be specified.</p>

                        <p>Some SQL engines also support using field abbreviations when sorting.</p>

                        <pre><code>select name, salary, department from employees order by 3, 2 desc;</code></pre>

                        <p>In this case, the results are sorted by the department in ascending order first and then by salary in descending order. The numbers refer to the fields' position in the selection portion of the query, so 1 would be name, 2 would be salary, and so on.</p>

                        <p>Note that the WHERE clause should come after the FROM clause. The ORDER BY clause always goes last.</p>

                        <pre><code>select * from employees where salary > 50000 order by last_name;</code></pre>

                        <h4>Limiting results using the LIMIT clause</h4>
                        <p>When we wish to see only a limited number of records, we can use a LIMIT clause.</p>

                        <p>The following returns the first ten records in the products table:</p>

                        <pre><code>select * from products
limit 10</code></pre>

                        <p>LIMIT clauses are often used in conjunction with ORDER BY. The following shows us the five most expensive products:</p>

                        <pre><code>select * from products
order by price desc
limit 5</code></pre>

                        <h4>Inserting data using INSERT</h4>
                        <p>An insert statement adds a new record to the database. All non-null fields must be listed out in the same order as their values. Some fields, like ids and timestamps, may be auto-generated and do not need to be included in an INSERT statement.</p>

                        <pre><code>-- we can add fields in any order; the values need to be in the same ordinal position
-- the id will be assigned automatically
insert into Customers (Country, CustomerName, ContactName, Address, City, PostalCode)
values ('USA', 'BloomTech', 'Austen Allred', '1 Bloom Court', 'Provo', '84601');</code></pre>

                        <p>The values in an insert statement must not violate any restrictions and constraints the database has in place, such as expected data types. We will learn more about constraints and schema design in a later section.</p>

                        <h4>Modifying recording using UPDATE</h4>
                        <p>When modifying a record, we identify a single record or a set of records to update using a WHERE clause. Then we can set the new value(s) in place.</p>

                        <pre><code>update Customers
set City = 'Silicon Valley', Country = 'USA'
where CustomerName = 'BloomTech'</code></pre>

                        <p>Technically the WHERE clause is not required, but leaving it off would result in every record within the table receiving the update.</p>

                        <h4>Removing records using DELETE</h4>
                        <p>When removing a record or set of records, we need only identify which record(s) to remove using a WHERE clause:</p>

                        <pre><code>delete from Customers
where CustomerName = 'BloomTech';</code></pre>

                        <p>Once again, the WHERE clause is not required, but leaving it off would remove every record in the table, so it's essential.</p>
                        <div class="video-container">
                            <iframe src="https://fast.wistia.net/embed/iframe/cu1jbpl64z" allow="autoplay; fullscreen" loading="lazy"></iframe>
                        </div>
                    </div>
                    <h2>Write Database Wueries Using knex.js</h2>
                    
                        <p>Raw SQL is a critical baseline skill. However, Node developers generally use an Object Relational Mapper (ORM) or query builder to write database commands in a backend codebase. Both ORMs and query builders are JavaScript libraries that allow us to interface with the database using a JavaScript version of the SQL language.</p>

                        <p>For example, instead of a raw SQL SELECT:</p>

                        <pre><code>SELECT * FROM users;</code></pre>

                        <p>We could use a query builder to write the same logic in JavaScript:</p>

                        <pre><code>db.select('*').from('users');</code></pre>

                        <p>Query builders are lightweight and easy to get off the ground, whereas ORMs use an object-oriented model and provide more heavy lifting within their rigid structure.</p>

                        <p>We will use a query builder called <a href="https://knexjs.org/" target="_blank" rel="noopener noreferrer">knex.js</a>.</p>
                        <div class="note-box">
                            <h3>How to Build It</h3>
                            <h4>Knex Setup</h4>
                            <p>To use Knex in a repository, we'll need to add two libraries:</p>

                            <pre><code>npm install knex sqlite3</code></pre>

                            <p><code>knex</code> is our query builder library, and <code>sqlite3</code> allows us to interface with a sqlite database. We'll learn more about sqlite and other database management systems in the following module. For now, know that you need both libraries.</p>

                            <p>Next, we use Knex to set up a config file:</p>

                            <pre><code>const knex = require('knex');

const config = {
  client: 'sqlite3',
  connection: {
    filename: './data/posts.db3',
  },
  useNullAsDefault: true,
};

module.exports = knex(config);</code></pre>

                            <p>We need to call Knex and pass in a config object to use the query builder elsewhere in our code. We'll be discussing knex configuration more in a future module. Still, we only need the client, connection, and useNullAsDefault keys, as shown above. The filename should point towards the pre-existing database file, which the .db3 extension can recognize.</p>

                            <div class="warning-box">
                                <p><strong>GOTCHA:</strong> The file path to the database should be with respect to the root of the repo, not the configuration file itself.</p>
                            </div>

                            <p>Once Knex is configured, we can import the above config file anywhere in our codebase to access the database.</p>

                            <pre><code>const db = require('../data/db-config.js);</code></pre>

                            <p>The db object provides methods that allow us to begin building queries.</p>

                            <h4>SELECT using Knex</h4>
                            <p>In Knex, the equivalent of <code>SELECT * FROM users</code> is:</p>

                            <pre><code>db.select('*').from('users');</code></pre>

                            <p>There's a simpler way to write the same command:</p>

                            <pre><code>db('users');</code></pre>

                            <p>Using this, we could write a GET endpoint.</p>

                            <pre><code>router.get('/api/users', (req, res) => {
  db('users')
  .then(users => {
    res.json(users);
  })
  .catch (err => {
    res.status(500).json({ message: 'Failed to get users' });
  });
});</code></pre>

                            <p><strong>NOTE:</strong> All Knex queries return promises.</p>

                            <p>Knex also allows for a where clause. In Knex, we could write <code>SELECT * FROM users WHERE id=1</code> as</p>

                            <pre><code>db('users').where({ id: 1 });</code></pre>

                            <p>This method will resolve to an array containing a single entry like so: <code>[{ id: 1, name: 'bill' }]</code>.</p>

                            <p>Using this, we might add a GET endpoint where a specific user:</p>

                            <pre><code>server.get('api/users/:id', (req, res) => {
  const { id } = req.params;

  db('users').where({ id })
  .then(users => {
    // we must check the length to find our if our user exists
    if (users.length) {
      res.json(users);
    } else {
      res.status(404).json({ message: 'Could not find user with given id.' })
   })
  .catch (err => {
    res.status(500).json({ message: 'Failed to get user' });
  });
});</code></pre>

                            <h4>INSERT using Knex</h4>
                            <p>In Knex, the equivalent of <code>INSERT INTO users (name, age) VALUES ('Eva', 32)</code> is:</p>

                            <pre><code>db('users').insert({ name: 'Eva', age: 32 });</code></pre>

                            <p>The insert method in Knex will resolve to an array containing the newly created id for that user like so: <code>[3]</code>.</p>

                            <h4>UPDATE using Knex</h4>
                            <p>In knex, the equivalent of <code>UPDATE users SET name='Ava', age=33 WHERE id=3;</code> is:</p>

                            <pre><code>db('users').where({ id: 3 })
.update({name: 'Ava', age: 33 });</code></pre>

                            <p>Note that the where method comes before update, unlike in SQL.</p>

                            <p>Update will resolve to a count of rows updated.</p>

                            <h4>DELETE using Knex</h4>
                            <p>In Knex, the equivalent of <code>DELETE FROM users WHERE age=33;</code> is:</p>

                            <pre><code>db('users').where({ age: 33}).del();</code></pre>

                            <p>Once again, the where must come before the del. This method will resolve to a count of records removed.</p>
                            <div class="video-container">
                                <iframe src="https://fast.wistia.net/embed/iframe/0liuahe2ej" allow="autoplay; fullscreen" loading="lazy"></iframe>
                            </div>
                        </div>
                    </div>

                    <div class="content-box module1-accent">
                        <h2>Guided Project</h2>
                      <p><a href="https://github.com/bloominstituteoftechnology/node-db1-guided" target="_blank" rel="noopener">Introduction to Relational Databases, SQL and Knex Starter Code</a></p>
                      <p><a href="https://github.com/bloominstituteoftechnology/node-db1-guided-solution" target="_blank" rel="noopener">Introduction to Relational Databases, SQL and Knex Solution</a></p>
                      <div class="video-container">
                          <iframe src="https://fast.wistia.net/embed/iframe/1fy0j00zcb" title="Guided Project" allow="autoplay; fullscreen" loading="lazy"></iframe>
                      </div>
                    </div>
        
                    <div class="content-box module1-accent">
                        <h2>Module 1 Project: Intro to Relational Databases</h2>
        
                        <p>The module project contains advanced problems that will challenge and stretch your understanding of the module's content. The project has built-in tests for you to check your work, and the solution video is available in case you need help or want to see how we solved each challenge, but remember, there is always more than one way to solve a problem. Before reviewing the solution video, be sure to attempt the project and try solving the challenges yourself.</p>
                        
        
                        <h3>Instructions</h3>
        
                        <p>The link below takes you to Bloom's code repository of the assignment. You'll need to fork the repo to your own GitHub account, and clone it down to your computer:</p>
                        <p>Starter Repo: <a href="https://github.com/bloominstituteoftechnology/node-db1-project" target="_blank">Intro to Relational Databases</a></p>
        
                        <ul>
                            <li>Fork the repository,</li>
                            <li>clone it to your machine, and</li>
                            <li>open the README.md file in VSCode, where you will find instructions on completing this Project.</li>
                            <li>submit your completed project to the BloomTech Portal</li>
                        </ul>
        
                        <h3>Solution</h3>
                        <div class="video-container">
                            <iframe src="https://fast.wistia.net/embed/iframe/cfmhiymcj7" title="Solution Video" allow="autoplay; fullscreen" loading="lazy"></iframe>
                        </div>
                    </div>

            <section class="resource-section">
                <h2 class="resource-section-title">Additional Resources</h2>
                <div class="resource-links">
                    <a href="https://knexjs.org/guide/" target="_blank" rel="noopener noreferrer" class="resource-link">
                        Knex.js Guide
                    </a>
                    <a href="https://www.w3schools.com/sql/" target="_blank" rel="noopener noreferrer"
                        class="resource-link">
                        W3Schools SQL Tutorial
                    </a>
                    <a href="https://sqlzoo.net/" target="_blank" rel="noopener noreferrer" class="resource-link">
                        SQLZoo Interactive Exercises
                    </a>
                </div>
            </section>
        </section>
    </main>
</body>

</html>