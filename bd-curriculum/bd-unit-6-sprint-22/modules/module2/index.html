<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 2: Computer Hardware and OS - BD Unit 6 Sprint 22</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
</head>

<body>
    <header>
        <nav>
            <div class="logo">BD Unit 6 Sprint 22</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module1/index.html">Module 1 - Stacks and Queues</a>
                        <a href="../module2/index.html" class="active">Module 2 - Computer Hardware and OS</a>
                        <a href="../module3/index.html">Module 3 - Immutability and Final</a>
                        <a href="../module4/index.html">Module 4 - In-Memory Caching</a>
                    </div>
                </li>
                <li><a href="../../code-alongs/index.html">Code-Alongs</a></li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            <h1>Module 2: Computer Hardware and OS</h1>

            <div class="content-box module2-accent">
                <h2>Overview</h2>
                <p>Computer hardware refers to the physical components that make up a computer system. These components
                    work together to process, store, and transmit data, enabling the computer to function.</p>

                <p>In this module, we'll explore the major hardware components, their roles, and how they interact with
                    the operating system to create a functioning computer system.</p>
            </div>

            <div class="content-box">
                <h2>Learning Objectives</h2>
                <ul>
                    <li>Recall that computers internally represent all data and applications as binary</li>
                    <li>Convert between different data size units (byte, kilobyte, megabyte, gigabyte)</li>
                    <li>Recall that a computer's central processing unit (CPU) executes instructions</li>
                    <li>Recall that a computer‚Äôs random access memory (RAM) is capable of fast, but temporary data
                        storage and retrieval</li>
                    <li>Recall that an operating system is capable of executing multiple processes concurrently</li>
                    <li>Recall that operating systems provide abstractions for processes to perform I/O with hardware
                    </li>
                    <li>Recall that the file system is responsible for persistent data storage and retrieval.</li>
                    <li>Recall that a process does not execute while waiting for I/O.</li>
                    <li>Recall that multi-core processors can execute multiple processes simultaneously</li>
                    <li>Analyze if a software system is CPU, I/O, or memory bound given observations of its performance
                    </li>
                    <li>Explain when a software system would be CPU bound</li>
                    <li>Explain when a software system would be I/O bound</li>
                    <li>Explain when a software system would be memory bound</li>
                    <li>Explain how to improve performance of a software system given that it is CPU, I/O, or memory
                        bound</li>
                </ul>
            </div>

            <div class="content-box">
                <h2>Introduction to Computer Hardware</h2>

                <div class="video-container">
                    <iframe class="wistia_embed" title="Introduction to Computer Hardware and OS"
                        src="https://fast.wistia.net/embed/iframe/7n3u4mu0gx" allow="autoplay; fullscreen"
                        allowfullscreen></iframe>
                </div>

                <p>In this lesson, you'll learn the basics about computer hardware and operating systems. As you move
                    through this lesson, pay attention to the individual pieces that make up the computer as well as how
                    these elements interact with each other. You might imagine the computer as an ecosystem in which
                    each part plays an important role. As Figure 1 illustrates, in natural ecosystems, there is a
                    constant flow between elements within the ecosystem, as resources are passed back and forth.
                    Similarly, there is a near-constant flow of input and output across the different elements of a
                    computer. The components we learn about in this lesson (the CPU, the operating system, RAM, the file
                    system, and I/O) all have an important role to play in your computer's ecosystem.</p>

                <img src="https://tk-assets.lambdaschool.com/24e6c074-0b85-4316-a8d4-d022b9252caa_image1.png"
                    alt="Figure 1" loading="lazy"
                    style="max-width: 100%; height: auto; display: block; margin: 0 auto;">

                <p>Figure 1: In a biological ecosystem, all parts play a role in the functioning of the environment,
                    each part taking some resources and providing other resources. This can be a helpful metaphor to
                    think about how the components of a computer interact.</p>

                <h3>Under the hood: How computers work</h3>
                <h4>What we see vs what the computer sees</h4>
                <p>Before tackling the various hardware elements that comprise a computer, we'll examine the difference
                    between what we see and what the computer sees. To do this, we'll briefly explore binary and how
                    data sizes are determined.</p>

                <h4>What is binary?</h4>
                <p>Binary is what's called a "base 2" number system. The name "base 2" isn't particularly important, but
                    it does help explain what binary is: a number system with only two symbols. Let's compare this to
                    the base 10 number system we normally use. A base 10 system uses ten symbols to represent numbers
                    (0, 1, 2, 3, 4, 5, 6, 7, 8, and 9). All of the numbers you can think of make use of some combination
                    of those ten symbols. Ten, for example, is a combination of 1 and 0.</p>

                <p>While we are used to the base 10 system, computers use binary, which is most often represented as a
                    series of ones and zeros. As the following table shows, all integers and letters can be represented
                    by a sequence of zeros and ones in binary. As you can see by looking at the alphabet letters, binary
                    is not easy for humans to recognize meaningfully.</p>

                <table>
                    <tr>
                        <th>Numbers</th>
                        <th>Numbers in Binary</th>
                        <th>Letters</th>
                        <th>Letters in Binary</th>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>0</td>
                        <td>A</td>
                        <td>01000001</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>1</td>
                        <td>B</td>
                        <td>01000010</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>10</td>
                        <td>C</td>
                        <td>01000011</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>11</td>
                        <td>D</td>
                        <td>01000100</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>100</td>
                        <td>E</td>
                        <td>01000101</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>101</td>
                        <td>F</td>
                        <td>01000110</td>
                    </tr>
                </table>

                <p>Optional: If you would like to learn more about how to translate base-10 numbers into base-2 you can
                    check out this <a href="http://www.steves-internet-guide.com/binary-numbers-explained/"
                        target="_blank" rel="noopener noreferrer">online resource</a>. If you want to write your friends
                    notes in binary, and need to translate characters into binary you can check out this <a
                        href="https://www.rapidtables.com/convert/number/ascii-to-binary.html" target="_blank"
                        rel="noopener noreferrer">online resource</a>.</p>

                <h4>High-level languages vs. binary</h4>
                <p>Programming languages are classified into three categories: High-level languages, low-level
                    languages, and machine language. Java is a high-level language. High-level languages are designed to
                    be easier for humans to read, understand, and code. Think about the keyword "return" in Java. Return
                    is a common word, and its meaning in Java is fairly similar to its meaning in daily use (to give
                    back). It's not too important to worry about low-level languages, but as you'll see in Figure 2,
                    they are an intermediary step between a high-level language like Java and machine language. In other
                    words, they are not as straightforward to scan and read as a high-level language, but they still
                    employ some recognizable keywords.</p>

                <p>Finally, we have machine language, which is binary. Computers only read machine language. This means
                    that all programming languages, from Python to Java, must be translated into binary for computers to
                    both understand and respond.</p>

                <img src="https://tk-assets.lambdaschool.com/41e8e41b-a125-4905-a1f5-f50c7724bc0e_image2.png"
                    alt="Figure 2" loading="lazy"
                    style="max-width: 100%; height: auto; display: block; margin: 0 auto;">
                <p>Figure 2: High-level programming languages like Java contain familiar keywords that help human
                    developers read and write them. Low-level programming languages contain fewer keywords but are still
                    easier for developers to read. The computer only understands binary, the executable machine code.
                </p>

                <h4>Binary and bytes</h4>
                <p>You may be wondering why binary matters? Well, understanding that the computer only "sees" binary is
                    important for understanding file sizes. Because the computer communicates in binary, the smallest
                    possible unit of data is a bit, which is a zero or a one. As we saw in Figure 1.1, however, a single
                    bit is so small it's not even enough to communicate a single letter. So, it's more practical to
                    think about a byte, which is eight bits. Why eight? Well, if you glance back to Figure 1.1, you'll
                    notice that the letters in binary are all eight digits long. A byte is enough information to store a
                    single character, like a letter.</p>

                <p>You may already be familiar with larger units of measure for digital storage. When new smartphones
                    are released, manufactures often flaunt the storage capacity, and if you have ever shopped for a
                    computer you may have thought about what size hard drive you need. It's worth remembering that
                    humans count in a "base 10" number system (we use ten digits to represent numbers), while computers
                    use binary. As you can see in Figure 3, this means that a kilobyte is actually 1024 bytes, instead
                    of the 1000 you might expect kilo to represent in base 10.</p>

                <img src="https://tk-assets.lambdaschool.com/405b369c-007d-48b2-a6ba-d92ba10ab72a_image3.png"
                    alt="Figure 3" loading="lazy"
                    style="max-width: 100%; height: auto; display: block; margin: 0 auto;">
                <p>Figure 3: Each size increment is 1024 units larger than the size below it. This allows us to talk
                    about very large file sizes accurately without using incredibly large numbers.</p>

                <p>As Figure 3 shows, each unit of measurement is bigger than the previous unit by 1024. For this unit,
                    you should make note of the order: byte, kilobyte, megabyte, gigabyte, and terabyte.</p>

                <p>To get some sense of how big each file size is, let's think about some common files and their
                    relative sizes. A very short email message is about 1kB, while a longer email message could perhaps
                    go up to 3-4 kB. A four-minute song is about 3.5 MB. A Blu-ray movie file is approximately 20 GB,
                    depending on the length of the movie. Converting these file sizes into kilobytes shows just how much
                    bigger each file size is.</p>

                <p>To find out how big our song is in kilobytes we multiply 3.5 by 1024 (because each single megabyte is
                    1024 kilobytes). The song is 3584 kilobytes. Converting our Blu-ray movie from gigabytes to
                    kilobytes will take an extra step, as we must first convert it into megabytes. We multiply 20 by
                    1024 to get 20480, the size of our movie in megabytes, and then multiple 20480 by 1024 to get
                    20,971,520.</p>

                <p>To get a better sense of how big each of these file sizes are, the below table shows a megabyte,
                    gigabyte and terabyte and its equivalent size in kilobytes:</p>

                <table>
                    <tr>
                        <th>Size</th>
                        <th>Size in kilobytes (KB)</th>
                    </tr>
                    <tr>
                        <td>1 megabyte (MB)</td>
                        <td>1024 KB</td>
                    </tr>
                    <tr>
                        <td>1 gigabyte (GB)</td>
                        <td>1,048,575 KB</td>
                    </tr>
                    <tr>
                        <td>1 terabyte (TB)</td>
                        <td>1,073,742,180 KB</td>
                    </tr>
                </table>

                <h3>Computer components</h3>
                <p>Now that we've covered what the computer sees and its units of measurement, we'll look at the
                    essential components of a computer: the CPU, the operating system, RAM, and the file system. As
                    mentioned in the introduction to this reading, you can think of a computer as an ecosystem, with
                    each component playing a specific role and communicating with other components in important ways.
                </p>

                <h4>The CPU</h4>
                <p>The CPU is the central processing unit in a computer and is sometimes referred to as simply the
                    processor, however, there are many processors in modern computers. Every single operation performed
                    by your computer is handled in the CPU. For each operation, the CPU will complete four main tasks:
                </p>

                <ul>
                    <li>Fetch: the CPU receives instructions about operations to perform</li>
                    <li>Decode: the CPU converts instructions into proper formats needed to continue the operation</li>
                    <li>Execute: the CPU performs the requested operation</li>
                    <li>Store: the CPU writes the result of the operation to memory, providing feedback on the operation
                    </li>
                </ul>

                <p>So how does a CPU relate to other elements of a computer? In short, the CPU is constantly receiving
                    requests (fetching) from the operating system, decoding and executing the requested operations, and
                    storing the results of the operation in RAM. The CPU also reads information in from the file system
                    and writes to it as needed.</p>

                <h4>Multi-core processors</h4>
                <p>Most modern systems contain multi-core CPUs; CPUs with more than one independent core processor.
                    Since we now know that every process must pass through the CPU, you may be able to guess the value
                    of a multi-core processor already. They can handle multiple processes simultaneously making them
                    more efficient. Programs running on a computer are often called processes.</p>

                <h4>Operating systems and I/O</h4>
                <p>While it may not seem like a flashy program, the operating system (OS) is the most important program
                    on any computer. Whether computer users are aware of it or not, they interact with their operating
                    system every time they use their computer. You can think of an operating system as part translator
                    and part manager for your computer. As translator, the operating system takes in all kinds of input
                    from users and applications and translates it into a format that the CPU can understand. It also
                    translates all output back to the appropriate format. As manager, the operating system makes
                    decisions about how and in what order to send requests to the CPU from all the various applications
                    and other forms of input a computer receives. Every application or program on a computer sends its
                    requests to the operating system to handle.</p>

                <p>One of the important decisions an operating system must make is determining which processes should be
                    given priority. Priority impacts when a request is sent to the CPU and how much space in RAM a
                    process is given (RAM will be explained more fully below). Some processes are the programs a user is
                    actively using, such as an internet browser or a word processor. However, there are many processes
                    that run in the background while a user is working on a computer. These background processes run
                    behind the scenes and don't require input from users. Background processes include things like
                    system monitoring and user notification systems. The operating system handles all of these processes
                    concurrently (at the same time) and, under normal working conditions, responds to the user without
                    interruption as it handles these background operations.</p>

                <p>Not only does your operating system need to manage each process running on your computer, it also
                    needs to act as a translator between you, networks you are connected to, and the CPU. As a user, you
                    can send information to your computer and receive information back from your computer through I/O
                    devices. I/O refers to input/output and is our means of communicating with a computer.</p>

                <p>Input devices include the hardware you use to interact with the computer like the mouse and keyboard,
                    but can also refer to things like a scanner, a touchpad, or any other device that sends signals to a
                    computer. When you click a key on your keyboard, it sends a signal to the operating system. The
                    operating system then determines what that input is intended to mean based on the process you are
                    actively running; clicking a key such as the enter button might have different meanings depending on
                    what program you are using. Once the operating system has interpreted your input, it translates it
                    to a request for the CPU.</p>

                <p>Output devices include things like monitors, printers, speakers, and anything that the computer uses
                    to communicate information to a user. If you click the enter key when using a word processor, the
                    output of that action (the response the CPU sends back to you) might be to move your cursor to a new
                    line. In short, I/O refers to the communication environment of a computer. Why are we talking about
                    I/O in a section about operating systems? Well, I/O is the way operating systems receive requests
                    from users and communicate back to users about processes. The operating system acts as a translator,
                    abstracting input from users and other sources into a usable format for hardware (turning the input
                    into binary for the CPU, and turning the output from binary to the proper format).</p>

                <h4>Types of memory and storage: RAM and file systems</h4>
                <p>In the last section of this read, we'll look at the differences between volatile and non-volatile
                    memory. The word volatile means able to change rapidly, which is a good description for memory that
                    only retains its memory information while the computer is powered on. As soon as a computer is
                    turned off, anything that was left in volatile memory is gone. To understand what this means, think
                    about using a word processor. As you type in a document, you can see the words you previously typed.
                    They are temporarily "stored". However, if you close your document without saving, or if your
                    computer loses power as you are working, those words are gone! In contrast, non-volatile memory
                    keeps its contents even after a computer is turned off or loses power. In our word processor
                    example--- if you save the document you are working on, you can close the program and turn the
                    computer off without losing your work. Your information persists through the computer losing power.
                </p>

                <h4>What is RAM?</h4>
                <p>Understanding the difference between volatile and non-volatile memory is important for understanding
                    the differences between RAM and the file system. RAM stands for Random Access Memory. RAM is
                    volatile memory where the computer stores information about processes on which it is currently
                    working. Imagine you have a desk in an office. Throughout the day, your desk accumulates things:
                    quick notes about projects you are working on, an important document you need to reference for a
                    meeting, perhaps the agenda of a meeting, etc. At the end of the day, you clear your desk off,
                    dumping all the scraps of paper that have accumulated into the trash so you can start again fresh
                    tomorrow.</p>

                <p>In this example, the worker is the operating system, adding information into RAM as it is needed. The
                    operating system continuously cycles information in and out of RAM based on the requests a user
                    makes and the needs of the CPU. RAM is great for quick, temporary storage. Like putting a sticky
                    note on your desk, it takes the computer very little time to add something to RAM or find it again.
                    However, again like your sticky note, RAM is not the ideal long-term storage solution.</p>

                <p>It's important to understand that RAM is for short term use only. RAM is not used for any sort of
                    long-term storage. Any information that needs to be retrieved later is not stored in RAM because it
                    is volatile and its contents are lost when the computer is turned off or loses power. Programs
                    themselves are not saved in RAM, and important program files should not be saved there either.</p>

                <h4>What is a file system?</h4>
                <p>If program files are not saved in RAM, you may be wondering how and where they are saved. Since users
                    need long term and frequent access to program files, these files need to be saved in a non-volatile
                    location. This is where the file system comes in. A file system is a part of the operating system
                    that is used to save and organize files for non-volatile storage. The file system keeps track of
                    everything that is on the hard disk (what computer users typically think of as the computer's
                    memory) and organizes it for easy access and retrieval. The file system has two important roles.
                    First, it determines how and where information will be stored on a computer. Second, the file system
                    determines what types of additional information, or metadata, will additionally be stored. You may
                    have noticed we identified the file system as a part of the operating system. This is important;
                    file systems are operating system specific, and vary in functionality between Windows, Mac, and
                    Linux. This is one reason you may see different file extensions on a Mac and Windows machine (.exe
                    on Windows and .dmg on Mac, for example) and why file paths may look different between the two
                    operating systems.</p>

                <p>Let's take a quick look at the differences between RAM and the file system. As volatile memory, RAM
                    stores data that is being actively worked on or requested by the operating system. It is not used
                    for long-term storage of program files. In contrast, the file system organizes information for
                    long-term storage, allocating space in directories and maintaining metadata (which might include
                    something like the last time a file was accessed and which user accessed it). The following table
                    gives you a quick reference to the different purposes of RAM and the file system.</p>

                <h4>Comparison of Memory and Storage Types</h4>
                <table>
                    <tr>
                        <th>RAM</th>
                        <th>File System</th>
                    </tr>
                    <tr>
                        <td>Short-term, temporary storage</td>
                        <td>Long-term, stable storage</td>
                    </tr>
                    <tr>
                        <td>Quickest access and retrieval</td>
                        <td>Slower access and retrieval</td>
                    </tr>
                    <tr>
                        <td>Contents cleared when system shuts down</td>
                        <td>Contents preserved when system shuts down</td>
                    </tr>
                </table>

                <h4>Conclusion</h4>
                <p>At the beginning of this lesson, we introduced the idea of the computer as an ecosystem. The CPU does
                    the literal 'computing' work of a computer, but it only communicates in a language that is difficult
                    for users to interpret. Acting as an intermediary, the operating system takes in input in user
                    friendly ways, from keyboards to scanners, and it responds to users in similar user-friendly ways,
                    from display monitors to printers. To complete the tasks of translating and managing, the operating
                    system interacts with RAM for short-term notetaking and the file system for long term storage. Each
                    piece of this hardware ecosystem is necessary for the proper functioning of a computer, and each
                    piece completes a clearly defined set of functions. This lesson has explored how systems are
                    supposed to work when all parts of the ecosystem are communicating well with each other. In the next
                    lesson, we'll take a look at what happens when communication between these parts slows down.</p>
            </div>

            <div class="content-box">
                <h2>Core Computer Hardware Components</h2>

                <h3>Central Processing Unit (CPU)</h3>
                <p>The CPU is the brain of the computer, responsible for executing instructions and performing
                    calculations. Modern CPUs contain multiple cores, allowing for parallel execution of tasks.</p>

                <ul>
                    <li><strong>Instruction Cycle:</strong> Fetch, decode, execute, store</li>
                    <li><strong>CPU Cache:</strong> L1, L2, and L3 caches provide fast access to frequently used data
                    </li>
                    <li><strong>Clock Speed:</strong> Measured in GHz, indicates how many cycles per second</li>
                    <li><strong>Architecture:</strong> CISC vs. RISC design approaches</li>
                </ul>

                <h3>Memory (RAM)</h3>
                <p>Random Access Memory provides temporary, high-speed storage for data that the CPU needs to access
                    quickly. RAM is volatile, meaning its contents are lost when power is turned off.</p>

                <ul>
                    <li><strong>Types:</strong> DDR4, DDR5, etc.</li>
                    <li><strong>Capacity:</strong> Measured in gigabytes (GB)</li>
                    <li><strong>Access Time:</strong> Typically measured in nanoseconds</li>
                    <li><strong>Role:</strong> Stores currently running programs and their working data</li>
                </ul>

                <h3>Storage (HDD/SSD)</h3>
                <p>These provide persistent storage for the operating system, applications, and user data.</p>

                <ul>
                    <li><strong>Hard Disk Drives (HDD):</strong> Magnetic storage, slower but more affordable for large
                        capacities</li>
                    <li><strong>Solid State Drives (SSD):</strong> Flash memory-based storage, faster but more expensive
                    </li>
                    <li><strong>NVMe:</strong> Interface protocol designed to accelerate the transfer of data between
                        SSDs and a computer's CPU</li>
                    <li><strong>Access Times:</strong> Milliseconds (HDD) vs. microseconds (SSD)</li>
                </ul>

                <h3>Motherboard</h3>
                <p>The main circuit board that connects all components together, providing pathways for data transfer.
                </p>

                <ul>
                    <li><strong>Chipset:</strong> Controls communication between CPU, memory, and peripherals</li>
                    <li><strong>Bus:</strong> Pathway for data transfer between components</li>
                    <li><strong>Form Factors:</strong> ATX, Micro-ATX, Mini-ITX, etc.</li>
                    <li><strong>Expansion Slots:</strong> PCIe slots for graphics cards, network cards, etc.</li>
                </ul>
            </div>

            <div class="content-box">
                <h2>Identifying and Resolving Basic Performance Issues</h2>
                <p>Understanding hardware-software interactions helps identify and resolve performance bottlenecks.</p>

                <ul>
                    <li><strong>I/O Bottlenecks:</strong> Slow disk access, network latency</li>
                    <li><strong>CPU Bottlenecks:</strong> Compute-intensive operations, inefficient algorithms</li>
                    <li><strong>Memory Bottlenecks:</strong> Insufficient RAM, excessive paging</li>
                    <li><strong>Optimization Techniques:</strong> Caching, parallel processing, asynchronous I/O</li>
                </ul>

                <div class="video-container">
                    <iframe src="https://fast.wistia.net/embed/iframe/vxdxf5i9yi"
                        title="Understanding Performance Issues and Bottlenecks"
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen></iframe>
                </div>

                <h2>Overview</h2>
                <p>In the last reading we ran through how computers communicate both with the user and with different
                    parts of its system. The descriptions of how the CPU, OS, and RAM communicate with each other
                    demonstrated how each part interacts when all processes run smoothly. In this lesson, we'll look at
                    where processes spend their time and how different components can cause bottlenecks in the
                    execution. We'll talk about three specific ways a process can encounter a slowdown, and we will
                    learn to identify why a process is running slowly as well as how to potentially speed it up.</p>

                <p>Last lesson we discussed the CPU, RAM, and input/output devices (referred to simply as I/O for the
                    rest of the lesson) as an interconnected system. We learned how processes, or programs, on your
                    computer interact with each of these different systems. These processes can slow down if there is an
                    issue communicating with any of them. When a process becomes limited by the speed of a resource it
                    requires, we refer to the process as bound.</p>

                <h3>When things slow down: CPU-, I/O-, and memory-bound processes</h3>
                <p>A process, or application, can hit a bottleneck at many different points in its execution. In
                    software engineering, a bottleneck occurs when an application's performance is limited by a single
                    resource, like the neck of a bottle slowing down the overall water flow. The application is bound by
                    that resource. In this lesson, we will look at the differences between a CPU-bound process, an
                    I/O-bound process, and a memory-bound process. We'll also cover some basic ways to identify where a
                    process has become bound and discuss strategies for improving bound processes' performance.</p>

                <h3>CPU-bound processes</h3>
                <p>In the last lesson, we introduced the role of the CPU as doing the actual "computing" in a computer.
                    It follows then that a CPU-bound process is one that is limited by the speed and processing power of
                    the CPU. These are processes that typically spend an excessive amount of time calculating or
                    executing code. During this time, the CPU may be using nearly all of its processing power, from 90
                    -- 100%. Sometimes a process is only briefly CPU-bound. A word processor running spell check is a
                    great example of this issue. While spell check is running, the processes' CPU usage will spike; it
                    is nearly entirely consumed by running the spell check.</p>

                <p>It is fairly straightforward to identify when a process becomes CPU-bound on a personal computer.
                    Since CPU-bound means the process is being slowed down by the CPU, opening the Activity Monitor on
                    your Mac while a process is running and looking at the performance information in the CPU pane will
                    give you a clear picture of whether the process is CPU bound. (To locate the Activity Monitor, in
                    the Finder click the Go menu and choose Utilities to find and open the Activity Monitor.) In Figure
                    1, you can see the CPU pane on the Activity Monitor with the usage for each process currently
                    running, both actively and in the background. If one of these processes were to become CPU-bound,
                    the usage for that process would be high.</p>

                <img src="https://tk-assets.lambdaschool.com/349ee75b-6362-41c5-9013-251f79e97d8d_image1.png"
                    alt="Figure 1" loading="lazy"
                    style="max-width: 100%; height: auto; display: block; margin: 0 auto;">
                <p>Figure 1: The Activity Monitor showing the CPU utilization. Currently, WindowsServer is using the
                    greatest amount, but overall utilization is low.</p>

                <p>Later in this unit, we will discuss metrics that track CPU usage for the code you write and deploy,
                    and learn about how we can view and analyze this data.</p>

                <h3>I/O bound processes</h3>
                <p>A process that is I/O bound is one that is waiting for input or output operations. To understand
                    this, think again about a word processor. When you open a new document, the word processor is
                    waiting for your input via the keyboard to display output to you, which are the words you typed.
                    Processes don't run when they are actively waiting for input or output.</p>

                <p>In the previous lesson we discussed I/O as a primarily user-based, local system. In other words, we
                    used the examples of a mouse and keyboard as input and the monitor and speakers as output. However,
                    computers also have network I/O. Network I/O refers to when the computer is communicating with
                    another computer, receiving input and providing output to another system. If a process requires
                    information from another server, it must request it with a network call, and it waits for the other
                    server to respond. This can be another service that your code is calling or a database. During this
                    waiting time your process is blocked, meaning it cannot continue until the response comes back. A
                    lot of network calls can mean that your process is spending more time requesting and blocked waiting
                    for data than it is processing it. This is an example of an I/O bound application. The problem can
                    become even worse if the server your process is waiting on takes a long time to respond or never
                    responds at all!</p>

                <p>Identifying an I/O bound process involves a bit of an awareness about what your process is trying to
                    do. Does your process require information from a network server, or is it spending time reading and
                    writing from files? When this happens, your process stops and waits, so you'll experience a slowdown
                    but won't see a spike in your CPU. Knowing that your processes require I/O and observing what else
                    is happening on your system can help you identify that you should investigate the time spent
                    performing I/O. Later in this unit we will discuss ways of collecting and reviewing metrics such as
                    how long it takes for a round trip call to your database or a dependent service.</p>

                <h3>Memory bound processes</h3>
                <p>The final type of bound process we'll cover in this lesson is when a process becomes memory bound.
                    RAM is essentially the notepad a computer actively uses during processes to store the information it
                    needs to complete operations. If the speed of the process is limited due to the amount of available
                    notepad space, needing notes to be erased before new ones can be made, your process is memory bound.
                </p>

                <p>Imagine that in order to respond to a request, your code must do a calculation which requires a large
                    amount of data from your database. In order to complete this calculation, you need to query multiple
                    tables and store the data in memory while you compute a response. The computer needs to hold the
                    contents of the queries in RAM. Now, if your queries' responses were really large, it's possible
                    that the data could entirely fill your available RAM attempting to process the request. Any
                    intermediate objects created while doing the calculation can add additional strains on your memory
                    usage.</p>

                <p>To identify if your process is memory-bound locally, you can look again at the Activity Monitor. This
                    time, instead of looking at the CPU pane, select the Memory pane as shown in Figure 2. If the memory
                    usage is particularly high, your process may be memory-bound. It's important to remember that the
                    CPU and RAM on your computer are shared by all processes. The operating system makes decisions about
                    which processes have access to which resources and when, but if one process becomes either CPU or
                    memory bound, it will slow down all other processes (due to the amount of CPU utilization and memory
                    being used by the bound process). Furthermore, a process that is NOT bound when it is the only thing
                    running on your system may become bound when you try to do something else on your system.</p>

                <img src="https://tk-assets.lambdaschool.com/897fcdba-79bd-41c3-8769-3199c6483399_image2.png"
                    alt="Figure 2" loading="lazy"
                    style="max-width: 100%; height: auto; display: block; margin: 0 auto;">
                <p>Figure 2: The Activity Monitor showing memory usage. kernel_task is currently using the most memory,
                    but there is plenty of free memory in this image. You can see this by taking a look at the Memory
                    Pressure section in the bottom left.</p>

                <p>Later in this unit we will discuss metrics that tracks your code's memory usage, and we will learn
                    how we can view and analyze this data.</p>

                <h3>Improving performance</h3>
                <p>Once you've identified where the bottleneck is in your process, you can begin to take steps to
                    improve your process' performance. These steps will differ depending on the nature of the bound
                    process. We will look at some steps to take for each problem type.</p>

                <h4>Correcting CPU-bound process</h4>
                <p>For a CPU-bound process, you want to find ways to minimize CPU utilization or run the process on a
                    more powerful CPU. One simple way to improve performance on your personal computer might be to close
                    other applications that are running. This will free up some room for your CPU to handle your
                    process. If we're talking about code that you have written and deployed, one option would be to
                    simplify the operations that are being run within your process. This is where the runtime of an
                    algorithm can have its impacts. Refactoring code that uses an algorithm that runs in quadratic time,
                    O(n^2), for one that runs in linear time, O(n), can really improve the performance of your process.
                    This may be at the cost of requiring more space. Another way to reduce calculation time is to store
                    the results of a calculation to prevent your process from having to do it again and again. This also
                    comes at the cost of requiring more memory, but this might be a good option depending on your
                    process. We'll learn more about this when we get to caching later in the unit.</p>

                <h4>Fixing a memory bound process</h4>
                <p>Improving the performance of a memory bound system can be solved in similar ways to CPU bound
                    processes. You need to either put less demand on memory or get more memory. As we mentioned above,
                    on your personal computer you may close any other applications you have running. The more processes
                    you have active at any one time, the more requests each of them makes for space, the more likely you
                    are to run into a memory issue. If we're talking about code that you have written and deployed, one
                    option would be to reduce the need for additional space when performing operations run within your
                    process. Is there a more space efficient algorithm? If not, as we mentioned above, you can trade
                    runtime efficiency for space efficiency. Here you would be decreasing the runtime efficiency, but
                    also reducing the demands on memory.</p>

                <h4>Reducing I/O bound process issues</h4>
                <p>As SDEs at Amazon, our I/O bound applications will typically be bound by network calls. Network I/O
                    can be improved by upgrading your ethernet card (the network I/O component). However, the fastest
                    network is much slower than memory and processors. Since a process waiting for I/O can't do anything
                    else (it's blocked), we can try to reduce the number of blocking operations. We can do this by
                    taking advantage of our faster memory. If the same data may be required multiple times, we can
                    perform I/O the first time and save the result in memory, retrieving it quickly in the future. This
                    is called "caching", and we'll cover it in more detail in a later lesson. If we cannot reduce our
                    I/O operations, we can consider utilizing our powerful CPU while we are blocked. If some portion of
                    our process does not require the results of the network I/O results, we can also execute that on the
                    processor while waiting for a response. This is called "concurrency", which we will also learn about
                    in a later lesson.</p>

                <h3>Conclusion</h3>
                <p>In this lesson, we learned about common circumstances for bound processes and how different
                    components can be the cause of bottlenecks in execution. Understanding how a process can suffer from
                    slowdowns will help you identify and optimize a process for greater efficiency.</p>
            </div>

            <div class="content-box">
                <h2>Operating System and Resource Management</h2>

                <p>The operating system (OS) is system software that manages computer hardware, software resources, and
                    provides services for computer programs.</p>

                <h3>Memory Management</h3>
                <p>Memory is organized in a hierarchy, with faster but smaller storage at the top and slower but larger
                    storage at the bottom.</p>

                <ul>
                    <li><strong>Registers:</strong> Fastest memory, inside the CPU</li>
                    <li><strong>Caches (L1, L2, L3):</strong> Small, fast memory between CPU and RAM</li>
                    <li><strong>Main Memory (RAM):</strong> Primary working memory</li>
                    <li><strong>Secondary Storage:</strong> Hard drives, SSDs</li>
                    <li><strong>Tertiary Storage:</strong> Tape drives, optical media</li>
                </ul>

                <p>Understanding this hierarchy is crucial for optimizing software performance.</p>
            </div>

            <div class="content-box">
                <h3>File System Management</h3>
                <p>The operating system manages file systems, organizing and controlling access to files. It provides a
                    hierarchical structure for organizing files and directories.</p>
            </div>

            <div class="content-box">
                <h3>JVM Tuning</h3>
                <p>Java Virtual Machine (JVM) tuning involves optimizing the JVM to improve the performance of Java
                    applications. This includes adjusting garbage collection settings, heap size, and other parameters.
                </p>
            </div>

            <div class="content-box">
                <h3>Monitoring and Profiling</h3>
                <p>Monitoring and profiling tools help identify performance bottlenecks and optimize software. Tools
                    like VisualVM, JConsole, and YourKit can provide detailed insights into application performance.</p>
            </div>

            <div class="content-box">
                <h2>Guided Project</h2>

                <div class="video-container">
                    <iframe src="https://fast.wistia.net/embed/iframe/8ifjf2szjv"
                        title="Computer Hardware and OS Guided Project"
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen></iframe>
                </div>

                <div class="resource-links">
                    <a href="https://github.com/BloomTechBackend/bd-intro-to-hardware-and-operating-systems"
                        target="_blank" rel="noopener noreferrer" class="resource-link">
                        Starter: Intro to Hardware and Operating Systems
                    </a>
                </div>
            </div>

            <div class="content-box">
                <h2>Mastery Task 3: Query, Query on the Wall</h2>
                <p>Mastery Task 3: Query, query on the wall, don't load just one, get them all!</p>

                <p>Next we'll work on the operation that allows a client to check in on the state of their publishing
                    request, GetPublishingStatus. When a book is submitted for publishing via our
                    SubmitBookForPublishing operation, we write to DynamoDB that the request had been queued. We store
                    an item in the table with the keys: {partition: publishingstatus.123, sort: QUEUED}. When the actual
                    publishing logic is implemented it will create a new item in DynamoDB when the request starts to be
                    processed: {partition: publishingstatus.123, sort: IN_PROGRESS}. Finally, when publishing has
                    completed, the publishing logic will again write to DynamoDB: {partition: publishingstatus.123,
                    sort: SUCCEEDED}.</p>

                <p>A call to GetPublishingStatus should retrieve each of the items from DynamoDB that correspond to the
                    provided publishingStatusId. If no items are found, the provided PublishingStatusNotFoundException
                    should be thrown.</p>

                <p>Create the GetPublishingStatusActivity class and implement the GetPublishingStatus operation using
                    the design documentation's implementation notes and sequence diagram. When populating the response,
                    you will need to convert the list of PublishingStatusItems to a list of PublishingStatusRecords.
                    Follow the pattern used in GetBookActivity when converting the list of BookRecommendations.</p>

                <p>Since we haven't implemented the publishing logic, we can't easily generate test data to retrieve
                    with our new API. We have populated your PublishingStatus table with a few complete publishing
                    status histories to help out with your testing. The table below contains publishingStatusIds that
                    you can use for the described test case.</p>

                <table>
                    <tr>
                        <th>test case</th>
                        <th>publishingStatusId</th>
                    </tr>
                    <tr>
                        <td style="padding-right: 20px;">successful publishing process</td>
                        <td>publishingstatus.bdd319cb-05eb-494b-983f-6e1b983c4c46</td>
                    </tr>
                    <tr>
                        <td style="padding-right: 20px;">failed publishing process</td>
                        <td>publishingstatus.4bd41646-b1b2-4627-8304-5180c9b54e00</td>
                    </tr>
                    <tr>
                        <td style="padding-right: 20px;">successful new version published</td>
                        <td>publishingstatus.2bc206a1-5b41-4782-a260-976c0a291825</td>
                    </tr>
                </table>

                <p>Run MasteryTaskThreeTests workflow to validate your changes.</p>

                <h3>Exit Checklist:</h3>
                <ul>
                    <li>You've implemented GetPublishingStatus's functionality</li>
                    <li>MasteryTaskThreeTests passes</li>
                </ul>
            </div>

            <section class="resource-section">
                <h2 class="resource-section-title">Additional Resources</h2>
                <div class="resource-links">
                    <a href="https://docs.oracle.com/javase/tutorial/essential/environment/index.html" target="_blank"
                        rel="noopener noreferrer" class="resource-link">
                        Java Environment Documentation
                    </a>
                    <a href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html" target="_blank"
                        rel="noopener noreferrer" class="resource-link">
                        Java Command Line Reference
                    </a>
                    <a href="https://docs.oracle.com/en/java/javase/17/gctuning/introduction-garbage-collection-tuning.html"
                        target="_blank" rel="noopener noreferrer" class="resource-link">
                        Garbage Collection Tuning Guide
                    </a>
                </div>
            </section>
        </section>
    </main>
</body>

</html>