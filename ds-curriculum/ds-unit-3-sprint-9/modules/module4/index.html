<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 4: Software Testing, Documentation, and Licensing</title>
    <link rel="stylesheet" href="../../../css/style.css">
</head>

<body>
    <header>
        <nav>
            <div class="logo">Data Science Unit 3</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module1/index.html">Module 1: Python Modules Packages Environments</a>
                        <a href="../module2/index.html">Module 2: OOP-Code-Style-Reviews</a>
                        <a href="../module3/index.html">Module 3: Containers and Reproducible Builds</a>
                        <a href="../module4/index.html" class="active">Module 4: Software Testing Documentation
                            Licensing</a>
                    </div>
                </li>
                <li><a href="../../code-alongs/index.html">Code-Alongs</a></li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <h1>Module 4: Software Testing, Documentation, and Licensing</h1>

        <section class="content-box">
            <h2>Module Overview</h2>
            <p>You've written your code using OOP; it runs and works, it's in a package, and you can even run it in a
                reproducible container. You're done, right? Nope!</p>
            <p>To effectively share your code in a way that will be lastingly useful, you also need to test and
                document. These are not just "overhead" tasks - they are a core part of software engineering, and code
                that lacks these properties is essentially impossible to maintain or build on in the long term.</p>
            <p>Last but not least, you need to choose an appropriate license for your code and make sure you understand
                the licenses of your dependencies and the ecosystem in general. You don't need a law degree, but there
                are significant differences between licenses you should understand, even ones that all count as "open
                source."</p>
        </section>

        <section class="content-box">
            <h2>Learning Objectives</h2>
            <ul>
                <li>Understand the purpose of software testing, and be able to write basic unit tests</li>
                <li>Read and write quality comments and READMEs</li>
                <li>Recognize major open-source licenses and their significance for personal and professional use</li>
            </ul>
        </section>

        <section class="content-box">
            <h2>Objective 01 - understand purpose of and approaches towards software testing and write basic unit tests
            </h2>
            <h3>Required Resources</h3>
            <ul>
                <li>
                    <a href="#" target="_blank" rel="noopener noreferrer">Unit testing framework</a>
                </li>
                <li>
                    <a href="#" target="_blank" rel="noopener noreferrer">Framework: pytest</a>
                </li>
            </ul>
            <h3>Overview</h3>
            <p>When you say “the code works”, what do you really mean? Generally you mean that, when the system/function
                is run with given input, the output/behavior is as expected (and hopefully documented).</p>
            <p>Software testing formally specifies this, and provides a framework for automatically verifying that code
                really passes the tests. This helps you avoid regressions - no, not the statistical models, but rather
                the literal meaning of “going backwards” with your code (introducing bugs/errors). You may have already
                seen this, and already ran software tests - in your coding challenges!</p>
            <p>The simplest possible test requires the simplest possible piece of code - a unit. What is a unit?</p>
            <p>In many cases it is just a function (or, if that function is a member of a class, remember it is called a
                method). For larger/more complicated code, it may be you write different unit tests for different cases
                of a function call, each passing different arguments in and testing for expected output.</p>
            <p>Unit tests are the most basic, well, unit of testing. There are more sophisticated tests - integration
                tests combine modules into a group and test their joint behavior, and end-to-end tests simulate an
                entire user flow/interaction. These larger tests are arguably more effective at catching tricky bugs -
                you can have “100% unit test coverage” and still miss things if you don’t test things combined.</p>
            <p>But there is one important advantage to unit tests, and a reason to not neglect them entirely - they may
                not catch every bug, but they do force you to think of your code in units. A good unit test requires
                good code to test, and so you may find yourself refactoring your code in order to make it more testable.
                Embrace this! It’s one of the biggest advantages of proper software testing.</p>
            <h3>Follow Along</h3>
            <p>To write unit tests, we will use unittest, a package included in the Python standard library (i.e. no
                special installation needed).</p>
            <p>Consider the following example:</p>
            <pre><code>import unittest
class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()
</code></pre>
            <p>This tests basic string methods (i.e. the “units” being tested are already written and built-in to
                Python). The overall test case is a class, inheriting from unittest.TestCase, and the methods in the
                class are specific tests.</p>
            <p>Save the code to a file <code>string_tests.py</code>, and execute with
                <code>python string_tests.py</code>. You should see:</p>
            <pre><code>...
----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK
</code></pre>
            <p>What happened? The default response when tests pass is to be silent - this just means all the tests
                passed. Try running again as verbose with <code>python string_tests.py -v</code>:</p>
            <pre><code>test_isupper (__main__.TestStringMethods) ... ok
test_split (__main__.TestStringMethods) ... ok
test_upper (__main__.TestStringMethods) ... ok

----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK
</code></pre>
            <p>Now you see it checking off each individual test and saying that it passed.</p>
            <p>What does it look like when a test fails? It’s noisier!</p>
            <p>Python string methods are pretty well-written, so to get a failing test let’s introduce a bug into the
                test itself:</p>
            <pre><code>    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FO')  # bug in test!
</code></pre>
            <p>Now run <code>python string_tests.py</code> again:</p>
            <pre><code>..F
======================================================================
FAIL: test_upper (__main__.TestStringMethods)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "string_tests.py", line 6, in test_upper
    self.assertEqual('foo'.upper(), 'FO')  # bug in test!
AssertionError: 'FOO' != 'FO'
- FOO
?   -
+ FO


----------------------------------------------------------------------
Ran 3 tests in 0.001s

FAILED (failures=1)
</code></pre>
            <p>Failure! Specifically, the assertion <code>self.assertEqual('foo'.upper(), 'FO')</code> failed, as
                <code>'foo'.upper()</code> is equal to FOO.</p>
            <p>The above is the minimal viable approach to testing basic expected code behavior - you can make unit
                tests more complicated, with <code>setUp()</code> and <code>tearDown()</code> methods in the class to do
                setup/cleanup behavior before/after tests. You can also use <code>unittest.mock</code> to make “fake”
                objects, e.g. a fake database connection, so that a unit test can run without hitting real systems.</p>
            <p>Advanced testing is beyond the scope for today, and in general is unlikely to be your core responsibility
                as a data scientist (there exist specific software test engineers). But it’s good to be aware of its
                existence, and that a codebase is only as healthy as its test suite.</p>
            <h3>Challenge</h3>
            <p>Write a unit test for one of the functions or methods (pop quiz - what’s the difference?) in your
                bloomdata package.</p>
            <h3>Additional Resources</h3>
            <ul>
                <li>
                    <a href="#" target="_blank" rel="noopener noreferrer">OOP Review Assignment - A great review of OOP
                        and testing - ace this, and the sprint challenge will be no sweat!</a>
                </li>
                <li>
                    <a href="#" target="_blank" rel="noopener noreferrer">Python typing module</a>
                </li>
                <li>
                    <a href="#" target="_blank" rel="noopener noreferrer">Travis CI - A continuous integration
                        (automatically run tests) platform</a>
                </li>
            </ul>
        </section>

        <section class="content-box">
            <h2>Objective 02 - read and write quality comments-documentation and READMEs</h2>
            <h3>Overview</h3>
            <p>“Everyone knows that debugging is twice as hard as writing a program in the first place. So if you’re as
                clever as you can be when you write it, how will you ever debug it?” - Brian Kernighan in “The Elements
                of Programming Style”Links to an external site.</p>
            <p>Every topic we’ve covered this week helps us address the above dilemma, but documentation plays a
                particularly key role. It’s where you write those things that the code itself doesn’t quite say, but you
                had to think through to be able to come up with it. Your coworkers (and future you) will thank you!</p>
            <p>You read more code than you write - and the more experience you get and the higher your position, the
                more that is true. So when you write code, you should always remember that it’s not good enough for it
                to just run. Obviously that matters, but it’s also important that your code can be read - that is,
                understood by another human, be it a coworker, or just you but in the future.</p>
            <p>Code that runs assigns and moves the bytes that the computer wants and understands - one of the biggest
                challenges of coding is “thinking like a computer” and writing code that does what it should. But your
                human “mental state” when writing that code is extremely temporary - it requires great focus to write
                complicated code, and you’ll quickly forget the details within weeks if not days.</p>
            <p>How do we send information to the future? We write it down! Comments, Pydoc, and READMEs are how we (as
                Python developers) save our human mental state, and share it with whoever works with our code in the
                future.</p>
            <h3>Follow Along</h3>
            <p>There are two sorts of comments in Python:</p>
            <h4>Inline comment</h4>
            <pre><code># This is an inline comment
</code></pre>
            <pre><code>"""
Multi
Line
Comment
"""</code></pre>
            <p>Both are useful, but serve different purposes - an inline comment is a brief annotation, to indicate the
                meaning (or “trick”) of a line or maybe a few lines of code.</p>
            <p>Multi-line comments, aka docstrings, (which are technically strings, but are ignored by the interpreter
                as they aren’t being assigned to anything) are documentation, and can describe details such as the
                argument and return types of a function, links to resources, etc. They’re what the help() function grabs
                to explain things in the repl, and there’s a tool named PydocLinks to an external site. that extracts
                docstrings and generates HTML (this is how a lot of code documentation sites are built!).</p>
            <h3>Challenge</h3>
            <p>Go back to your bloomdata project, and make sure you’ve added comments as appropriate. In particular,
                have docstrings wherever PEP8 suggests - then build/import your module and try the help() function on
                your code. For an extra goal - try building HTML documentation with pydoc - you can even put it in a
                docs/ directory and push to GitHub to deploy with GitHub Pages!</p>
            <h3>Additional Resources</h3>
            <ul>
                <li>Pandas docstring guideLinks to an external site.</li>
                <li>Sphinx Python Documentation GeneratorLinks to an external site.</li>
                <li>Literate programming (Wikipedia)Links to an external site.</li>
            </ul>
        </section>

        <section class="content-box">
        </section>

        <section class="content-box">
            <h2>Guided Project</h2>

            <p>In this guided project, we'll learn how to write effective tests, documentation, and choose appropriate
                licenses for our code. Open <strong>guided-project.md</strong> in the GitHub repository below to follow
                along with the guided project.</p>

            <div class="resource-links">
                <a href="https://github.com/bloominstituteoftechnology/DS-Unit-3-Sprint-1-Software-Engineering/tree/main/module4-software-testing-documentation-and-licensing"
                    class="resource-link" target="_blank" rel="noopener noreferrer">GitHub Repo</a>
                <a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account"
                    class="resource-link" target="_blank" rel="noopener noreferrer">Adding new SSH key to GitHub</a>
                <a href="https://github.com/bloominstituteoftechnology/DS-Unit-3-Setup#git-cli-command-line-interface-installation"
                    class="resource-link" target="_blank" rel="noopener noreferrer">Git Command Line Tool
                    Installation</a>
            </div>

            <div class="video-container">
                <iframe src="https://fast.wistia.net/embed/iframe/1yc54xw27p" allowtransparency="true" frameborder="0"
                    scrolling="no" class="wistia_embed" name="wistia_embed"
                    title="Module 4 Guided Project: Testing, Documentation, and Licensing" allowfullscreen
                    mozallowfullscreen webkitallowfullscreen oallowfullscreen msallowfullscreen></iframe>
            </div>
        </section>

        <section class="content-box">
            <h2>Module Assignment</h2>
            <p>For this assignment, you'll implement software testing, documentation, and licensing practices to create
                professional-quality code that follows industry standards.</p>

            <div class="resource-links">
                <a href="https://github.com/bloominstituteoftechnology/DS-Unit-3-Sprint-1-Software-Engineering/blob/main/module4-software-testing-documentation-and-licensing/assignment.md"
                    class="resource-link" target="_blank" rel="noopener noreferrer">Module 4 Assignment</a>
            </div>

            <h3>Solution Video</h3>
            <div class="video-container">
                <iframe src="https://fast.wistia.net/embed/iframe/4jfxn5gr0m" allowtransparency="true" frameborder="0"
                    scrolling="no" class="wistia_embed" name="wistia_embed" title="Module 4 Assignment Solution Video"
                    allowfullscreen mozallowfullscreen webkitallowfullscreen oallowfullscreen
                    msallowfullscreen></iframe>
            </div>
        </section>

        <section class="content-box">
            <h2>Additional Resources</h2>
            <h3>Testing</h3>
            <ul>
                <li><a href="https://docs.python.org/3/library/unittest.html" target="_blank"
                        rel="noopener noreferrer">Framework:
                        unittest</a></li>
                <li><a href="https://docs.pytest.org/en/latest/" target="_blank" rel="noopener noreferrer">Framework:
                        pytest</a>
                </li>
            </ul>

            <h3>Documentation</h3>
            <ul>
                <li><a href="https://docs.python.org/3/library/pydoc.html" target="_blank"
                        rel="noopener noreferrer">Python pydoc
                        documentation</a></li>
                <li><a href="https://www.sphinx-doc.org/en/master/" target="_blank" rel="noopener noreferrer">Sphinx
                        Documentation
                        Generator</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Literate_programming" target="_blank"
                        rel="noopener noreferrer">Literate
                        programming</a></li>
            </ul>

            <h3>Licensing</h3>
            <ul>
                <li><a href="https://writing.kemitchell.com/2016/09/21/MIT-License-Line-by-Line.html" target="_blank"
                        rel="noopener noreferrer">MIT License, Line by Line</a></li>
                <li><a href="https://creativecommons.org/" target="_blank" rel="noopener noreferrer">Creative
                        Commons</a></li>
                <li><a href="https://opensource.org/licenses" target="_blank" rel="noopener noreferrer">Open Source/OSI
                        Approved
                        Licenses</a></li>
            </ul>

            <h3>Additional Tools</h3>
            <ul>
                <li><a href="https://travis-ci.org/" target="_blank" rel="noopener noreferrer">Travis CI</a></li>
                <li><a href="https://github.com/lambdaschool/DS-OOP-Review" target="_blank"
                        rel="noopener noreferrer">OOP Review
                        Assignment</a></li>
                <li><a href="https://docs.python.org/3/library/typing.html" target="_blank"
                        rel="noopener noreferrer">Python typing
                        module</a></li>
            </ul>
        </section>
    </main>
</body>

</html>