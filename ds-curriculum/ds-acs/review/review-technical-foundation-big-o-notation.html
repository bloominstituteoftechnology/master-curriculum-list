<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Review Technical Foundation: Big O Notation</title>
  <meta name="identifier" content="gf15a3915f86191cfa7f187333ec758bf" />
  <meta name="editing_roles" content="teachers" />
  <meta name="workflow_state" content="active" />
  <style>
    /* Dark theme styles */
    body {
      background-color: #1e1e1e;
      color: #e0e0e0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    h2,
    h3,
    h4 {
      color: #bbb;
      margin-top: 25px;
      margin-bottom: 15px;
    }

    a {
      color: #61afef;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    p,
    ul,
    ol {
      margin-bottom: 15px;
    }

    ul,
    ol {
      padding-left: 25px;
    }

    li {
      margin-bottom: 8px;
    }

    .code-block {
      background-color: #2c2c2c;
      padding: 15px;
      border-radius: 5px;
      margin: 15px 0;
      font-family: 'Courier New', Courier, monospace;
      white-space: pre;
      overflow-x: auto;
      color: #d4d4d4;
      border: 1px solid #444;
    }

    .leetcode-link {
      color: #e6b450;
      text-decoration: none;
    }

    .leetcode-link:hover {
      text-decoration: underline;
    }

    .concept-section {
      margin-bottom: 20px;
      padding: 15px;
      border-left: 3px solid #93005a;
      background-color: #252525;
      border-radius: 0 5px 5px 0;
    }

    .complexity-table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
      border-radius: 5px;
      overflow: hidden;
    }

    .complexity-table th,
    .complexity-table td {
      border: 1px solid #444;
      padding: 12px;
    }

    .complexity-table th {
      background-color: #333;
      text-align: left;
    }

    .complexity-table tr:nth-child(even) {
      background-color: #2a2a2a;
    }

    iframe {
      border: none;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
  </style>
</head>

<body>
  <div class="concept-section">
    <h2>Big O Notation: Understanding Algorithm Efficiency</h2>
    <p>Big O notation is a fundamental concept in computer science used to describe the performance or complexity of an
      algorithm. It provides a standardized way to express how the runtime or space requirements of an algorithm grow as
      the input size increases.</p>

    <p>After reviewing this material, you will be able to:</p>
    <ul>
      <li>Analyze algorithms to determine their time and space complexity</li>
      <li>Compare algorithms based on their efficiency</li>
      <li>Recognize common time complexities (O(1), O(log n), O(n), O(n log n), O(n²), etc.)</li>
      <li>Apply optimization techniques to improve algorithm efficiency</li>
      <li>Make informed decisions about algorithm selection for specific problems</li>
    </ul>
  </div>

  <p><span>As you go through the topics covered in this unit, you will see the importance of Big O Notation. For
      example, you will be able to assess and choose sorting algorithms based on efficiency according to some predefined
      inputs.&nbsp;</span></p>

  <p>Watch this video to learn more about Big O Notation. This video will cover:</p>
  <ul>
    <li aria-level="1"><span>How complex algorithms are in time and space</span></li>
    <li aria-level="1"><span>How Big O notation translates this complexity and how it can be used to rank algorithms
        regarding their efficiency</span></li>
    <li aria-level="1"><span>Why knowing about Big O Notation is important for job interviews and the GCA</span></li>
  </ul>

  <p><strong><iframe class="wistia_embed" title="ACS Sprints 12, 24 Module 2 CC Big O Notation Video"
        src="https://fast.wistia.net/embed/iframe/rtrnfk2g7y" width="640" height="360" name="wistia_embed"
        allow="fullscreen" loading="lazy"></iframe></strong></p>

  <h3>Common Time Complexities Explained</h3>

  <table class="complexity-table">
    <tr>
      <th>Notation</th>
      <th>Name</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>O(1)</td>
      <td>Constant</td>
      <td>Runtime is independent of input size</td>
      <td>Array access, hash table insertion/retrieval</td>
    </tr>
    <tr>
      <td>O(log n)</td>
      <td>Logarithmic</td>
      <td>Runtime grows logarithmically with input size</td>
      <td>Binary search, balanced search trees</td>
    </tr>
    <tr>
      <td>O(n)</td>
      <td>Linear</td>
      <td>Runtime grows linearly with input size</td>
      <td>Simple traversal, linear search</td>
    </tr>
    <tr>
      <td>O(n log n)</td>
      <td>Linearithmic</td>
      <td>Combination of linear and logarithmic growth</td>
      <td>Efficient sorting algorithms (merge sort, quicksort)</td>
    </tr>
    <tr>
      <td>O(n²)</td>
      <td>Quadratic</td>
      <td>Runtime grows with the square of input size</td>
      <td>Nested loops, bubble sort, insertion sort</td>
    </tr>
    <tr>
      <td>O(2^n)</td>
      <td>Exponential</td>
      <td>Runtime doubles with each additional input element</td>
      <td>Recursive solutions without memoization</td>
    </tr>
  </table>

  <h3>Code Examples with Different Time Complexities</h3>

  <h4>O(1) - Constant Time</h4>
  <div class="code-block">
    # O(1) - Accessing an array element
    def get_element(arr, index):
    return arr[index] # Direct access, always same number of operations

    # O(1) - Dictionary lookup
    def has_key(obj, key):
    return key in obj # Direct hash lookup
  </div>

  <h4>O(log n) - Logarithmic Time</h4>
  <div class="code-block">
    # O(log n) - Binary search
    def binary_search(sorted_array, target):
    left = 0
    right = len(sorted_array) - 1
    while left <= right: mid=(left + right) // 2 if sorted_array[mid]==target: return mid # Found the target elif
      sorted_array[mid] < target: left=mid + 1 # Search in the right half else: right=mid - 1 # Search in the left half
      return -1 # Target not found </div>

      <h4>O(n) - Linear Time</h4>
      <div class="code-block">
        # O(n) - Linear search
        def linear_search(array, target):
        for i, value in enumerate(array):
        if value == target:
        return i
        return -1

        # O(n) - Find maximum value
        def find_max(array):
        max_val = array[0]
        for value in array[1:]:
        if value > max_val:
        max_val = value
        return max_val
      </div>

      <h4>O(n log n) - Linearithmic Time</h4>
      <div class="code-block">
        # O(n log n) - Merge sort
        def merge_sort(array):
        if len(array) <= 1: return array mid=len(array) // 2 left=merge_sort(array[:mid]) right=merge_sort(array[mid:])
          return merge(left, right) def merge(left, right): result=[] i=j=0 while i < len(left) and j < len(right): if
          left[i] <=right[j]: result.append(left[i]) i +=1 else: result.append(right[j]) j +=1 result.extend(left[i:])
          result.extend(right[j:]) return result </div>

          <h4>O(n²) - Quadratic Time</h4>
          <div class="code-block">
            # O(n^2) - Bubble sort
            def bubble_sort(array):
            n = len(array)
            for i in range(n):
            for j in range(n - i - 1):
            if array[j] > array[j + 1]:
            array[j], array[j + 1] = array[j + 1], array[j]
            return array

            # O(n^2) - Checking all pairs in an array
            def find_all_pairs(array):
            pairs = []
            n = len(array)
            for i in range(n):
            for j in range(i + 1, n):
            pairs.append((array[i], array[j]))
            return pairs
          </div>

          <h3>Space Complexity</h3>
          <p>Space complexity refers to the amount of memory an algorithm uses relative to its input size. Like
            time complexity, it's also expressed using Big O notation.</p>

          <div class="code-block">
            # O(1) space complexity - constant extra space
            def sum_array(arr):
            total = 0 # single variable, constant space
            for num in arr:
            total += num
            return total

            # O(n) space complexity - linear extra space
            def create_doubled_array(arr):
            doubled = [] # new array that grows with input size
            for num in arr:
            doubled.append(num * 2)
            return doubled
          </div>

          <h3>Practice with LeetCode Problems</h3>

          <p>Note: Previously, this course referenced the CodeSignal Arcade for practice, which is no longer
            available. The LeetCode problems below follow the same principles and are an excellent alternative
            for practicing algorithm efficiency and preparing for technical interviews.</p>

          <h4>Problems by Time Complexity:</h4>

          <p><strong>O(1) and O(log n) Problems:</strong></p>
          <ul>
            <li><a href="https://leetcode.com/problems/search-in-a-binary-search-tree/" class="leetcode-link"
                target="_blank" rel="noopener noreferrer">Search in a Binary Search Tree</a> - Practice O(log
              n) binary search tree traversal</li>
            <li><a href="https://leetcode.com/problems/power-of-two/" class="leetcode-link" target="_blank"
                rel="noopener noreferrer">Power of Two</a> - Solve in O(1) time using bit manipulation</li>
          </ul>

          <p><strong>O(n) Problems:</strong></p>
          <ul>
            <li><a href="https://leetcode.com/problems/two-sum/" class="leetcode-link" target="_blank"
                rel="noopener noreferrer">Two Sum</a> - Can be solved in O(n) time with a hash map</li>
            <li><a href="https://leetcode.com/problems/maximum-subarray/" class="leetcode-link" target="_blank"
                rel="noopener noreferrer">Maximum Subarray</a> - Practice Kadane's algorithm
              (O(n))</li>
          </ul>

          <p><strong>O(n log n) Problems:</strong></p>
          <ul>
            <li><a href="https://leetcode.com/problems/sort-an-array/" class="leetcode-link" target="_blank"
                rel="noopener noreferrer">Sort an Array</a> - Implement efficient sorting algorithms</li>
            <li><a href="https://leetcode.com/problems/merge-intervals/" class="leetcode-link" target="_blank"
                rel="noopener noreferrer">Merge Intervals</a> - Requires sorting, then linear processing</li>
          </ul>

          <p><strong>Algorithm Optimization Problems:</strong></p>
          <ul>
            <li><a href="https://leetcode.com/problems/contains-duplicate/" class="leetcode-link" target="_blank"
                rel="noopener noreferrer">Contains Duplicate</a> - Compare O(n²) vs O(n)
              approaches</li>
            <li><a href="https://leetcode.com/problems/find-peak-element/" class="leetcode-link" target="_blank"
                rel="noopener noreferrer">Find Peak Element</a> - Can be optimized from O(n)
              to O(log n)</li>
          </ul>

          <h3>Big O Cheat Sheet Summary</h3>

          <p>When analyzing algorithms, remember these key principles:</p>

          <ul>
            <li><strong>Focus on the dominant term:</strong> Drop constants and lower-order terms (e.g., O(2n)
              → O(n), O(n² + n) → O(n²))</li>
            <li><strong>Consider worst-case scenario:</strong> Unless specified otherwise, Big O represents
              the upper bound (worst case)</li>
            <li><strong>Analyze both time and space:</strong> Sometimes you can trade one for the other</li>
            <li><strong>Context matters:</strong> O(n log n) might be better than O(n) if the constant factors
              are vastly different</li>
          </ul>

          <p>Understanding Big O notation will help you make informed decisions about algorithm selection and
            optimization, which is crucial for both technical interviews and real-world software development.
          </p>

</body>

</html>