<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guided Project: Graphs I</title>
    <meta name="identifier" content="g01f9eb02c97e2e7a4de50690705d50ee" />
    <meta name="editing_roles" content="teachers" />
    <meta name="workflow_state" content="unpublished" />
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #1a1d23;
            /* Dark background color */
            color: #ffffff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #222831;
            /* Darker container background */
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        h1,
        h2,
        h3,
        h4 {
            color: #ffffff;
            margin: 0;
        }

        h1 {
            color: #ffffff;
            margin-bottom: 30px;
            border-bottom: 2px solid #ff5722;
            /* Orange accent color */
            padding-bottom: 10px;
            text-align: center;
            font-size: 2.5rem;
        }

        h2 {
            color: #ffffff;
            margin-top: 10px;
            margin-bottom: 20px;
            font-size: 1.75rem;
        }

        h3 {
            color: #ff5722;
            /* Orange accent color */
            margin-top: 0;
            font-size: 1.25rem;
            margin-bottom: 15px;
        }

        h4 {
            color: #ffffff;
            margin-top: 10px;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        p {
            color: #b3b3b3;
            margin-bottom: 16px;
        }

        /* Navigation */
        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .nav-link {
            color: #ff5722;
            text-decoration: none;
            display: flex;
            align-items: center;
            transition: color 0.2s;
        }

        .nav-link:hover {
            color: #ff7043;
            text-decoration: underline;
        }

        .nav-link svg {
            width: 20px;
            height: 20px;
            margin-right: 8px;
        }

        /* Header */
        .header-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .header-description {
            max-width: 800px;
            margin: 0 auto;
            margin-top: 15px;
            font-size: 1.2rem;
        }

        /* Section styling */
        .section {
            margin-bottom: 40px;
            background-color: #2a303c;
            border-radius: 4px;
            padding: 20px;
            border: 1px solid #333a47;
        }

        /* Content wrapper */
        .content-wrapper {
            margin-top: 30px;
        }

        /* Code blocks */
        .code-block {
            background-color: #1a1d23;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
            overflow-x: auto;
        }

        code {
            color: #e0e0e0;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre;
            font-size: 1rem;
        }

        /* Example usage */
        .info-box {
            background-color: #333a47;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }

        /* Lists */
        ul,
        ol {
            color: #b3b3b3;
            padding-left: 20px;
            margin-left: 0;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 10px;
        }

        /* Video container */
        .wistia-responsive-padding {
            padding: 56.25% 0 0 0;
            position: relative;
        }

        .wistia-responsive-wrapper {
            height: 100%;
            left: 0;
            position: absolute;
            top: 0;
            width: 100%;
        }

        .video-container {
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        /* Links */
        .link {
            color: #ff5722;
            text-decoration: none;
            transition: color 0.2s;
        }

        .link:hover {
            color: #ff7043;
            text-decoration: underline;
        }

        /* Spacing utilities */
        .space-y {
            margin-bottom: 30px;
        }

        /* Grid layout */
        .grid {
            display: grid;
            gap: 20px;
        }

        .grid-cols-1 {
            grid-template-columns: 1fr;
        }

        @media (min-width: 768px) {
            .grid-cols-2 {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Tab navigation */
        .tab-navigation {
            display: flex;
            border-bottom: 1px solid #333a47;
            margin-bottom: 30px;
        }

        .tab-button {
            background: none;
            border: none;
            color: #b3b3b3;
            padding: 12px 16px;
            margin-right: 20px;
            font-size: 1rem;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab-button:hover {
            color: #ffffff;
        }

        .tab-button.active {
            color: #ff5722;
            border-bottom: 2px solid #ff5722;
        }

        /* Hidden content */
        .hidden {
            display: none;
        }

        /* Example scenarios */
        .example-box {
            background-color: #333a47;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .example-code {
            background-color: #1a1d23;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            color: #e0e0e0;
            margin-top: 8px;
        }

        /* Strong emphasis */
        strong {
            color: #fff;
            font-weight: bold;
        }
    </style>
    <script>
        function switchTab(tabId, element) {
            document.querySelectorAll('[data-tab-content]').forEach(content => {
                content.classList.add('hidden');
            });
            document.querySelectorAll('[data-tab]').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-tab-content="${tabId}"]`).classList.remove('hidden');
            element.classList.add('active');
        }
    </script>
</head>

<body>
    <div class="container">
        <!-- Navigation -->
        <div class="nav-container">
            <a href="../welcome.html" class="nav-link">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
                <span>Back to Main ACS Page</span>
            </a>
        </div>

        <!-- Header Section -->
        <div class="header-section">
            <h1>Guided Project: Detecting Cycles in Graphs</h1>
            <p class="header-description">
                Learn how to implement cycle detection in graphs using depth-first search.
                Master this essential algorithm used in various real-world applications.
            </p>
        </div>

        <!-- Main Navigation Tabs -->
        <div class="tab-navigation">
            <button data-tab="overview" onclick="switchTab('overview', this)" class="tab-button active">
                Overview
            </button>
            <button data-tab="guided-implementation" onclick="switchTab('guided-implementation', this)"
                class="tab-button">
                Guided Implementation
            </button>
            <button data-tab="practice" onclick="switchTab('practice', this)" class="tab-button">
                Practice Challenge
            </button>
        </div>

        <!-- Tab Contents -->
        <div class="content-wrapper">
            <!-- Overview Tab -->
            <div data-tab-content="overview" class="space-y">
                <div class="section">
                    <h2>Project Overview</h2>
                    <div class="grid grid-cols-2">
                        <div class="space-y">
                            <h3>Learning Goals</h3>
                            <ul>
                                <li>Understand cycle detection algorithms</li>
                                <li>Implement DFS-based cycle detection</li>
                                <li>Handle directed and undirected graphs</li>
                                <li>Analyze algorithm complexity</li>
                            </ul>
                        </div>
                        <div class="space-y">
                            <h3>Prerequisites</h3>
                            <ul>
                                <li>Graph fundamentals</li>
                                <li>Depth-first search</li>
                                <li>JavaScript classes</li>
                                <li>Recursive functions</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2>Real-World Applications</h2>
                    <div class="grid grid-cols-2">
                        <div class="space-y">
                            <h3>Use Cases</h3>
                            <ul>
                                <li>Deadlock detection in operating systems</li>
                                <li>Dependency resolution in package managers</li>
                                <li>Circuit design verification</li>
                                <li>Network topology analysis</li>
                            </ul>
                        </div>
                        <div class="space-y">
                            <h3>Example Scenarios</h3>
                            <div class="example-box">
                                <p>Deadlock Example:</p>
                                <div class="example-code">Process A → Resource 1 → Process B → Resource 2 → Process A
                                    (Cycle indicates potential deadlock)</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Guided Implementation Tab -->
            <div data-tab-content="guided-implementation" class="hidden space-y">
                <div class="section">
                    <h2>Detecting Cycles in Graphs</h2>

                    <!-- Video Section -->
                    <div class="space-y">
                        <div class="video-container">
                            <div class="wistia-responsive-padding">
                                <div class="wistia-responsive-wrapper">
                                    <iframe src="https://fast.wistia.net/embed/iframe/cz1gs6r8ew?videoFoam=true"
                                        title="s20M1 Web-JavaScript Guided Project Detecting Cycles Video"
                                        allow="fullscreen" allowtransparency="true" frameborder="0" scrolling="no"
                                        width="100%" height="100%"></iframe>
                                </div>
                            </div>
                        </div>

                        <!-- Implementation Overview -->
                        <div class="info-box">
                            <h3>Understanding Cycle Detection</h3>
                            <p>
                                A cycle in a graph is a path where the first and last vertices are the same. Cycle
                                detection is a fundamental graph problem with applications in deadlock detection,
                                dependency resolution, and circuit design verification.
                            </p>
                            <p>
                                For directed graphs, we use a recursive DFS approach with a "recursion stack" to keep
                                track of vertices being processed in the current path. If a vertex is visited again and
                                it's in the recursion stack, we've found a cycle.
                            </p>
                            <p>
                                For undirected graphs, we use a simpler approach: if we encounter a vertex that has
                                already been visited and it's not the parent of the current vertex, we've found a cycle.
                            </p>
                        </div>

                        <!-- Implementation Steps -->
                        <div class="space-y">
                            <h3>Implementation Steps</h3>

                            <div class="grid grid-cols-2">
                                <div class="space-y">
                                    <h4>Step 1: Graph Setup</h4>
                                    <div class="code-block">
                                        <code>class Graph:
    def __init__(self):
        self.adjacency_list = {}

    def add_vertex(self, vertex):
        if vertex not in self.adjacency_list:
            self.adjacency_list[vertex] = []

    def add_edge(self, v1, v2):
        self.adjacency_list[v1].append(v2)
        # For undirected graphs, add:
        # self.adjacency_list[v2].append(v1)
</code>
                                    </div>
                                </div>

                                <div class="space-y">
                                    <h4>Step 2: Cycle Detection Method</h4>
                                    <div class="code-block">
                                        <code>def has_cycle(self):
    visited = {}
    rec_stack = {}

    # Check all vertices (for disconnected graphs)
    for vertex in self.adjacency_list:
        if self.has_cycle_util(vertex, visited, rec_stack):
            return True
    return False</code>
                                    </div>
                                </div>
                            </div>

                            <div class="space-y">
                                <h4>Step 3: Helper Method for Cycle Detection</h4>
                                <div class="code-block">
                                    <code>def has_cycle_util(self, vertex, visited, rec_stack):
    # If not visited, mark as visited
    if vertex not in visited:
        visited[vertex] = True
        rec_stack[vertex] = True  # Add to recursion stack

        # Check all neighbors
        for neighbor in self.adjacency_list[vertex]:
            # If neighbor not visited and has cycle
            if neighbor not in visited and self.has_cycle_util(neighbor, visited, rec_stack):
                return True
            # If neighbor is in recursion stack, cycle found
            elif neighbor in rec_stack and rec_stack[neighbor]:
                return True
    
    # Remove from recursion stack when backtracking
    rec_stack[vertex] = False
    return False</code>
                                </div>
                            </div>

                            <!-- Cycle Detection for Undirected Graphs -->
                            <div class="space-y">
                                <h4>Cycle Detection for Undirected Graphs</h4>
                                <div class="code-block">
                                    <code>def has_cycle_undirected(self):
    visited = {}
    
    # Helper function
    def has_cycle_util(vertex, parent):
        # Mark current node as visited
        visited[vertex] = True
        
        # Visit all adjacent vertices
        for neighbor in self.adjacency_list[vertex]:
            # If neighbor is not visited, recursively check
            if neighbor not in visited:
                if has_cycle_util(neighbor, vertex):
                    return True
            # If neighbor is visited and not the parent,
            # then there is a cycle
            elif neighbor != parent:
                return True
        return False
    
    # Check all vertices (for disconnected graphs)
    for vertex in self.adjacency_list:
        if vertex not in visited:
            if has_cycle_util(vertex, None):
                return True
    
    return False</code>
                                </div>
                            </div>
                        </div>

                        <!-- Example Usage -->
                        <div class="space-y">
                            <h3>Example Usage</h3>
                            <div class="code-block">
                                <code># Create a directed graph
graph = Graph()

# Add vertices
graph.add_vertex("A")
graph.add_vertex("B")
graph.add_vertex("C")
graph.add_vertex("D")

# Add edges (directed)
graph.add_edge("A", "B")
graph.add_edge("B", "C")
graph.add_edge("C", "A") # Creates a cycle A -> B -> C -> A
graph.add_edge("D", "C")
# Check for cycles
print(graph.has_cycle())  # Output: True

# Visualize the graph structure
print(graph.adjacency_list)
#   A: [B],
#   B: [C],
#   C: [A],
#   D: [C]
</code>
                            </div>
                        </div>

                        <!-- Practice with LeetCode -->
                        <div class="space-y">
                            <h3>Practice with LeetCode</h3>
                            <p>Cycle detection is a common interview question and appears in many practical problems.
                                Practice with these LeetCode problems:</p>
                            <ul>
                                <li>
                                    <a href="https://leetcode.com/problems/course-schedule/" class="link">Course
                                        Schedule</a>
                                    <span class="text-gray-600 ml-2">- Determine if you can finish all courses (cycle
                                        detection in directed graph)</span>
                                </li>
                                <li>
                                    <a href="https://leetcode.com/problems/redundant-connection/" class="link">Redundant
                                        Connection</a>
                                    <span class="text-gray-600 ml-2">- Find an edge that can be removed to make a tree
                                        (cycle detection in undirected graph)</span>
                                </li>
                                <li>
                                    <a href="https://leetcode.com/problems/find-eventual-safe-states/" class="link">Find
                                        Eventual Safe States</a>
                                    <span class="text-gray-600 ml-2">- Find all vertices that don't belong to a
                                        cycle</span>
                                </li>
                            </ul>
                            <p class="text-gray-700 mt-4">
                                Note: Previously, this course referenced the CodeSignal Arcade, which is no longer
                                available. The LeetCode problems above follow the same principles and are an excellent
                                alternative for practicing graph algorithms and preparing for technical interviews.
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Practice Challenge Tab -->
            <div data-tab-content="practice" class="hidden space-y">
                <div class="section">
                    <h2>Practice Challenge: Implement Cycle Detection</h2>
                    <p>Now that you've learned how to detect cycles in graphs, try implementing the algorithm yourself.
                    </p>

                    <div class="space-y">
                        <h3>Challenge Description</h3>
                        <p>Implement a cycle detection algorithm for both directed and undirected graphs.</p>

                        <div class="info-box">
                            <h4>Requirements:</h4>
                            <ul>
                                <li>Add a method to detect cycles in a directed graph</li>
                                <li>Add a method to detect cycles in an undirected graph</li>
                                <li>Return true if a cycle is found, false otherwise</li>
                                <li>Use the Graph class provided in the guided implementation</li>
                            </ul>
                        </div>

                        <div class="space-y">
                            <h3>Code Starting Point</h3>
                            <div class="code-block">
                                <code>class Graph:
    def __init__(self):
        self.adjacency_list = {}

    def add_vertex(self, vertex):
        if vertex not in self.adjacency_list:
            self.adjacency_list[vertex] = []

    def add_edge(self, v1, v2, directed=True):
        self.adjacency_list[v1].append(v2)
        if not directed:
            self.adjacency_list[v2].append(v1)
    
    # Implement cycle detection for directed graphs
    def has_cycle_directed(self):
        # Your code here
        pass
    
    # Implement cycle detection for undirected graphs
    def has_cycle_undirected(self):
        # Your code here
        pass
</code>
                            </div>
                        </div>

                        <div class="space-y">
                            <h3>Testing Your Solution</h3>
                            <div class="code-block">
                                <code># Create a directed graph with a cycle
directed_graph = Graph()
directed_graph.add_vertex('A')
directed_graph.add_vertex('B')
directed_graph.add_vertex('C')
directed_graph.add_vertex('D')
directed_graph.add_edge('A', 'B')
directed_graph.add_edge('B', 'C')
directed_graph.add_edge('C', 'D')
directed_graph.add_edge('D', 'B') # Creates a cycle B → C → D → B
print(directed_graph.has_cycle_directed()) # Should return True

# Create an undirected graph with a cycle
undirected_graph = Graph()
undirected_graph.add_vertex('A')
undirected_graph.add_vertex('B')
undirected_graph.add_vertex('C')
undirected_graph.add_edge('A', 'B', False)
undirected_graph.add_edge('B', 'C', False)
undirected_graph.add_edge('C', 'A', False) # Creates a cycle A — B — C — A
print(undirected_graph.has_cycle_undirected()) # Should return True</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>

</html>