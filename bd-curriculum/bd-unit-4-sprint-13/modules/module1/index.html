<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 1: Intro to DynamoDB - BD Unit 4 Sprint 13</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
</head>

<body>
    <header>
        <nav>
            <div class="logo">BD Unit 4 Sprint 13</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module1/index.html" class="active">Module 1: Intro to DynamoDB</a>
                        <a href="../module2/index.html">Module 2: DynamoDB Annotations and Load</a>
                        <a href="../module3/index.html">Module 3: Writing to DynamoDB + HTTP</a>
                        <a href="../module4/index.html">Module 4: HTTP and RESTful Services</a>
                    </div>
                </li>
                <li><a href="../../code-alongs/index.html">Code-Alongs</a></li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            <h1>Module 1: Intro to DynamoDB</h1>

            <div class="content-box">
                <h2>Module Overview</h2>
                <p>Learn the fundamentals of DynamoDB, including database concepts, partition and sort keys, and data
                    types.</p>
            </div>

            <div class="content-box">
                <h2>Learning Objectives</h2>
                <ul>
                    <li>Outline the role a database serves in an application</li>
                    <li>Outline some of the benefits of distributed over non-distributed data stores</li>
                    <li>Identify a unique item in a provided DynamoDB table by its partition key</li>
                    <li>Identify a unique item in a provided DynamoDB table by its partition and sort keys</li>
                    <li>Identify whether a given Java type should be represented by a DynamoDB Number</li>
                    <li>Identify whether a given Java type should be represented by a DynamoDB String</li>
                    <li>Identify whether a given Java type should be represented by a DynamoDB Boolean</li>
                    <li>Identify whether a given Java type should be represented by a DynamoDB NumberSet</li>
                    <li>Identify whether a given Java type should be represented by a DynamoDB StringSet</li>
                    <li>Outline the cases in which each of create, read, update, and delete operations of a database is
                        used</li>
                    <li>Understand the core concepts of NoSQL databases</li>
                    <li>Learn about DynamoDB's data model, including tables, items, and attributes</li>
                    <li>Master the use of partition keys and sort keys for efficient data access</li>
                    <li>Explore DynamoDB's supported data types, including scalar types and sets</li>
                    <li>Learn the principles of designing effective DynamoDB tables</li>
                </ul>
            </div>

            <div class="content-box">
                <h2>Introduction to Databases</h2>
                <div class="video-container">
                    <iframe class="wistia_embed" title="Introduction to Databases"
                        src="https://fast.wistia.net/embed/iframe/oce48k57cw" width="100%" height="360"
                        name="wistia_embed" allowfullscreen="allowfullscreen" allow="fullscreen"
                        loading="lazy"></iframe>
                </div>

                <h3>Key Concepts</h3>
                <p>A database is an organized collection of data, stored and accessed electronically from a computer
                    system. Databases are essential for storing and retrieving data reliably and efficiently. They serve
                    critical roles in applications by:</p>
                <ul>
                    <li>Providing a structured way to store and organize large amounts of data</li>
                    <li>Enabling efficient retrieval of information based on specific attributes</li>
                    <li>Ensuring data consistency and integrity across applications</li>
                    <li>Supporting concurrent access by multiple users</li>
                </ul>
                <p>In DynamoDB, data is organized into tables, items (similar to rows in relational databases), and
                    attributes (similar to columns). Each item in a DynamoDB table can be uniquely identified by its
                    primary key.</p>
                <p>Consider a practical example: if you organized 30 pairs of shoes in your closet, you would create a
                    system where each shoe has attributes like color, style, and occasion. Similarly, databases organize
                    data with attributes that allow for easy retrieval based on specific criteria.</p>
                <pre><code>
// Example of data representation in a DynamoDB table
Table: ShoeOrganizer
{
  "shoe_id": "SN01",  // Partition key
  "cubby_location": 1,
  "color": "grey",
  "style": "sneaker",
  "occasion": "athletic"
}
                </code></pre>
                <p>Distributed database systems like DynamoDB offer additional benefits:</p>
                <ul>
                    <li>Ability to store much larger datasets across multiple machines</li>
                    <li>Higher availability with geographically distributed data storage</li>
                    <li>Increased fault tolerance - if one server fails, others can handle requests</li>
                    <li>Better support for concurrent requests through distributing load</li>
                </ul>

                <div class="content-box">
                    <h2>What is a Database?</h2>
                    <p>A database is an organized collection of data, stored and accessed electronically from a computer
                        system. Databases are popular because of their ability to reliably store and retrieve data in
                        various ways and because of the large amount of data they can store.</p>

                    <p>Databases are used for so many different applications that you likely interact with one every
                        day. Whether you're buying something online, logging into social media, or accessing a webpage,
                        all those applications likely use a database. While this section gives a general overview of
                        databases, in later sections you will learn how to use the Amazon DynamoDB database service in
                        particular.</p>

                    <h3>Organizing your Closet</h3>
                    <p>Imagine you're cleaning your room and you have 30 pairs of shoes that you need to put away. If
                        you just throw all your shoes into the closet, shut the door, and walk away, then tomorrow when
                        you're looking for a specific pair of shoes, it's going to be difficult to find them. Instead of
                        throwing your shoes in a closet, you buy a shoe organizer and label each cubby with the pair of
                        shoes it contains---completely organizing your closet!</p>

                    <p>This works great if you always know the exact pair of shoes you want to wear, but what if you
                        want to wear grey shoes and aren't sure exactly which pair? If you keep track of certain
                        attributes that your shoes have then you can pull them out based on that attribute. Examine the
                        following table as a brief example:</p>

                    <table>
                        <tr>
                            <th>shoe_id</th>
                            <th>cubby_location</th>
                            <th>color</th>
                            <th>style</th>
                            <th>occasion</th>
                        </tr>
                        <tr>
                            <td>SN01</td>
                            <td>1</td>
                            <td>grey</td>
                            <td>sneaker</td>
                            <td>athletic</td>
                        </tr>
                        <tr>
                            <td>BO01</td>
                            <td>2</td>
                            <td>grey</td>
                            <td>boot</td>
                            <td>work</td>
                        </tr>
                        <tr>
                            <td>SN02</td>
                            <td>3</td>
                            <td>black</td>
                            <td>sneaker</td>
                            <td>casual</td>
                        </tr>
                    </table>

                    <p>Now if you want a grey pair of shoes, you could take out the shoes located in cubbies 1 and 2. If
                        you wanted sneakers you could take out shoes in cubbies 1 and 3. If you want to go to the gym,
                        you know that the only athletic shoes you own are located in cubby 1. These are a few examples
                        of common database use cases: retrieving items from a large set based on the items'
                        characteristics.</p>

                    <p>Organizing your shoes this way feels unnecessary, but when you're dealing with a dataset of
                        thousands, or millions, or billions of entries, it's critical to have a reliable way to organize
                        and retrieve data. Databases usually comprise multiple tables, each table representing an
                        entity. Entities represent people, places, or other things that capture and store data. Items
                        represent an instance of an entity, and attributes are the characteristics or properties of an
                        entity. Entities are analogous to Java classes in that they represent a kind of thing. Items are
                        analogous to instances of classes, in that they represent individual things of that kind.</p>

                    <p>In our shoe example, the entity is shoe. The items are each individual shoe entry in our table
                        and the shoe's attributes are shoe_id, cubby_location_shoe, color, style, and occasion. The
                        first item, shoe_id SN01, has the following attributes: SN01, 1, grey, sneaker, athletic.</p>

                    <h3>Moving our Example to DynamoDB</h3>
                    <p>Now that we've laid out the data for our database table and learned some of the concepts, we can
                        map our example to a specific database service. As mentioned previously, we'll be using Amazon's
                        DynamoDB database service, as it's a good bet that you'll be using DynamoDB before too long in
                        your SDE career at Amazon.</p>

                    <p>In DynamoDB, each attribute must have a data type assigned to it---there are numerous types that
                        DynamoDB supports, but the main ones you will use are Strings, Numbers, and Booleans. In our
                        above example, the cubby_location_shoe attribute uses a Number type, and the other four
                        attributes use a String type. We'll talk more about attribute types in a later section.</p>

                    <p>Each table in DynamoDB must have an attribute or pair of attributes that is its primary key.
                        Primary keys are unique identifiers, a value that represents only that item in the table. The
                        item can be unambiguously identified and retrieved from DynamoDB by that primary key. In our
                        shoe example, the primary key is the shoe_id --- each shoe gets a unique ID. The shoe_id
                        contains the first two letters of the style of shoe and a number that distinguishes different
                        shoes of the same style. For example, the shoe with key SN01 is a sneaker and is a different
                        pair from SN02, another pair of sneakers. We will go into more detail about keys in a later
                        section.</p>

                    <p>Retrieving information from a database is known as a query. A query can retrieve one item or
                        record (e.g. the shoe with ID SN01) or can retrieve multiple pieces of data based on specified
                        attributes (e.g. all shoes that are the color grey). If we retrieve all grey shoes, we end up
                        with both shoe 1 and shoe 2. A database's ability to retrieve multiple pieces of data based on
                        attribute values is one of the reasons databases are so useful. We will go more into depth about
                        queries in a later unit.</p>

                    <p>Our shoe example is one table we could have in our database. We could create tables for shirts
                        and pants, and a table to represent complete outfits.</p>

                    <p>The shirts table might be set up in the following way:</p>
                    <table>
                        <tr>
                            <th>shirt_id</th>
                            <th>cubby_location</th>
                            <th>color</th>
                            <th>style</th>
                            <th>occasion</th>
                        </tr>
                        <tr>
                            <td>LS01</td>
                            <td>8</td>
                            <td>black</td>
                            <td>long-sleeve</td>
                            <td>work</td>
                        </tr>
                    </table>

                    <p>The pants table:</p>
                    <table>
                        <tr>
                            <th>pants_id</th>
                            <th>cubby_location</th>
                            <th>color</th>
                            <th>style</th>
                            <th>occasion</th>
                        </tr>
                        <tr>
                            <td>JE01</td>
                            <td>20</td>
                            <td>blue</td>
                            <td>jeans</td>
                            <td>casual</td>
                        </tr>
                    </table>

                    <p>The outfit table:</p>
                    <table>
                        <tr>
                            <th>outfit_id</th>
                            <th>shoe_id</th>
                            <th>shirt_id</th>
                            <th>pants_id</th>
                        </tr>
                        <tr>
                            <td>OU01</td>
                            <td>SN02</td>
                            <td>LS01</td>
                            <td>JE03</td>
                        </tr>
                        <tr>
                            <td>OU02</td>
                            <td>SN01</td>
                            <td>TS02</td>
                            <td>JE01</td>
                        </tr>
                        <tr>
                            <td>OU03</td>
                            <td>SN01</td>
                            <td>LS01</td>
                            <td>JE03</td>
                        </tr>
                    </table>

                    <p>The attributes in our outfit table correspond to the primary keys for each clothing item. In our
                        example, we've decided to make the primary key for each outfit OU followed by a unique number.
                    </p>

                    <p>In this example, the outfit attributes are keys referring to other tables. The outfit table's
                        attributes shoe_id, shirt_id, and pants_id, correspond to ids from the shoe, shirt, and pants
                        tables, respectively. Looking at the same example as before, to create outfit OU01, we would get
                        the value for shoe_id, which is SN02, and then query the shoe_id table for the item with a
                        matching id. The same process is followed in the shirts table and pants table. The outfit points
                        to its related items by storing their keys as its own attributes.</p>

                    <img src="https://tk-assets.lambdaschool.com/8b2cf320-e7be-43e8-ac85-52a90f5cddc9_image1.png"
                        alt="Figure 1: Diagram showing SN01 pointing to both OU02 and OU03" loading="lazy">
                    <p class="caption">Figure 1: Diagram showing SN-1 pointing to both OU02 and OU03.</p>

                    <p>Tables can be used to represent a relationship where an item in a table can be associated with
                        several items in a different table, which is called a 1 to N, or one-to-many, relationship. Our
                        clothing and outfits tables represent a one-to-many relationship because one article of clothing
                        can be worn with many outfits. For example, the shoe SN01 is used for both outfit OU02 and OU03,
                        showing that the shoes and outfit table have a one-to-many relationship (shown in the diagram
                        above). The same is true for the shirts and outfits tables and the pants and outfits table.</p>

                    <p>It doesn't always make sense for tables to have a one-to-many relationship, however, such as
                        tables where multiple entities couldn't have the same attribute value (for example, if you were
                        relating citizens to driver's license IDs).</p>

                    <h3>Benefits of a Database</h3>
                    <h4>Protection</h4>
                    <p>A well-written database will ensure that your data is still there tomorrow, so luckily you don't
                        need to worry much about protecting it. Each change, often called a transaction or a commit, is
                        stored in a transaction log, which is a history of the actions executed by the database system.
                        If the database runs into trouble, it can often recover all data by reprocessing the transaction
                        log from a last known good state. A database ensures that few, if any, transactions will be
                        lost.</p>

                    <p>When an error occurs, databases won't perform partial writes. A transaction will be fully
                        completed, or it won't happen at all. The simplest case is of writing a single item: either the
                        entire item is added to the database, or none of it is. The database will not allow part of the
                        item to be written, even in the case of an unexpected error. You can also compare this to a
                        transaction you make at a store: when you purchase something, there are two possible outcomes:
                        you give your money and receive a product in exchange, or you don't give your money and receive
                        no product in exchange. You wouldn't give your money without getting your product and they
                        wouldn't give you the product if you didn't pay. Either both pieces of the transaction occur or
                        none of it occurs.</p>

                    <p>A backup is an additional protection against data loss that most databases provide. A database
                        backup stores a copy of the data so that it can be recovered later in case something goes wrong.
                        Backup and recovery facilities are used to create and store copies of data to minimize data loss
                        and are important to ensure the safety of your data. There are many backup and recovery
                        facilities available, and usage usually depends on a team's preference.</p>

                    <h4>Scalability</h4>
                    <p>One of the other benefits of databases is that they can be used by many users at the same time.
                        When you log into Amazon to order something, many other customers are logged in at the same
                        time. The ability to handle multiple simultaneous requests is called concurrency, which
                        describes multiple computations happening at the same time. Databases are one technology that
                        employs concurrency. Many other examples exist, such as multiple applications running on a
                        single computer and multiple computers in a network.</p>

                    <p>Concurrency can lead to issues, however, such as multiple users making edits to a document at the
                        same time and accidentally overwriting each other's edits. Databases are useful in dealing with
                        this as they handle the complexity that concurrency inherently creates so that we don't have to!
                        Concurrency in databases helps manage users modifying data by restricting other users from
                        making changes until the edits are committed. A database commit refers to updating an item in a
                        database and making it available for other users to see the changes. Commits are permanent saves
                        and are necessary to prevent uncertainty about whether the available data is correct. You will
                        learn more about concurrency in later units (when you'll be using concurrency in your own code).
                    </p>

                    <p>Databases are also designed to store large amounts of data. Usually large enough that they cannot
                        store all the data on one machine. Modern databases handle this issue by storing data across
                        many machines that work together, referred to as distributed data storage.</p>

                    <h4>Benefits of Distributed Datastores</h4>
                    <p>Distributed datastores are databases that store data across multiple machines. These allow a much
                        larger set of data to be stored in a single database. As data grows, additional machines can be
                        added to store it all.</p>

                    <p>Distributed databases can also support more concurrent requests to access data because each
                        machine can handle data requests. If many requests arrive at the same time to access the same
                        data, they can distribute access across many machines to prevent any one machine from having to
                        process all the requests themselves.</p>

                    <p>Distributed databases can also run across multiple geographic locations to keep handling requests
                        even when an issue occurs in one location. If you are using a non-distributed datastore model
                        and the one location where you have your database loses power from a natural disaster, then no
                        users will be able to access the data until your database gets power again. In a distributed
                        datastore model, however, if one location goes down or is experiencing errors, then the other
                        locations can usually provide access to the same data with minimal performance loss.</p>
                </div>
            </div>

            <div class="content-box">
                <h2>Partition and Sort Keys</h2>
                <div class="video-container">
                    <iframe class="wistia_embed" title="Partition and Sort Keys"
                        src="https://fast.wistia.net/embed/iframe/ep4gourt0y" width="100%" height="360"
                        name="wistia_embed" allowfullscreen="allowfullscreen" allow="fullscreen"
                        loading="lazy"></iframe>
                </div>

                <h3>Primary Keys in DynamoDB</h3>
                <p>Primary keys in DynamoDB uniquely identify each item in a table. DynamoDB supports two types of
                    primary keys:</p>
                <ol>
                    <li><strong>Partition Key Only</strong> - A simple primary key with a single attribute called the
                        partition key</li>
                    <li><strong>Composite Primary Key</strong> - A composite primary key consisting of a partition key
                        and a sort key</li>
                </ol>
                <p>The <strong>partition key</strong> determines the partition where your data is stored. It's used by
                    DynamoDB's internal hash function to distribute data across partitions for scalability. For example,
                    in a shoe table, "shoe_id" might be a good partition key.</p>
                <p>The <strong>sort key</strong> allows you to organize items with the same partition key. This is
                    especially useful for related items that need to be retrieved together.</p>
                <pre><code>
// Example of a table with composite primary key
Table: MusicLibrary
{
  "artist": "Black Eyed Peas",  // Partition key
  "song_title": "I Gotta Feeling",  // Sort key
  "genre": "pop",
  "year": 2009
}

{
  "artist": "Black Eyed Peas",  // Same partition key
  "song_title": "Pump It",  // Different sort key
  "genre": "pop",
  "year": 2006
}
                </code></pre>

                <div class="content-box">
                    <h3>Understanding Primary Keys</h3>
                    <p>In the previous reading we briefly discussed primary keys and how they provide a unique
                        identifier for each record in your table, but let's dive a little deeper.</p>

                    <p>Let's return to the shoe organizer table:</p>

                    <table>
                        <tr>
                            <th>shoe_id</th>
                            <th>cubby_location</th>
                            <th>color</th>
                            <th>style</th>
                            <th>occasion</th>
                        </tr>
                        <tr>
                            <td>SN01</td>
                            <td>1</td>
                            <td>grey</td>
                            <td>sneaker</td>
                            <td>athletic</td>
                        </tr>
                        <tr>
                            <td>BO01</td>
                            <td>2</td>
                            <td>grey</td>
                            <td>boot</td>
                            <td>work</td>
                        </tr>
                        <tr>
                            <td>SN02</td>
                            <td>3</td>
                            <td>black</td>
                            <td>sneaker</td>
                            <td>casual</td>
                        </tr>
                    </table>

                    <p>The primary key in this table is shoe_id. We've formed our keys by using both the first two
                        letters of the style of shoe and a number that increments for each repeat style. The particular
                        scheme we use is somewhat arbitrary; the important thing is that our key, shoe_id, is unique for
                        each item in the table.</p>

                    <p>To show the need for primary keys we'll consider what would happen if our table was missing the
                        shoe_id attribute.</p>

                    <table>
                        <tr>
                            <th>cubby_location</th>
                            <th>color</th>
                            <th>style</th>
                            <th>occasion</th>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>grey</td>
                            <td>sneaker</td>
                            <td>athletic</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>grey</td>
                            <td>boot</td>
                            <td>work</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>black</td>
                            <td>sneaker</td>
                            <td>casual</td>
                        </tr>
                    </table>

                    <p>Now take a look at our outfit table from the previous reading:</p>

                    <table>
                        <tr>
                            <th>id</th>
                            <th>shoe_id</th>
                            <th>shirt_id</th>
                            <th>pants_id</th>
                        </tr>
                        <tr>
                            <td>OU01</td>
                            <td>SN02</td>
                            <td>LS01</td>
                            <td>JE03</td>
                        </tr>
                        <tr>
                            <td>OU02</td>
                            <td>SN01</td>
                            <td>TS02</td>
                            <td>JE01</td>
                        </tr>
                        <tr>
                            <td>OU03</td>
                            <td>SN01</td>
                            <td>LS01</td>
                            <td>JE03</td>
                        </tr>
                    </table>

                    <p>Our outfit table used the unique IDs for shoes, shirts, and pants to identify which specific
                        article of clothing, but if we remove the shoe_id from the shoe organizer table, then what will
                        we use to identify the shoes here in the outfits table?</p>

                    <p>Let's see if we can replace shoe_id with one of the other attributes in our shoe table, such as
                        'style.'</p>

                    <table>
                        <tr>
                            <th>id</th>
                            <th>style</th>
                            <th>shirt_id</th>
                            <th>pants_id</th>
                        </tr>
                        <tr>
                            <td>OU01</td>
                            <td>sneaker</td>
                            <td>LS01</td>
                            <td>JE03</td>
                        </tr>
                        <tr>
                            <td>OU02</td>
                            <td>boot</td>
                            <td>TS02</td>
                            <td>JE01</td>
                        </tr>
                        <tr>
                            <td>OU03</td>
                            <td>sneaker</td>
                            <td>LS01</td>
                            <td>JE03</td>
                        </tr>
                    </table>

                    <p>If you want to retrieve the shoes for outfit OU02, this happens to work out, because we only have
                        one pair of boots in the table. However, if we want to retrieve the shoes for outfit OU01 or
                        OU03, we run into a problem. Looking at our shoe table we can see that we own two pairs of
                        sneakers, but it's not clear which pair of shoes complete outfits OU01 and OU03. We have no
                        other way to distinguish which pair of sneakers we are looking for in our outfit table. We also
                        can't wear two pairs of sneakers with one outfit.</p>

                    <p>If we changed the attribute to 'occasion' instead of 'style' it would work for now, but as soon
                        as we buy another pair of athletic, work, or casual shoes, we're back to the same issue. Since
                        only one pair of shoes can fit in each cubby, we could use cubby_location as a unique
                        identifier, however, the id values would get messed up if we misplaced a shoe or reorganized our
                        closet.</p>

                    <p>We nearly always want our key values to be immutable, meaning that the values never change no
                        matter what other attributes change on the item, so that we don't have to worry about changing
                        the key and messing up any other entities that refer to that key. The best way to ensure that
                        the key value is immutable is by picking an attribute that is meaningless and won't ever have to
                        be changed, such as our shoe_id of SN01. That's why we structured our shoe table in the
                        following way:</p>

                    <table>
                        <tr>
                            <th>shoe_id</th>
                            <th>cubby_location</th>
                            <th>color</th>
                            <th>style</th>
                            <th>occasion</th>
                        </tr>
                        <tr>
                            <td>SN01</td>
                            <td>1</td>
                            <td>grey</td>
                            <td>sneaker</td>
                            <td>athletic</td>
                        </tr>
                        <tr>
                            <td>BO01</td>
                            <td>2</td>
                            <td>grey</td>
                            <td>boot</td>
                            <td>work</td>
                        </tr>
                        <tr>
                            <td>SN02</td>
                            <td>3</td>
                            <td>black</td>
                            <td>sneaker</td>
                            <td>casual</td>
                        </tr>
                    </table>

                    <p>Primary keys can also be used to distinguish between multiple items that are exactly the same,
                        such as owning two identical shirts. Without a primary key, it would be impossible to
                        differentiate between the two. It may seem unimportant to differentiate between two identical
                        shirts, but this can become more important with databases for online stores to avoid mistakenly
                        trying to send the same exact box to five different addresses. Stores can assign a unique
                        product ID to easily keep track of the individual items. It will depend on the business
                        requirements whether distinguishing individual identical items is required. This will be a
                        necessary part of designing the database tables (more in a later unit!).</p>

                    <h3>Partition and Sort Keys</h3>
                    <p>DynamoDB supports two kinds of keys: partition keys and sort keys. A partition key is a single
                        value. Our shoe organizer table is a table with just a partition key, shoe_id. A sort key can be
                        used to order values that have the same partition key value.</p>

                    <p>DynamoDB tables define their primary key with either just a partition key (with no sort key
                        defined), or a partition + a sort key. In the first case, the primary key is the partition key,
                        and in the second case, the primary key is the pair of partition + sort key, which is also
                        referred to as a composite primary key. In order to identify a unique item in a partition + sort
                        key table, you must specify both the partition and the sort key (it's possible---even
                        likely---that multiple items will match the partition or the sort key alone).</p>

                    <p>With a composite primary key, the partition key itself does not have to be unique. It is possible
                        for multiple items to have the same partition key, but among these items with the same partition
                        key, each has to have a unique sort key. The following table compares partition key-only primary
                        keys and composite primary keys:</p>

                    <table>
                        <tr>
                            <th></th>
                            <th>Partition key-only primary key</th>
                            <th>Composite primary key</th>
                        </tr>
                        <tr>
                            <td>Include a partition key?</td>
                            <td>yes</td>
                            <td>yes</td>
                        </tr>
                        <tr>
                            <td>Include a sort key?</td>
                            <td>no</td>
                            <td>yes</td>
                        </tr>
                        <tr>
                            <td>What is unique?</td>
                            <td>partition key</td>
                            <td>partition + sort key pairings</td>
                        </tr>
                        <tr>
                            <td>When is it used?</td>
                            <td>when each item is completely independent, and we only ever need to look items up by
                                their primary identifier</td>
                            <td>when items naturally group together in some way and we might order items within their
                                natural group</td>
                        </tr>
                        <tr>
                            <td>Example</td>
                            <td>ASIN</td>
                            <td>artist + song</td>
                        </tr>
                    </table>

                    <p>All the examples you've seen so far used a partition key-only primary key. Let's look at an
                        example that uses a partition + sort key.</p>

                    <p>Examine the following table:</p>

                    <table>
                        <tr>
                            <th>artist</th>
                            <th>song_title</th>
                            <th>genre</th>
                            <th>year</th>
                        </tr>
                        <tr>
                            <td>Black Eyed Peas</td>
                            <td>I Gotta Feeling</td>
                            <td>pop</td>
                            <td>2009</td>
                        </tr>
                        <tr>
                            <td>Linkin Park</td>
                            <td>Numb</td>
                            <td>rock</td>
                            <td>2003</td>
                        </tr>
                        <tr>
                            <td>Black Eyed Peas</td>
                            <td>Pump It</td>
                            <td>pop</td>
                            <td>2005</td>
                        </tr>
                        <tr>
                            <td>Missy Elliot</td>
                            <td>Work It</td>
                            <td>rap</td>
                            <td>2002</td>
                        </tr>
                        <tr>
                            <td>Daddy Yankee</td>
                            <td>Gasolina</td>
                            <td>latin pop</td>
                            <td>2004</td>
                        </tr>
                    </table>

                    <p>Our songs table uses a composite primary key: 'artist' is the partition key and 'song_title' is
                        the sort key. As you can see, our partition key in this example is not a unique identifier, as
                        'Black Eyed Peas' is listed as the artist for two songs. The sort key differentiates the two
                        items by having different values for song_title. We could even have two songs with the same
                        song_title but by different artists in this table, and they'll have different primary keys, as
                        they will have different artist + song_title pairings.</p>

                    <p>It would be possible to create a unique ID for each artist/song combination and just use a single
                        partition key, so what's the benefit of creating the composite primary key? When you use a
                        composite primary key, the partition key allows you to easily retrieve commonly needed groups of
                        related items, such as all the songs by a certain artist. This provides additional flexibility
                        when querying data, including the ability to specify an order for the items within the same
                        partition. With our artist + song_title table, we can list the songs from each artist
                        alphabetically. The choice for the sort key will depend on how you plan to use the data. We'll
                        go into more detail in a later unit when we design DynamoDB tables.</p>

                    <p>Additionally, using a composite primary key also provides a data storing benefit. Partition keys
                        determine where an item is stored in the database. When you create a table with only a partition
                        key, each item is stored in a separate location. With a composite primary key, however, items
                        with the same partition key are stored together on the same computer, sorted by their sort
                        value, which can make related items faster to retrieve. Think of a filing cabinet---the
                        partition key determines which folder each item is stored in, and the sort key sorts each item
                        in individual folders.</p>
                </div>
            </div>

            <div class="content-box">
                <h2>DynamoDB Scalar and Set Types</h2>

                <div class="video-container">
                    <iframe class="wistia_embed" title="Introduction to Databases"
                        src="https://fast.wistia.net/embed/iframe/fdtyxomlcn" width="100%" height="360"
                        name="wistia_embed" allowfullscreen="allowfullscreen" allow="fullscreen"
                        loading="lazy"></iframe>
                </div>

                <p>When creating a database, it's important to understand the different data types used for attributes,
                    and when you would want to use the different types. DynamoDB accepts both scalar types, a type
                    representing exactly one value such as a String, and sets, a type representing multiple scalar
                    values.</p>

                <h3>Scalar Types</h3>
                <img src="https://tk-assets.lambdaschool.com/860109ba-2c0c-4fe3-a565-00b99376af66_image1.png"
                    alt="Figure 1: A DynamoDB table named ClubMember, with attributes MemberId, Active, Age, and LastName."
                    loading="lazy">
                <p>Figure 1: A DynamoDB table named ClubMember, with attributes MemberId, Active, Age, and LastName.</p>

                <p>Figure 1: A DynamoDB table named ClubMember, with attributes MemberId, Active, Age, and LastName.</p>

                <p>A scalar type represents exactly one value such as the String, Boolean, and Number types. This table
                    includes all three of these scalar types.</p>

                <p>DynamoDB type BOOL (Boolean type), maps to the Java types, boolean or Boolean. Boolean values are
                    actually represented by a 1 or 0, but in DynamoDB we represent them in English terms as true
                    (corresponding to 1) or false (corresponding to 0). The Boolean type is therefore useful for
                    attributes that can be represented only as true or false, such as whether a club member is active
                    (the Active attribute).</p>

                <p>DynamoDB type S (String type) maps to a Java String. In ClubMember, the attribute LastName is of type
                    S. A String is a sequence of characters, able to represent text or alphanumeric (containing numbers
                    and letters) data, such as IDs that consist of mixed numbers and letters.</p>

                <p>DynamoDB type N (Number type) maps to "all Number types" in Java. Java Number types include both
                    primitives and primitive wrapper classes, including Long/long, Integer/int, Double/double,
                    Float/float, BigDecimal and BigInteger. All numbers are sent across the network to DynamoDB as
                    Strings to maximize compatibility across languages and libraries; however, DynamoDB treats them as
                    Number type attributes for mathematical operations. Numbers can be positive, negative, zero, and
                    anything in between. When reading from DynamoDB to Java, it is on the developer to ensure that the
                    value retrieved from DynamoDB is valid for the Java type they are trying to read (e.g. an int can't
                    have decimal places). In ClubMember, Age is type N and maps to Java type Integer.</p>

                <h3>Set Type</h3>
                <img src="https://tk-assets.lambdaschool.com/15382a26-4cd9-4c23-bc67-c9cd82937dd1_image2.png"
                    alt="Figure 2: A DynamoDB table named ClubMember, with attributes MemberId, Active, Age, LastName, Committees and YearsActive."
                    loading="lazy">
                <p>Figure 2: A DynamoDB table named ClubMember, with attributes MemberId, Active, Age, LastName,
                    Committees and YearsActive.</p>

                <p>Figure 2: A DynamoDB table named ClubMember, with attributes MemberId, Active, Age, LastName,
                    Committees and YearsActive. <a
                        href="https://tk-assets.lambdaschool.com/00aa4910-6666-426b-b003-b358d9164e3c_ClubMember-View2.csv"
                        target="_blank" rel="noopener noreferrer">Download ClubMember table CSV export 2</a>.</p>

                <p>Set types represent multiple scalar values. Sets are used when an attribute can have multiple, unique
                    values, just like a Java Set. But unlike a Java Set, which can hold any kind of object, a DynamoDB
                    Set can only be a Set of Strings or a Set of Numbers.</p>

                <p>We've updated the ClubMember table from the previous section. It now has an attribute for Committees,
                    which shows all the committees the member is currently a part of. Each member is a part of one
                    committee, several different committees, or no committees. Since the data in our Committees
                    attribute is represented by text, the attribute is of DynamoDB type SS (String Set), which maps to
                    Java type Set&lt;String&gt;.</p>

                <p>Our ClubMember table also features an attribute for YearsActive which lists all the years the member
                    has been active in the club. Each member has been active for one or more years. Since the data in
                    our YearsActive attribute is represented by numbers, the attribute is of DynamoDB type NS (Number
                    Set), which maps to Java type Set&lt;T&gt;. For the DynamoDB type NS, the Java Type is depicted as a
                    generic type representing any of the primitive wrapper classes. The most commonly used numeric types
                    in ATA will be Integer and BigDecimal.</p>

                <p>It's important to remember that all the values in a Set must be unique, so they should only be used
                    when you know all the data for that attribute will be different. For example, Sets are useful to
                    keep track of the YearsActive for a club member, as it wouldn't make sense to list a year twice.
                    Additionally, Sets are not an ordered collection, meaning there are no guarantees for the position
                    of elements in the Set. This is the same as the Java Set type, which differs from the Java List type
                    where order is guaranteed.</p>
            </div>

            <div class="content-box">
                <h2>Guided Project</h2>

                <div class="video-container">
                    <iframe class="wistia_embed" title="Introduction to Databases"
                        src="https://fast.wistia.net/embed/iframe/l8fttjluvk" width="100%" height="360"
                        name="wistia_embed" allowfullscreen="allowfullscreen" allow="fullscreen"
                        loading="lazy"></iframe>
                </div>

                <div class="resource-links">
                    <a href="https://github.com/BloomTechBackend/bd-dynamodb-annotations-load-and-save-discussion-cli"
                        target="_blank" rel="noopener noreferrer" class="resource-link">Discussion CLI</a>
                </div>
            </div>

            <div class="content-box">
                <h2>Preparedness Tasks</h2>

                <h3>Task 1: Setup Sprint 13 Challenge Repo</h3>

                <div>
                    <p>This Sprint culminates in a Sprint Challenge project. You should begin by forking and cloning the
                        Sprint Challenge starter repo:</p>

                    <p><a href="https://github.com/BloomTechBackend/music-playlist-service" target="_blank"
                            rel="noopener noreferrer">Sprint 13 Challenge Starter Repo</a></p>

                    <p>This will be your project repo for Sprints 13 - 15.</p>

                    <p>This resource is also visible under the Sprint Challenge section of the course page. After each
                        module, you will be assigned a mastery task with instructions on adding to or modifying the
                        starter code for the challenge.</p>

                    <p>Upon completion of all mastery tasks, the Sprint Challenge project will be complete and ready for
                        you to submit to CodeGrade. The CodeGrade submission page is available under the Sprint
                        Challenge section on the modules page.</p>
                </div>

                <h3>Task 2: Create and Initialize Your DynamoDB Tables</h3>

                <div>
                    <p>For this project, you will need to create two DynamoDB Tables, playlists and album_tracks.</p>

                    <p>First, make sure you have the aws cli installed on your machine. You can find instructions to do
                        so from the <a
                            href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html"
                            target="_blank" rel="noopener noreferrer">AWS documentation</a>.</p>

                    <p>You have been provided a Cloudformation template which will create the two tables for you. You
                        are encouraged to read through this file inside of the configurations directory within this
                        project. In doing so, you will see the schema for each table.</p>

                    <p>Run the following command to create these tables on DynamoDB</p>

                    <pre><code>aws cloudformation create-stack --region us-west-2 --stack-name musicplaylistservice-createtables --template-body file://configurations/tables.template.yml --capabilities CAPABILITY_IAM</code></pre>

                    <p>Once you've verified your tables exist on AWS it is time to populate the album_tracks table.
                        We'll use a JSON file which you should read over first in order to get an idea of how it works
                        and what it looks like. When you are ready, run the following command:</p>

                    <pre><code>aws dynamodb batch-write-item --request-items file://configurations/AlbumTracksData.json</code></pre>

                    <p>Verify once again that your album_tracks table on AWS has now been populated.</p>
                </div>
            </div>

            <section class="content-box">
                <h2 class="resource-section-title">Additional Resources</h2>
                <div class="resource-links">
                    <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html"
                        target="_blank" rel="noopener noreferrer" class="resource-link">
                        DynamoDB Core Components
                    </a>
                    <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html"
                        target="_blank" rel="noopener noreferrer" class="resource-link">
                        Partitions and Data Distribution
                    </a>
                    <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html"
                        target="_blank" rel="noopener noreferrer" class="resource-link">
                        Data Types in DynamoDB
                    </a>
                </div>
            </section>
        </section>
    </main>
</body>

</html>