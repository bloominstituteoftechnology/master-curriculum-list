<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 2 - Form Management</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
</head>
<body>
    <header>
        <nav>
            <div class="logo">Web Unit 2 Sprint 7</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module1/index.html">Module 1: React Router</a>
                        <a href="../module2/index.html" class="active">Module 2: Form Management</a>
                        <a href="../module3/index.html">Module 3: Advanced Form Management</a>
                        <a href="../module4/index.html">Module 4: Introduction to Testing</a>
                    </div>
                </li>
                <li><a href="https://github.com/bloominstituteoftechnology/web-s07-practice-problems">Practice Problems</a></li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            <h1>Module 2 - Form Management</h1>

            <div class="content-box module2-accent">
                <h2>Forms in React</h2>

                <p>Welcome to the exciting world of forms in React! In this Core Competency, we will dive into the intricacies of building dynamic and interactive forms in your React applications.</p>

                <p>Forms are essential to many web applications and have been around forever. Traditional HTML apps use forms to gather user input, such as name, password, address, and comments. Legacy forms trigger an HTTP GET (or POST) message whenever the user submits information, allowing the server to receive and process the data.</p>

                <p>You will learn how to use forms with JS and JSX within React applications. React provides powerful tools and techniques to handle forms effectively, including various types of inputs, manipulation of input values, and handling of submit events. You will also explore the concept of controlled versus uncontrolled inputs.</p>

                <p>By the end of this Core Competency, you'll have a solid understanding of creating robust and user-friendly forms in React, empowering you to build engaging and responsive web applications. So, let's begin our journey to master forms in React!</p>
                
                <h3>Building a basic form</h3>
                <p>Forms are one of the best ways for companies to gather data from users and get them to interact with their software. Forms have been around for a long time! Every language and framework will handle form data differently, but most of them will build a form using the following HTML elements:</p>

                <p>The <code>&lt;form&gt;</code> element represents a document section that contains interactive controls for submitting information to a web server, wrapping all the inputs and labels under one tag.</p>

                <p>The <code>&lt;input&gt;</code> element creates interactive controls for web-based forms to accept user data. You can specify different inputs by setting the type attribute. The more common values for type include text, password, checkbox, date, email, and submit.</p>

                <p>Along with specifying the input type, the input tag has several other attributes that specify some behaviors. You can see the complete list <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attributes" target="_blank" rel="noopener noreferrer">here</a>.</p>

                <p>Here is an example of an input tag with many of its attributes (see if you can deduce what each one does):</p>

                <pre><code>&lt;input type="text" id="name" name="name" required minlength="4" maxlength="8" placeholder="Type your name here" /&gt;</code></pre>

                <p>Let's go through what each attribute provides:</p>

                <ul>
                    <li><strong>id</strong> specifies a unique identifier, just like any other HMTL element, so JavaScript can select and manipulate this element.</li>
                    <li><strong>name</strong> is used for form submission, along with the actual input from the user, as a key/value pair. It also links this input element to a label (more on this below).</li>
                    <li><strong>required</strong> tells the form that this field must be filled in before submitting.</li>
                    <li><strong>minlength</strong> and <strong>maxlength</strong> require the field to have a certain min and max number of characters.</li>
                    <li>The <strong>placeholder</strong> is the default text shown inside the input, usually used to instruct the user what to type.</li>
                </ul>

                <p>The HTML <code>&lt;label&gt;</code> element represents a caption for an item in a user interface. This element has the attribute <code>for</code> which links the label to an input, positioning the caption correctly on the screen.</p>

                <p>Now that you've read about the elements of a form, you can create a simple form using each of these elements like so:</p>

                <pre><code>&lt;form action="https://server.com/action_page"&gt;
  &lt;!-- Label and text box for the first name --&gt;
  &lt;label for="fname"&gt;First name:&lt;/label&gt;&lt;br&gt;
  &lt;input type="text" id="fname" name="fname" value="John"&gt;&lt;br&gt;

  &lt;!-- Label and text box for the last name --&gt;
  &lt;label for="lname"&gt;Last name:&lt;/label&gt;&lt;br&gt;
  &lt;input type="text" id="lname" name="lname" value="Doe"&gt;&lt;br&gt;&lt;br&gt;

  &lt;!-- The submit button --&gt;
  &lt;input type="submit" value="Submit"&gt;
&lt;/form&gt;</code></pre>

                <p>The code above renders like this in the browser:</p>

                <div class="image-container">
                    <img src="../../assets/images/simple_form.png" alt="Image shows the rendered form in the browser, with two inputs, their corresponding labels, and the submit button">
                </div>

                <p>You may have noticed the form tag has an <code>action</code> attribute. <code>action</code> specifies the URL to receive the form's data when the user clicks the "Submit" button. You'll learn more about submitting data in a later reading.</p>

                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>To create a simple form in your React app, you could use the same syntax inside the JSX.</p>

                    <pre><code>export default function App() {
  return (
    &lt;&gt;
      &lt;form&gt;
        &lt;label&gt;
          Username:
          &lt;input type="text" /&gt;
        &lt;/label&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}</code></pre>

                    <p>Notice that in the example above, we wrap the text input inside a <code>&lt;label&gt;</code> element. This is an alternative (arguably easier) way to add labels to inputs. As a next step, you would add attributes like name and id for the input, a submit button, and an action URL.</p>

                    <p>While this React form looks exactly like HTML, remember you are dealing with JSX here. You can add code inside the JSX to create dynamic and smart forms! Moreover, React can maintain state for inputs inside the <code>&lt;form&gt;</code> element, as you will learn later in this Core Competency.</p>
                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/ui86up9r6b?seo=false&videoFoam=false" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>

                <h3>Changing form values</h3>

                <p>Let's learn how to access a form input's value and track real-time changes in your React app. But first, a quick recap.</p>

                <p>In JavaScript, you can access the value of any form input by selecting the corresponding DOM element. Consider this form below:</p>

                <pre><code>&lt;form&gt;
  &lt;label&gt;
    First name:
    &lt;input type="text" id="fname" name="fname" value="John" /&gt;
  &lt;/label&gt;
  &lt;label&gt;
    Last name:
    &lt;input type="text" id="lname" name="lname" value="Doe" /&gt;
  &lt;/label&gt;
  &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;</code></pre>

                <p>To access the current value of the "first name" input, you can select the DOM element and access its value property:</p>

                <pre><code>console.log(document.getElementById("fname").value);</code></pre>

                <p>"John" will be logged since it is the default value. But whenever you access the value property, you get the input's current value, so you must ensure that the user has finished typing before reading the property. Or you can use an event handler to be informed about any changes in the input!</p>

                <p>The DOM will generate an event every time the input is updated. You can add the oninput attribute to the input element and monitor changes in real time:</p>

                <pre><code>&lt;input oninput="monitor()" type="text" id="fname" name="fname" value="John" /&gt;</code></pre>

                <p>The value of oninput is the function called when the input changes. If you wanted monitor() to log the value after every change, you could do this:</p>

                <pre><code>function monitor() {
  console.log(document.getElementById("fname").value);
}</code></pre>

                <p>An alternative approach is to leverage pure JS to assign the handler and access the event object:</p>

                <pre><code>const firstName = document.getElementById("fname");
firstName.oninput = function (e) {
  console.log(e.target.value);
};</code></pre>

                <p>So far, so good. Now, let's see how to track values and changes in React.</p>
                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>Within JSX, the onChange attribute will behave precisely like JavaScript's oninput. You can choose to either write the handler code inline:</p>

                    <pre><code>export default function App() {
  return (
    &lt;&gt;
      &lt;form&gt;
        &lt;label&gt;
          Username:
          &lt;input
            type="text"
            onChange={(event) =&gt; console.log(event.target.value)}
          /&gt;
        &lt;/label&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}</code></pre>

                    <p>Or declare the handler as a named function inside the component:</p>

                    <pre><code>export default function App() {
  const logEvent = (event) =&gt; {
    console.log(event.target.value);
  };
  return (
    &lt;&gt;
      &lt;form&gt;
        &lt;label&gt;
          Username:
          &lt;input type="text" onChange={logEvent} /&gt;
        &lt;/label&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}</code></pre>

                    <p>Now, let's create some state to store the input's value and make it available to the component (and its children) at any time. Don't forget to import useState:</p>

                    <pre><code>import { useState } from "react";

export default function App() {
  const [username, setUsername] = useState("");
  const saveUsername = (event) =&gt; {
    setUsername(event.target.value);
  };
  return (
    &lt;&gt;
      &lt;h1&gt;Username: {username}&lt;/h1&gt;
      &lt;form&gt;
        &lt;label&gt;
          Username:
          &lt;input type="text" onChange={saveUsername} /&gt;
        &lt;/label&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}</code></pre>

                    <p>Although you are not submitting the form now, notice how the &lt;h1&gt; content will dynamically update as you type! React will render the component every time the state is updated.</p>

                    <p>If you hit enter to submit the form, the page will reload, and you will lose the state. The next Learning Objective will teach you how to deal with form submission.</p>
                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/b01ive8fus?seo=false&videoFoam=false" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                <h3>Submitting a form</h3>

                <p>The beauty of JSX when building forms is that you can use an HTML-like syntax while adding arbitrary code to create dynamic components.</p>

                <p>You have learned how to track input changes in real-time using state, and now you will learn how to handle form submissions.</p>

                <p>Like with HTML, a &lt;form&gt; element can have a onSubmit attribute, which will assign an event handler to run additional code when the user submits the form data:</p>

                <pre><code>&lt;form onSubmit={handleSubmit}&gt;
    &lt;label&gt;
      Your Name:
      &lt;input type="text" /&gt;
    &lt;/label&gt;
&lt;/form&gt;

const handleSubmit = (event) =&gt; {
  event.preventDefault();
  // Access state variables, send GET or POST request.
};</code></pre>

                <p>By preventing the default action, you can intercept the submission and cancel the default behavior that would refresh the page. Then, you can add code to your handler to process/submit data and receive/handle the response from the back-end server.</p>
                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>Continuing with the App component from the preview page, you can add the handler function and the onSubmit attribute to the form:</p>

                    <pre><code>import { useState } from "react";

export default function App() {
  const [username, setUsername] = useState("");
  const saveUsername = (event) =&gt; {
    setUsername(event.target.value);
  };
  const handleSubmit = (event) =&gt; {
    event.preventDefault();
    // Access state variables, send GET or POST request.
  };
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label&gt;
        Username:
        &lt;input type="text" onChange={saveUsername} /&gt;
      &lt;/label&gt;
    &lt;/form&gt;
  );
}</code></pre>

                    <p>In a real scenario, the handler would call fetch or axios.get to send the HTTP request right after event.preventDefault(). Let's use console.log to test the handler and also add a simple submit button to the form so the user can either press Enter or click the button:</p>

                    <pre><code>import { useState } from "react";

export default function App() {
  const [username, setUsername] = useState("");
  const saveUsername = (event) =&gt; {
    setUsername(event.target.value);
  };
  const handleSubmit = (event) =&gt; {
    event.preventDefault();
    console.log(username);
  };
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label&gt;
        Username:
        &lt;input type="text" onChange={saveUsername} /&gt;
      &lt;/label&gt;
      &lt;input type="submit" /&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/oivyo4uo6o?seo=false&videoFoam=false" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>

                <h3>Handling multiple inputs</h3>

                <p>Handling multiple inputs can get awkward in React apps. For every additional form input, you must add code to the JSX output, create a new state, and write a new handler. In no time, your component will become bloated with repetitive code, which is hard to read and maintain.</p>

                <p>To avoid this, you can use a design pattern that prioritizes the use of objects as state variables and a single multi-purpose handler that can be assigned to several form inputs. The concept is simple and effective: an object can hold several values simultaneously! But first, you must understand the syntax of updating state objects in React.</p>

                <p>Take a look at the following state variable:</p>

                <pre><code>const [obj, setObj] = useState({
  key1: "value1", 
  key2: "value2",
});</code></pre>

                <p>Because of the way JS handles objects in memory, you can't update value1 or value2 independently and directly. The setObj function expects to receive a complete object when updating the state. The solution is to create a temporary copy of the existing object, update what needs to be changed, and then pass the final complete object to the function. In JS, one of the best ways to accomplish this is to use the spread operator ...:</p>

                <pre><code>//First, you create a copy of the object since you are not supposed to modify state directly:
const objCopy = { ...obj };

//Then you change what you need:
objCopy.key2 = "newValue2";

// and finally you call setObj() to update the state:
setObj(objCopy);</code></pre>

                <p>You could combine the first two steps above in a single statement using this syntax:</p>

                <pre><code>//Create a copy and update the object:
const objCopy = { ...obj, key2: "newValue2" };
setObj(objCopy);</code></pre>

                <p>You can even shorten the code further and get the job done in a single statement:</p>

                <pre><code>setObj({ ...obj, key2: "newValue2" });</code></pre>

                <p>Nice! Remember, this is how you are supposed to update state objects! Using an object, you can add a lot of data in a single state variable instead of creating a separate state for each form input. Notice, however, that the setObj function in our example is hard-coded to update key2. What if you wanted to use a single function to update any key with any value?</p>

                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>Let's start with the value. You have been using event.target.value to receive the current input value inside the onChange handler. Study the code below:</p>

                    <pre><code>import { useState } from "react";

export default function App() {
  const [name, setName] = useState({ firstName: "", lastName: "" });
  const saveFirstName = (event) => {
    // an onChange handler for saving firstName
    setName({ ...name, firstName: event.target.value });
  };
  const saveLastName = (event) => {
    // an onChange handler for saving lastName
    setName({ ...name, lastName: event.target.value });
  };
  // Luckily, this form is only two inputs big, but what if the form had many more inputs?

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log(name);
  };
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;h1&gt;First Name: {name.firstName}&lt;/h1&gt;
      &lt;h1&gt;Last Name: {name.lastName}&lt;/h1&gt;
      &lt;label&gt;
        First Name:
        &lt;input type="text" onChange={saveFirstName} /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Last Name:
        &lt;input type="text" onChange={saveLastName} /&gt;
      &lt;/label&gt;
      &lt;input type="submit" /&gt;
    &lt;/form&gt;
  );
}</code></pre>

                    <p>Notice how you use only one state variable to store all the form data! This is great, but you still use a separate event handler for each form input. Let's improve the code with another syntax sugar. JavaScript allows you to compute the key during runtime using brackets []:</p>

                    <pre><code>// The code below:
const newFirstName = { ...name, firstName: event.target.value };
// Is effectively the same as:
const keyString = "firstName";
const newFirstName = { ...name, [keyString]: event.target.value };</code></pre>

                    <p>To create a single multi-purpose function that can update any value in the object, you must pass the key string as an argument. Since the onChange handler automatically receives the event object, a good solution is to add an extra name attribute to each input, which matches the corresponding key in the object, and extract name from the event object. Check the final code below:</p>

                    <pre><code>import { useState } from "react";

export default function App() {
  const [name, setName] = useState({ firstName: "", lastName: "" });
  // only one handler, which extracts key and value from the event object
  const saveName = (event) => {
    setName({ ...name, [event.target.name]: event.target.value });
  };
  const handleSubmit = (event) => {
    event.preventDefault();
    console.log(name);
  };
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;h1&gt;First Name: {name.firstName}&lt;/h1&gt;
      &lt;h1&gt;Last Name: {name.lastName}&lt;/h1&gt;
      &lt;label&gt;
        First Name:
        &lt;input type="text" name="firstName" onChange={saveName} /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Last Name:
        &lt;input type="text" name="lastName" onChange={saveName} /&gt;
      &lt;/label&gt;
      &lt;input type="submit" /&gt;
    &lt;/form&gt;
  );
}</code></pre>

                    <p>Your component is now shorter and ready to be easily upgraded with new form inputs!</p>
                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/kane7pg10e?seo=false&videoFoam=false" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                <h3>Using controlled inputs</h3>
                <p>At this point, you are practically a React form master! But there's another essential trick to learn: controlled inputs.</p>

                <p>As a developer, you must always consider the uncertainty of user behavior. The whole point of designing an excellent user interface is minimizing errors and bad user experiences. Form inputs, if not very well organized and implemented, often lead to bugs in the application.</p>

                <p>Here are some example use cases that require extra coding logic:</p>

                <ul>
                    <li>If the user's age is less than 16 years, the user should not be able to enter the driver's license number;</li>
                    <li>A text input for a name should contain only letters;</li>
                    <li>A zip code must follow a specific pattern, with five numbers and possibly an option for 5 + "-" + 4 numbers.</li>
                </ul>

                <p>If the application does not manage, validate, or control the inputs in real-time, the user will assume that the values entered or selected are valid. Down the line, an invalid value can generate critical errors. For instance, what happens when a function expects two numbers but tries multiplying 2 by "A"?</p>

                <p>That's why you should control inputs, especially when they are critical to the app logic and the user experience.</p>

                <h4>Controlled Inputs</h4>
                <p>In this Learning Objective and throughout the rest of the program, the term "controlled input" pertains to an input that undergoes real-time validation by the application, potentially being modified to meet validation criteria and subsequently displayed back to the user interface to provide visual feedback. While "validating" and "controlling" may be interchangeable in certain contexts, here, "controlling" encompasses a broader scope.</p>
                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>Let's say you want to add a Social Security Number input to your form. While there are many types of validation to confirm if a particular SSN# is valid, let's create a simple input control to ensure that the user has typed nine numbers and automatically add the - characters in the correct positions.</p>

                    <p>The first step is to control the input value in real-time through an event handler called controlSSN, which will update the state after every change in the input. Next, you need to add code to populate the input with the current state. This is done with the value attribute inside the &lt;input&gt; element. Finally, when the user submits the form, you could add code to reset the state (and thus the input field on the screen).</p>

                    <p>Take a look at the following implementation of controlSSN:</p>

                    <pre><code>import { useState } from "react";

export default function App() {
  //SSN is a string, initialized empty
  const [ssn, setSSN] = useState("");
  // the handler will control the input and update the state
  const controlSSN = (event) => {
    // first we create a temp variable to format the final value
    let social = event.target.value;
    // the hyphen character will be added automatically
    if ((social.length == 3) | (social.length == 6)) {
      social += "-";
    }
    // the string limit is 11 characters
    if (social.length > 11) {
      social = social.slice(0, -1);
    }
    setSSN(social);
  };
  // the state will be reset to an empty string upon form submission
  const handleSubmit = (event) => {
    event.preventDefault();
    console.log(ssn);
    setSSN("");
  };
  //Notice the "value" attribute in the input, which will populate the form with the current state
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label&gt;
        SSN#:
        &lt;input type="text" onChange={controlSSN} value={ssn} /&gt;
      &lt;/label&gt;
      &lt;input type="submit" /&gt;
    &lt;/form&gt;
  );
}</code></pre>

                    <p>This is how you implement the three basic steps to add a controlled input:</p>

                    <ol>
                        <li>Validate the input and update the state accordingly;</li>
                        <li>Use the value attribute to display whatever you want in the input field (often, the state itself);</li>
                        <li>Clear the input upon form submission to indicate to the user that data was submitted and the input is ready to accept a new value.</li>
                    </ol>

                    <p>Granted, this is a simple input control. As it is, the user could still type letters (which should not be accepted), and the backspace key will not work as expected. This shows that input control is not always trivial but will help your application perform flawlessly!</p>

                    <p>Let's improve our control. The submission handler could check if the user has typed nine numbers (11 characters in total). Just add a disabled attribute to the submit input like this:</p>

                    <pre><code>&lt;input type="submit" disabled={ssn.length != 11} /&gt;</code></pre>

                    <p>And just like magic, the submit button will be inactive until the user types nine characters!</p>

                    <p>The next step would be to prevent the user from typing non-number characters. In JS (and in most languages), this is often implemented via Regular Expressions (RegEx). You will learn more about input validation in the next module, but feel free to start exploring RegEx in JS by visiting this <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">Regular Expressions</a>.</p>
                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/579r9pxqiv?seo=false&videoFoam=false" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                <h3>Conclusion</h3>
                <p>Now you know how to create forms in React, monitor input changes, use state to store values, intercept the form submission, optimize the code for multiple inputs, and even validate and control the user's behavior.</p>

                <p>That's a lot, and you should be proud!</p>

                <p>In the next module, you will continue to explore form management and learn some advanced concepts. See you there!</p>
            </div>
            <div class="content-box module2-accent">
                <h2>Guided Project</h2>
              <p><a href="https://github.com/bloominstituteoftechnology/web-guided-project-form-management" target="_blank" rel="noopener">Form Management Starter Code</a></p>
              <p><a href="https://github.com/bloominstituteoftechnology/web-guided-project-form-management-solution" target="_blank" rel="noopener">Form Management Solution</a></p>
              <div class="video-container">
                  <iframe src="https://fast.wistia.net/embed/iframe/hhcdwq6jff" title="Guided Project" allow="autoplay; fullscreen" loading="lazy"></iframe>
              </div>
            </div>

            <div class="content-box module2-accent">
                <h3>Module 2 Project: The DOM</h3>

                <p>This project will have you build a form. Your task is to implement a form capable of creating new team members. One convenient advantage of forms is that you can use the same form to edit existing resources, which is another requirement of this project. By the end, you will have a list of team members that you can add to and edit.</p>
                <p>The module project contains advanced problems that will challenge and stretch your understanding of the module's content. The project has built-in tests for you to check your work, and the solution video is available in case you need help or want to see how we solved each challenge, but remember, there is always more than one way to solve a problem. Before reviewing the solution video, be sure to attempt the project and try solving the challenges yourself.</p>
                

                <h3>Instructions</h3>

                <p>The link below takes you to Bloom's code repository of the assignment. You'll need to fork the repo to your own GitHub account, and clone it down to your computer:</p>
                <p>Starter Repo: <a href="https://github.com/bloominstituteoftechnology/team-builder" target="_blank">Form Management</a></p>

                <ul>
                    <li>Fork the repository,</li>
                    <li>clone it to your machine, and</li>
                    <li>open the README.md file in VSCode, where you will find instructions on completing this Project.</li>
                    <li>submit your completed project to the BloomTech Portal</li>
                </ul>

                <h3>Solution</h3>
                <div class="video-container">
                    <iframe src="https://fast.wistia.net/embed/iframe/jzl3osehya?seo=false&videoFoam=false" title="Solution Video" allow="autoplay; fullscreen" loading="lazy"></iframe>
                </div>
            </div>

            <div class="content-box">
                <h2>Resources</h2>
                <div class="resource-links">
                    <a href="https://reactjs.org/docs/forms.html" target="_blank" rel="noopener noreferrer" class="resource-link">React Forms Documentation</a>
                    <a href="https://reactjs.org/docs/uncontrolled-components.html" target="_blank" rel="noopener noreferrer" class="resource-link">Uncontrolled Components</a>
                    <a href="https://reactjs.org/docs/forms.html#controlled-components" target="_blank" rel="noopener noreferrer" class="resource-link">Controlled Components</a>
                </div>
            </div>
        </section>
    </main>
</body>
</html> 