<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 2: Events in the Browser - Web Unit 2 Sprint 5</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
</head>
<body>
    <header>
        <nav>
            <div class="logo">Web Unit 2 Sprint 5</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module1/index.html">Module 1: The DOM</a>
                        <a href="../module2/index.html" class="active">Module 2: Events in the Browser</a>
                        <a href="../module3/index.html">Module 3: Building Components</a>
                        <a href="../module4/index.html">Module 4: Consuming Data From the Network</a>
                    </div>
                </li>
                <li><a href="https://github.com/bloominstituteoftechnology/web-s05-practice-problems" target="_blank" rel="noopener noreferrer">Practice Problems</a></li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            
            <h1>Module 2: Events in the Browser</h1>
            
            <div class="content-box module2-accent">
                <h2>Events and Their Types</h2>

                <p>A dynamic application is not really dynamic if there's no user interaction!</p>

                <p>The JS code running in the browser often relies on the user to decide what to do next. Virtually any action by the user, whether it's a simple mouse movement, click, or key down, is being monitored by the browser. Under the hood, the engine generates events which can then be accessed by the application. Sometimes the browser creates hundreds of them every second!</p>

                <p>Events can also be triggered by timers, tasks finished (e.g. page loaded), and even the user's device condition, such as changes in screen orientation and resolution.</p>

                <p>Events are a big part of web development. In fact, JavaScript is considered to be an event-driven programming language, with native objects and methods that have been designed from the ground up to facilitate the handling of events.</p>

                <p>The asynchronous nature of JS allows you to build applications that run code in a non-continuous arbitrary order. Typically, the page will load, execute some start-up sequence, and automatically enter a "listening" state. From that point, events will determine what will be executed next.</p>

                <p>You will now learn about some common types of events, and how to write code to react to them.</p>

                <h3>Understanding events</h3>

                <p>From the development point of view, events are objects created and exposed by the browser whenever specific situations occur. Most of the time, you will probably deal with mouse and keyboard events more than anything else, but there are dozens of types of events which can occur while the application is running.</p>

                <p>Every single event object created is readily available to the application if the developer chooses to "listen" to it. The event object contains lots of information about that particular event: where it occurred on the page, what type of action or condition etc. Inside your script, you will have full control of events. Basically, you will decide which events to monitor, when to monitor them, and how to react!</p>

                <p>For instance, you might want to hide a page element whenever a specific button (and only that button) is clicked, or you might want to change a header style when the ENTER key is pressed. The possibilities are endless.</p>

                <p>The fundamental approach to JS event-driven programming is:</p>

                <ul>
                    <li>Decide which event type will trigger a reaction</li>
                    <li>Decide which target node/element should react to that event</li>
                    <li>Write the actual code to handle the event (often called event listener, event handler, or callback function).</li>
                </ul>

                <div class="note-box">
                    <h3>How to Build It</h3>

                    <p>The basic functionality of the Kolors application is to shuffle over color palettes whenever the user clicks the "Change Palette" button.</p>

                    <p>Following the 3 steps above, you know exactly what to do next!</p>

                    <ul>
                        <li>The monitored event will be a mouse click</li>
                        <li>The element which will listen to that event is the button</li>
                        <li>And the event handler will update the color bars.</li>
                    </ul>

                    <img src="../../assets/images/BrowserEvents.jpg" alt="Browser Events">

                    <p>A 'click' event over the "Change Palette" button will run code to change all the color bars (text and background color).</p>

                    <p>But there's another event to be monitored: a click over the 'Dark Theme Off' should change the background of the page!</p>

                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/duhx65xam7?seo=false&videoFoam=false" title="Building the Kolors Application" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>

                <h3>Understanding the types of events</h3>

                <p>There are many types of events reported by the browser. We mentioned that two of the most common types are related to MOUSE and KEYBOARD actions, such as movements, clicks, drags, key presses etc.</p>

                <p>But if you refer to the <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener noreferrer">documentation</a>, you will see that events are classified under many types, such as Animation, Clipboard, CSS transition, Focus, Form, Gestures (used with touchscreens), Media, Print, etc. Your application can even tell if the device's (e.g. smartphone) battery is low and react accordingly!</p>

                <p>Regardless of the type of the event, the process of handling them is always the same: think of events, targets, and reactions.</p>

                <div class="note-box">
                    <h3>How to Build It</h3>

                    <p>It looks like the 'click' event is going to be the focus of your application.</p>

                    <p>But Product Management has mentioned in the past that it would be great if users had the option to get more information about a particular color, such as the CMYK code for printing jobs.</p>

                    <p>You can add a 'mouseover' event to each color bar, so that by hovering the mouse over the color, the user will get more details about that particular color. That would be very dynamic and helpful! You design a mockup to show the PM:</p>

                    <div class="color-mockup">
                        <img src="../../assets/images/BrowserEvents2.jpg" alt="Mockup showing color info on hover">
                        <p class="caption">Three boxes with unique colors. One black, one purple, and one white. A mouse hovers over the purple box, and an info box is next to the mouse, depicting what happens when a mouse hovers over a box. The info box has info about the color such as the color's name, RGB values, and hex value.</p>
                    </div>

                    <p>Design mock-ups are great to discuss functionalities with teammates and clients. Once they are approved, you can start coding.</p>

                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/ibfctjj28k?seo=false&videoFoam=false" title="Event Types and Color Information" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>

                <h3>Handling events with HTML attributes</h3>

                <p>Some years ago, It was common practice to manage events using inline HTML.</p>

                <p>The code would be written like this:</p>

                <pre><code>&lt;button onclick="btnClick()"&gt;Click Me&lt;/button&gt;

&lt;script&gt;
  function btnClick() {
    console.log("Button Clicked")
  }
&lt;/script&gt;</code></pre>

                <p>The onclick attribute specifies that this particular element (button) should react to an 'onclick' event by running the btnClick() function declared elsewhere in the code. Again, you choose the event type, the target element, and the callback function.</p>

                <p>If you use this approach, as your application evolves, you might end up with several event handlers listening for different types of events on the same element, and the HTML inline notation could become hard to read and manage:</p>

                <pre><code>&lt;button onclick="function1()" onfocus="function2()" ondblclick="function3"&gt;
  Try Me
&lt;/button&gt;</code></pre>

                <p>In the code above, the button element is listening to different types of events, each one bound to a callback function.</p>

                <p>Another possibility, which ultimately renders the same result, is to set the onclick attribute by JavaScript:</p>

                <pre><code>&lt;button id="myBtn"&gt;Click Me&lt;/button&gt;

&lt;script&gt;
  var btn = document.getElementById("myBtn")
  btn.onclick = btnClick

  function btnClick() {
    console.log("Button Clicked")
  }
&lt;/script&gt;</code></pre>

                <p>This gives you more flexibility to manage events during runtime, and dynamically add reactions to your elements. Notice however that in this case the attribute is set to btnClick instead of btnClick(). It's just a convention in JavaScript.</p>

                <p>The limitation of either approach above is that you can't add multiple callbacks to the same event. Whenever you set the 'onclick' attribute, it is overwritten, so any previous function assigned to it will cease to work.</p>

                <p>Let's study this example. If you assign the onclick attribute to another callback function, the previous assignment will be lost.</p>

                <pre><code>&lt;button id="btn1"&gt;Button 1&lt;/button&gt;

&lt;script&gt;
  function function1() {
    console.log("Function1")
  }
  function function2() {
    console.log("Function2")
  }

  var btn1 = document.getElementById("btn1")
  btn1.onclick = function1
  btn1.onclick = function2
&lt;/script&gt;</code></pre>

                <p>If you click on btn1, the console will only log:</p>

                <pre><code>"Function2"</code></pre>

                
                <div class="note-box">
                    <h3>How to Build It</h3>

                <p>If you wanted to use HTML to handle events in the application, perhaps to make some tests while in development, you could revisit the code:</p>

                <pre><code>&lt;body&gt;
   &lt;h1&gt;Kolors Palette Selector&lt;/h1&gt;
   &lt;button type="button" id="palettebtn"&gt;Change Palette&lt;/button&gt;
   &lt;div class="container"&gt;
     &lt;div class="rectangle"&gt;&lt;/div&gt;
     &lt;div class="rectangle"&gt;&lt;/div&gt;
     &lt;div class="rectangle"&gt;&lt;/div&gt;
     &lt;div class="rectangle"&gt;&lt;/div&gt;
     &lt;div class="rectangle"&gt;&lt;/div&gt;
   &lt;/div&gt;
 &lt;/body&gt;</code></pre>

                <p>And modify it to:</p>

                <pre><code>&lt;body&gt;
   &lt;h1&gt;Kolors Palette Selector&lt;/h1&gt;
   &lt;button type="button" id="palettebtn" onclick="changePalette()"&gt;Change Palette&lt;/button&gt;
   &lt;div class="container"&gt;
     &lt;div class="rectangle" mouseover="showInfo()"&gt;&lt;/div&gt;
     &lt;div class="rectangle" mouseover="showInfo()"&gt;&lt;/div&gt;
     &lt;div class="rectangle" mouseover="showInfo()"&gt;&lt;/div&gt;
     &lt;div class="rectangle" mouseover="showInfo()"&gt;&lt;/div&gt;
     &lt;div class="rectangle"&gt;&lt;/div&gt;
   &lt;/div&gt;
&lt;/body&gt;</code></pre>

                <p>The onclick attribute of the button is pointing to the changePalette() function, and every single rectangle (div) has a mouseover attribute which will call the showInfo() function. Both function handlers will be coded inside the &lt;script&gt; section.</p>

                <div class="video-container">
                    <iframe src="https://fast.wistia.net/embed/iframe/6mbyxyxh7y?seo=false&videoFoam=false" title="Handling Events with HTML Attributes" allow="autoplay; fullscreen" loading="lazy"></iframe>
                </div>
            </div>

            <h3>Conclusion</h3>

            <p>In the end, designing a dynamic application comes down to planning which elements will react to which events. Now it would be a good time for you to research about other event types.</p>

            <p>If you are careful to plan and assign initial classes and IDs in the HTML, selecting elements and manipulating them through event handlers will be easy! Next, you will learn how to handle events using pure JS.</p>
            
            </div>

            <div class="content-box module2-accent">

                <h2>Adding Event Listeners in JS</h2>

                <p>You will now learn how to add event listeners using pure JavaScript. By designing a basic HTML foundation, you will be able to concentrate your development efforts on JS. Remember that some elements might be created dynamically during the runtime of the application, so it would be great if those elements could also listen and react to events dynamically!</p>

                <p>The most common way to handle events these days is to use the .addEventListener() method and that's what you will learn in this Core Competency.</p>

                <h3>Handling an event with .addEventListener()</h3>

                <p>The .addEventListener() method allows you to specify all you need in a single line of code: target element, event type, and callback. Here's the syntax:</p>

                <pre><code>eventTarget.addEventListener(eventType, eventListener);</code></pre>

                <p>Common targets are elements of the page, the document itself, or the window object. The eventType is a string containing the name of the event, such as "click" (instead of "onclick", beware of the notation!). And the eventListener is a reference to a function declared elsewhere (or inside the statement as an inline function).</p>

                <p>This example below will register an event listener for clicks over a h1 section. Study the HTML and JS:</p>

                <pre><code>&lt;body&gt;
&lt;h1 class="main-header"&gt;Events&lt;/h1&gt;
&lt;nav class="main-nav"&gt;
  &lt;a href="#" class="nav-item"&gt;Home&lt;/a&gt;
  &lt;a href="#" class="nav-item"&gt;About&lt;/a&gt;
  &lt;a href="#" class="nav-item"&gt;Blog&lt;/a&gt;
  &lt;a href="#" class="nav-item"&gt;Contact&lt;/a&gt;
&lt;/nav&gt;
&lt;/body&gt;</code></pre>

                <pre><code>// the target element
const mainHeader = document.querySelector('.main-header');

// the event handler
const handleClick = () => {
   mainHeader.textContent = 'Click!';
};

// the element is now ready to react to the event!
mainHeader.addEventListener('click', handleClick);</code></pre>

                <p>The code above is straightforward: the text content of the header will change to 'Click!' whenever the user clicks over the h1 section.</p>

                <div class="side-note">
                    <p>Pro Tip: notice how we use 'handleClick' for the callback, instead of 'handleClick()'. In JS, the latter would make the function execute upon page load, which is not the desired behavior in this case.</p>
                </div>

                <p>You could accomplish the same result by declaring the callback function inline:</p>

                <pre><code>const mainHeader = document.querySelector('.main-header');

mainHeader.addEventListener('click', () => {
   mainHeader.textContent = 'Click!';
   }
);</code></pre>

                <p>The .addEventListener() method allows you to add multiple handlers for the same target, and even for the same event type!</p>

                <pre><code>mainHeader.addEventListener('click', handleClick2);
mainHeader.addEventListener('click', handleClick3);
mainHeader.addEventListener('mouseover', handleMouseOver);</code></pre>

                <p>If a 'click' event happens over the mainHeader element, all of the registered callback functions will run, typically in the order they have been attached.</p>

                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>Let's look at a more complete example. Here's the HTML structure for a color palette application:</p>

                    <pre><code>&lt;body&gt;
   &lt;h1&gt;Kolors Palette Selector&lt;/h1&gt;
   &lt;button type="button" id="togglebtn"&gt;Dark Theme OFF&lt;/button&gt;
   &lt;button type="button" id="palettebtn"&gt;Change Palette&lt;/button&gt;
   &lt;div class="container"&gt;
     &lt;div class="rectangle"&gt;&lt;/div&gt;
     &lt;div class="rectangle"&gt;&lt;/div&gt;
     &lt;div class="rectangle"&gt;&lt;/div&gt;
     &lt;div class="rectangle"&gt;&lt;/div&gt;
     &lt;div class="rectangle"&gt;&lt;/div&gt;
   &lt;/div&gt;
&lt;/body&gt;</code></pre>

                    <p>And here's the JavaScript code that sets up the event handlers:</p>

                    <pre><code>// some code omitted

const paletteBtn = document.getElementById("palettebtn");
const toggleBtn = document.getElementById("togglebtn");
const colorBars = document.querySelectorAll(".rectangle");
// Three selections made for future use

const toggleTheme = () => {
   document.querySelector("body").classList.toggle("dark-theme");
};

const changePalette = () => {
   // existing code
};

const showInfo = () => {
   // to be implemented
};

// Three handlers defined!</code></pre>

                    <p>Finally, we attach the handlers to the proper elements:</p>

                    <pre><code>paletteBtn.addEventLister('click', changePalette);
toggleBtn.addEventLister('click', toggleTheme);
colorBars.forEach(el => {
   el.addEventListener('mouseover', showInfo);
});</code></pre>

                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/md91pir870?seo=false&videoFoam=false" title="Adding Event Listeners in JavaScript" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>

                <h3>Studying the event object</h3>

                <p>Sometimes you will need to access the event object to further inspect its properties. This is easy to do by declaring a parameter inside the callback.</p>

                <p>Let's say you wanted to listen for the "Escape" key pressed on the keyboard and change the background color of the target element:</p>

                <pre><code>const handleEscape = (event) => {
   if (event.key == 'Escape') {
      event.target.style.backgroundColor = 'red';
   }
};

document.addEventListener('keydown', handleEscape);</code></pre>

                <p>Notice how the callback always receives the event object as the argument, and is able to access its properties (e.g. .key), including the actual target element (.target) and its own properties (e.g. .target.style).</p>

                <p>The 'keydown' event will be triggered upon any key press, so you must inspect the event object if you need to know which key was actually pressed. As a bonus, by using event.target instead of a particular node reference, you can reuse the handler for any node on the page!</p>

                <p>If you wanted to access the text content and the tag type of any element, you would write a generic handler function like this:</p>

                <pre><code>const handleClick = (event) => {
   event.target.textContent = `You clicked on a ${event.target.tagName} element`;
};</code></pre>

                <p>You can also access the event object just to log properties on the console, which is especially helpful when testing and debugging your application!</p>

                <div class="note-box">
                    <h3>How to Build It</h3>
                <p>Let's implement the showInfo() function to display color details when hovering over color bars. We'll use the element's ID (set to the color name) to look up information in our colorInfo object:</p>

                <pre><code>const colorInfo = {
    charcoal: "hex: E4AC23, cmyk: (22,5,122,43), rgb: (120,34,65), family: Dark Minerals",
    saffron: "hex: 64B2C0, cmyk: (23,121,43,45), rgb: (12,223,67), family: Pale Yellows",
    // ... additional colors
};

const showInfo = (event) => {
    // Create floating element to show the info
    const infoBox = document.createElement('div');
    infoBox.style.position = 'absolute';
    infoBox.style.backgroundColor = '#fff';
    infoBox.style.padding = '10px';
    infoBox.style.border = '1px solid #ccc';
    infoBox.style.borderRadius = '4px';
    
    // Position next to mouse cursor
    infoBox.style.left = (event.pageX + 10) + 'px';
    infoBox.style.top = (event.pageY + 10) + 'px';

    // Get and display the color information
    infoBox.textContent = colorInfo[event.target.id];
    
    // Add to document
    document.body.appendChild(infoBox);
    
    // Remove box when mouse leaves color bar
    event.target.addEventListener('mouseout', () => {
        document.body.removeChild(infoBox);
    });
};</code></pre>

                <p>This implementation:</p>
                <ul>
                    <li>Creates a floating div element styled to look like an info box</li>
                    <li>Positions it near the mouse cursor using the event coordinates</li>
                    <li>Looks up color info using the element's ID as the key</li>
                    <li>Adds the box to the document</li>
                    <li>Removes the box when the mouse leaves the color bar</li>
                </ul>

                <div class="video-container">
                    <iframe src="https://fast.wistia.net/embed/iframe/gnq9jntccg?seo=false&videoFoam=false" title="Implementing Color Information Display" allow="autoplay; fullscreen" loading="lazy"></iframe>
                </div>
            </div>

            <h3>Preventing the default behavior of an event</h3>

                <p>Some elements have a native default reaction to certain events. For example, the <code>&lt;a&gt;</code> element will natively open a new page pointing to the href attribute. By default, every <code>&lt;a&gt;</code> element is listening for clicks and is attached to an 'open page' handler. In the example below, clicking over the link will open a new page by default:</p>

                <pre><code>&lt;a href='https://bloomtech.com' id='home-link'&gt;Bloomtech&lt;/a&gt;</code></pre>

                <p>What if for some reason you want to first redirect the user to another page or even change the reaction to the click completely? You can use the <code>.preventDefault()</code> method of the event object!</p>

                <p>Let's see how to do it.</p>

                <p>Knowing that any event listener added by the application will execute before the default behavior, you can attach a listener to the element and call the <code>.preventDefault()</code> method inside of it:</p>

                <pre><code>document.querySelector("#home-link").addEventListener("click", doSomethingElse);
// Handlers added by the user will run before the default reaction

const doSomethingElse = (event) => {
   event.preventDefault();
   // prevents default behavior
   // do something else
   // if other handlers are registered, they will also run
};</code></pre>

                <p>You need to register your own listener so that you can capture the event object and call <code>.preventDefault()</code>. This will also make sure that only that particular element attached to the handler will ignore the default behavior.</p>

                <div class="side-note">
                    <p>Pro-tip: Can you see how a malicious code could use this method to redirect the user to a fake page? That's why you should always verify the address bar after clicking on a link!</p>
                </div>

                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>Let's practice preventing default behavior with a real example:</p>

                    <pre><code>&lt;a id="resources" href='https://en.wikipedia.org/wiki/Color_science' id='home-link'&gt;Additional Resources&lt;/a&gt;

const externalLink = document.querySelector("#resources");
externalLink.addEventListener("click", displayMessage);

const displayMessage = (event) => {
   event.preventDefault();
   window.alert("You will be redirected to a third party website!");
   window.open(externalLink.href, '_blank');
};</code></pre>

                    <p>When clicking on the link, the user will get a message pop-up and the code will halt execution until the user acknowledges and clicks OK. Next, the browser will open a new tab with the URL from the href attribute.</p>

                    <p>This pattern is commonly used when:</p>
                    <ul>
                        <li>Redirecting users to external sites</li>
                        <li>Warning users about leaving your domain</li>
                        <li>Getting user confirmation before navigation</li>
                    </ul>

                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/qmrre58zhs?seo=false&videoFoam=false" title="Preventing Default Event Behavior" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                <h3>Conclusion</h3>
                <p>In this Core Competency you have learned not only how to add event listeners with JS, but how to access the event object and even prevent default behaviors.</p>

                <p>Take some time to log an event object in the console and study all of its properties and methods. It is important that you feel comfortable with the event object as you'll be using it in a variety of ways in your career, and knowing its properties will help you solve many problems. There's a lot you can do by accessing the event inside the handler.</p>

                <p>Next, you will learn how to deal with event propagation and gain full control of event handling in your application!</p>
            </div> 

            <div class="content-box module2-accent">
                <h2>Event Propagation</h2>

                <p>In the previous Core Competency, you learned how to add event listeners to elements and how to handle events using the event object. Now, you will learn how to control the way events are handled and propagated in your application.</p>

                <p>For this next Core Competency, it is helpful to think of events like entities that are "fired" from a particular element and propagate up the DOM tree. On its way to the top of the tree (usually the document root node), the event will "touch" other elements and will also trigger those that are set to listen and react to that particular type of event.</p>

                <p>If there are no event listeners on this path, the event will eventually "die" and nothing will happen in the application. In other words, a single user interaction might trigger multiple callback functions, over multiple targets, even if that's not the intention of the user.</p>

                <p>Your application must be able to deal with the propagation of events and decide which elements should react, and in which order they should react!</p>

                <h3>Understanding the phases of propagation</h3>

                <p>Let's study an example of event propagation. Consider the code below:</p>

                <h4>HTML</h4>
                <pre><code>&lt;body&gt;
  &lt;h1 class="main-header"&gt;Events&lt;/h1&gt;
  &lt;div class="menu"&gt;
    &lt;h2 id="menu-header"&gt;MENU&lt;/h2&gt;
    &lt;a href="#" id="home-link"&gt;Home&lt;/a&gt;
    &lt;a href="#" id="about-link"&gt;About&lt;/a&gt;
    &lt;a href="#" id="blog-link"&gt;Blog&lt;/a&gt;
    &lt;a href="#" id="contact-link"&gt;Contact&lt;/a&gt;
  &lt;/div&gt;
&lt;/body&gt;</code></pre>

                <h4>JS</h4>
                <pre><code>document.querySelector(".menu").addEventListener("click", handleDiv);
// click handler attached to the div.menu element

document.querySelector("#menu-header").addEventListener("click", handleH2);
// another click handler attached to the h2#menu-header element</code></pre>

                <p>The code above is attaching a distinct click handler to each of the two elements.</p>

                <p>Whenever the user clicks over the h2#menu-header element, the browser will trigger a click event and handleH2() will be called, as expected, because that element is configured to listen to that event.</p>

                <p>But the event will continue to propagate up to the div.menu element, because it is the parent of the h2 element. Since this div is also configured to listen to the click event, it will call handleDiv(). Then the event will reach the body and finally, the document root, and both will ignore it.</p>

                <p>Regardless of the user's intentions, clicking over this particular h2 means that the user is also clicking over other elements: the parent div, the body, and the document.</p>

                <p>These are the propagation steps, from 1 to 4:</p>

                <img src="../../assets/images/Event Propagation.png" alt="Event Propagation">

                <ol>
                    <li>h2:user clicks and triggers the attached handler --&gt;</li>
                    <li>div: any "click" handler will also be triggered --&gt;</li>
                    <li>body: any "click" handler would also be triggered; h1: This is a sibling of div, the event will not touch it --&gt;</li>
                    <li>document: any "click" handler here would also be triggered</li>
                </ol>

                <p>The bubbling-up (propagation phase) will make the event trigger handlers following the order above, from 1 to 4. In other words, from the inner most element to the last parent. But you may change the default behavior and have a particular handler execute before the others! All you need to do is add true as a third argument when attaching the handler:</p>

                <pre><code>// click handler attached to the div.menu element will be executed before the propagation phase.
document.querySelector(".menu").addEventListener("click", handleDiv, true);

// the other click handler attached to the h2#menu-header element will be executed normally during the propagation phase.
document.querySelector("#menu-header").addEventListener("click", handleH2);</code></pre>

                <p>If you have multiple handlers set as true, they will execute in reverse order, meaning, from the outermost element, to the innermost child.</p>

                <p>For all of the available options when attaching an event listener, please refer to this <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener noreferrer">documentation</a>.</p>

                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>Let's look at a practical example of event propagation and how to control it. We'll build a color palette selector that demonstrates event handling and propagation:</p>

                    <pre><code>&lt;body&gt;
  &lt;h1&gt;Kolors Palette Selector&lt;/h1&gt;
  &lt;button type="button" id="togglebtn"&gt;Dark Theme OFF&lt;/button&gt;
  &lt;button type="button" id="palettebtn"&gt;Change Palette&lt;/button&gt;
  &lt;div class="container"&gt;
    &lt;div class="rectangle"&gt;&lt;/div&gt;
    &lt;div class="rectangle"&gt;&lt;/div&gt;
    &lt;div class="rectangle"&gt;&lt;/div&gt;
    &lt;div class="rectangle"&gt;&lt;/div&gt;
    &lt;div class="rectangle"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;</code></pre>

                    <p>To handle mouse events on the color bars, we can attach multiple event listeners using a forEach loop:</p>

                    <pre><code>colorBars.forEach(el => {
  el.addEventListener('mouseover', showInfo);
  el.addEventListener('wheel', shuffleColor);
});</code></pre>

                    <p>The wheel event handler needs to check the scroll direction using event.deltaY:</p>

                    <pre><code>const shuffleColor = (event) => {
  if (event.deltaY > 0) {
    // get next family color from array/object
    // update the color bar title, color, info box
  }
  else if (event.deltaY < 0) {
    // get previous family color from array/object
    // update the color bar title, color, info box
  }
};</code></pre>

                    <p>When testing the wheel event, you'll notice the page scrolls up and down unintentionally. This is because the wheel event propagates up through the DOM tree to parent elements. To prevent this default scrolling behavior, you'll need to call <code>event.preventDefault()</code> on the wheel event.</p>

                    <p>You can test which parent element is causing the scroll by attaching wheel event listeners to each parent in the chain:</p>

                    <pre><code>// Test each parent element
document.querySelector('.container').addEventListener('wheel', e => {
  console.log('Container wheel event');
  e.preventDefault(); 
});

document.body.addEventListener('wheel', e => {
  console.log('Body wheel event');
  e.preventDefault();
});

document.addEventListener('wheel', e => {
  console.log('Document wheel event');
  e.preventDefault();
});</code></pre>

                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/e3ic0ke848?seo=false&videoFoam=false" title="Understanding Event Propagation" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>

                <h3>Find the target and the current target of an event</h3>

                <p>If you refer back to the image in the previous page, at step 1, the original click event happens over the h2 element. This h2 element is the actual target of the event, the origin, where it all started, and can be accessed by the application through the read-only .target property:</p>

                <pre><code>const handleH2 = (event) => {
  console.log('the target element of the event is:', event.target);
  // logs the original element where the event was created
  event.target.style.backgroundColor = "yellow";
  // changes the background color of the target h2
};</code></pre>

                <p>If other handlers up the tree access the event.target property, it will always refer to the same h2 element where the event was initially fired from: the h2#menu-header. The handler below, although called by a different parent element (div.menu) , will perform the exact same thing as the previous handler:</p>

                <pre><code>const handleDiv = (event) => {
  console.log('the target element of the event is:', event.target);
  // logs the original element where the event was created
  event.target.style.backgroundColor = "yellow";
  // changes the background color of the target h2
};</code></pre>

                <p>If a handler needs to access the actual element that it is attached to (which is often the case!), it can use the .currentTarget property:</p>

                <pre><code>const handleDiv = (event) => {
  event.currentTarget.style.backgroundColor = "yellow";
  // changes the background color of the div, not the h2!
};</code></pre>

                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>You can use <code>.target</code> and <code>.currentTarget</code> to actually understand how the wheel event is propagating in your document. Add another simple handler and attach it to all the parent elements of the color bars.</p>

                    <p>Use the <code>.tagName</code> property to identify the actual element:</p>

                    <pre><code>const showTarget = (event) => {
  console.log('target:', event.target.tagName);
  console.log('currentTarget:', event.currentTarget.tagName);
  console.log(' ');
};

document.addEventListener('wheel', showTarget);
document.querySelector('body').addEventListener('wheel', showTarget);
document.querySelector('.container').addEventListener('wheel', showTarget);</code></pre>

                    <p>What happens when you scroll the wheel while moving the mouse over different parts of the page?</p>

                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/ixsmszw7c3?seo=false&videoFoam=false" title="Event Target and Current Target" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                
                <h3>Stopping event propagation</h3>

                <p>Ask yourself: do you really want your application to trigger all the event handlers up the tree? In this particular scenario from the previous example, do you want to change the background color of both elements? Do you want to run both the h2 handler AND the parent div handler? Probably not. So you need a way to control the propagation of events!</p>

                <p>Fortunately, the event object has another method just for that! By calling <code>.stopPropagation()</code>, you can catch the event on a particular element and stop it from propagating to other elements!</p>

                <p>If you rewrite the click handler attached to the h2#menu-header to:</p>

                <pre><code>const handleH2 = (event) => {
  event.stopPropagation();
  // prevents parents from triggering their handlers
  event.currentTarget.style.backgroundColor = "yellow";
};</code></pre>

                <p>You can now be sure that the click event will "die" inside this handler and will not propagate further, effectively preventing any other click handlers from running!</p>

                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>As you have concluded, you don't want other elements reacting to the mouse wheel and make the document scroll up and down in the window.</p>

                    <p>You can try two different approaches:</p>

                    <pre><code>const showTarget = (event) => {
  event.preventDefault();
  // this option will prevent the document from scrolling up and down, although it will still receive the event and execute the code below (log the targets)
  event.stopPropagation();
  // this option will stop propagation when you use the wheel over the color bars. but will still scroll the page when you move the wheel outside this target, over the document.
  console.log('target:',event.target.tagName);
  console.log('currentTarget:',event.currentTarget.tagName);
  console.log(' ');
};

document.addEventListener('wheel', showTarget);
document.querySelector('body').addEventListener('wheel', showTarget);
document.querySelector('.container').addEventListener('wheel', showTarget);</code></pre>

                    <p>After some testing, you conclude that the ideal approach is to add .stopPropagation() to the shuffleColor() handler:</p>

                    <pre><code>const shuffleColor = (event) => {
  event.stopPropagation();
  if (event.deltaY > 0) {
    // get next family color from array/object, update the color bar title, color, info box
  }
  else if (event.deltaY < 0) {
    // get previous family color from array/object, update the color bar title, color, info box
  }
};</code></pre>

                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/pnvlrs211u?seo=false&videoFoam=false" title="Stopping Event Propagation" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                <h3>Conclusion</h3>
                <p>Knowing how to handle events is extremely important to a great design and implementation. Remember to use your console to log events so you can better visualize how propagation is happening and which elements have a default action.</p>

                <p>You can always access the original target from anywhere in your application, as well as modify default actions and "kill" events when you don't want them to traverse the DOM.</p>
            </div>

            <div class="content-box module2-accent">
                <h2>Guided Project</h2>
              <p><a href="https://github.com/bloominstituteoftechnology/web-guided-project-dom-2" target="_blank" rel="noopener noreferrer">DOM II Starter Code</a></p>
              <p><a href="https://github.com/bloominstituteoftechnology/web-guided-project-dom-2-solution" target="_blank" rel="noopener noreferrer">DOM II Solution</a></p>
              <div class="video-container">
                  <iframe src="https://fast.wistia.net/embed/iframe/b60x8cm1sj" title="DOM II Guided Project" allow="autoplay; fullscreen" loading="lazy"></iframe>
              </div>
            </div>

            <div class="content-box module2-accent">
                <h3>Module 2 Project: Events in the Browser</h3>

                <p>In this project, you will practice using "vanilla" JavaScript to manipulate the DOM without any frameworks. Your goal is to build a video game using only JavaScript. By the time you finish this project, you will have gained the foundation needed to build games such as Minesweeper, Connect-Four, Battleship, or any grid-based game you wish to create.</p>
                <p>The module project contains advanced problems that will challenge and stretch your understanding of the module's content. The project has built-in tests for you to check your work, and the solution video is available in case you need help or want to see how we solved each challenge, but remember, there is always more than one way to solve a problem. Before reviewing the solution video, be sure to attempt the project and try solving the challenges yourself.</p>
                

                <h3>Instructions</h3>

                <p>The link below takes you to Bloom's code repository of the assignment. You'll need to fork the repo to your own GitHub account, and clone it down to your computer:</p>
                <p>Starter Repo: <a href="https://github.com/bloominstituteoftechnology/W_S5M2_Project" target="_blank" rel="noopener noreferrer">Events in the Browser</a></p>

                <ul>
                    <li>Fork the repository,</li>
                    <li>clone it to your machine, and</li>
                    <li>open the README.md file in VSCode, where you will find instructions on completing this Project.</li>
                    <li>submit your completed project to the BloomTech Portal</li>
                </ul>

                <h3>Solution</h3>
                <div class="video-container">
                    <iframe src="https://fast.wistia.net/embed/iframe/wffgyrd8j6?seo=false&videoFoam=false" title="Events in the Browser Solution" allow="autoplay; fullscreen" loading="lazy"></iframe>
                </div>
            </div>

            <section class="resource-section">
                <h2 class="resource-section-title">Additional Resources</h2>
                <div class="resource-links">
                    <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener noreferrer" class="resource-link">
                        MDN: Event reference
                    </a>
                    <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener noreferrer" class="resource-link">
                        MDN: addEventListener()
                    </a>
                    <a href="https://javascript.info/introduction-browser-events" target="_blank" rel="noopener noreferrer" class="resource-link">
                        JavaScript.info: Introduction to Browser Events
                    </a>
                    <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events" target="_blank" rel="noopener noreferrer" class="resource-link">
                        MDN: Introduction to events
                    </a>
                </div>
            </section>
        </section>
    </main>
</body>
</html> 