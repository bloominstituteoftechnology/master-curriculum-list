<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Module 2: Client-Side Auth - Web Unit 3 Sprint 11</title>
  <link rel="stylesheet" href="../../assets/css/style.css">
</head>

<body>
  <header>
    <nav>
      <div class="logo">Web Unit 3 Sprint 11</div>
      <ul>
        <li><a href="../../index.html">Home</a></li>
        <li class="dropdown">
          <a href="#" class="active">Modules</a>
          <div class="dropdown-content">
            <a href="../module1/index.html">Module 1: Testing React</a>
            <a href="../module2/index.html" class="active">Module 2: Client-Side Auth</a>
            <a href="../module3/index.html">Module 3: HTTP: The Native Fetch</a>
            <a href="../module4/index.html">Module 4: Deploying Web Apps</a>
          </div>
        </li>
        <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
      </ul>
    </nav>
  </header>

  <main class="container">
    <h1>Module 2: Client-Side Auth - Web Unit 3 Sprint 11</h1>
    <section class="welcome">
      <div class="content-box module2-accent">
        <h2>Understanding Login Requests</h2>
        <p>This lesson will cover login requests, a fundamental aspect of web development. We will explore how a simple
          action like logging into a website involves making a network request, focusing on the POST request method,
          headers and payloads. By the end of this Learning Objective, you'll understand the structure of requests and
          responses and how to inspect them using tools like HTTPie, Chrome Developer Tools, and Postman.</p>

        <p>Ready to dive into the details? Let's get started!</p>
        <div class="note-box">
          <h3>How to Build It</h3>
          <h4>Exploring the Request-Response Cycle</h4>
          <p>When you enter credentials on a login page, you're actually sending a POST request to the server. This
            request includes headers—key-value pairs with information about the request—and a payload, the data you're
            sending, typically in JSON format. The server then processes this request and sends back a response, also
            structured with headers and a body, which might contain a welcome message or an error code, like the 401
            Unauthorized status.</p>

          <img src="../../assets/images/testing1.png" alt="Request and Response">

          <p>http request and response</p>

          <h4>Inspecting Requests with Developer Tools</h4>
          <p>Using Chrome's Developer Tools, you can see the details of the request you've made, including the URL,
            method, status code, headers, and the payload you've sent. Similarly, the response from the server,
            including its headers and body, can be inspected. This allows you to understand what information is being
            exchanged and debug issues related to login processes effectively.</p>

          <img src="../../assets/images/testing2.png" alt="Inspecting Requests">

          <p>network tab in chrome</p>

          <h4>The Role of Tokens</h4>
          <p>In successful login attempts, the server responds with a token—a string that represents your authentication
            status. This token can be used for subsequent requests to access protected resources, signifying a crucial
            element in web security and session management.</p>

          <img src="../../assets/images/testing3.png" alt="Successful Login">

          <p>successful login</p>

          <h4>Practical Tools for Inspecting HTTP Traffic</h4>
          <p>Beyond Chrome's Developer Tools, tools like <a href="https://httpie.io/" target="_blank"
              rel="noopener noreferrer">HTTPie</a> and Postman
            offer robust capabilities for inspecting and debugging HTTP traffic. They allow for manual
            assembly and inspection of requests and responses, providing a deeper understanding of the
            underpinnings of web communication.</p>

          <p>Through Postman, for instance, you can construct a login request by specifying the method, URL, and
            payload, and then send it off to see the response. This hands-on approach not only demystifies the login
            process but also equips you with practical skills for your web development toolkit.</p>
          <div class="video-container">
            <iframe title="Web Unit 3 Sprint 11 Module 2 Video"
              src="https://fast.wistia.net/embed/iframe/km6meui62f?seo=false&videoFoam=false"
              allow="autoplay; fullscreen" loading="lazy"></iframe>
          </div>
        </div>
        <h2>Handling Authentication with Tokens</h2>
        <p>This learning objective introduces token authentication, a method allowing applications to authenticate users
          and manage sessions. We will cover the complete process from logging in and receiving a token to using this
          token for accessing protected resources and handling common challenges.</p>
        <div class="note-box">
          <h3>How to Build It</h3>
          <h4>Introduction to Token Authentication</h4>
          <p>Instead of providing username and password all the time, tokens allow you to login once and access a
            multitude of services. Here's how it works:</p>

          <ul>
            <li>Login: You submit your credentials (username/password) to a login endpoint.</li>
            <li>Receive a Token: If your credentials are correct, the server sends back a JSON Web Token (JWT).</li>
            <li>Use the Token: You use this token to access protected resources without needing to log in again.</li>
          </ul>

          <p>JWTs are secure, efficient, and stateless. They're composed of three parts: Header, Payload, and Signature.
            Together, they ensure your token is valid and hasn't been tampered with.</p>

          <h4>Storing the Token</h4>
          <p>Once received, the token must be stored for future use. There are different approaches for this. One option
            is to use the browser's local storage. This is simple but it has the downside that any script running on the
            page can access local storage, so it's crucial that the token be short-lived, and not contain any sensitive
            information:</p>

          <pre><code>// inside the login form component
const handleSubmit = async (event) => {
  event.preventDefault()
  try {
    const { data } = await axios.post(
      `/api/auth/login`,
      { username, password },
    )
    localStorage.setItem('token', data.token)
  } catch (err) {
    setError('An error occurred. Please try again.')
  }
}</code></pre>

          <h4>Redirecting After Successful Login</h4>
          <p>Successful authentication may redirect the user to a protected area. This involves utilizing React Router's
            navigation hook:</p>

          <pre><code>// inside the login form component
const navigate = useNavigate()

const handleSubmit = async (event) => {
  event.preventDefault()
  try {
    const { data } = await axios.post(
      `/api/auth/login`,
      { username, password },
    )
    localStorage.setItem('token', data.token)
    navigate('/todos') // redirecting the user after successful login
  } catch (err) {
    setError('An error occurred. Please try again.')
  }
}</code></pre>

          <h4>Using the Token for Protected Assets</h4>
          <p>Once the user lands on the new route, a request may go off to requests assets that are meant for
            authenticated users. Without a valid token, the server will respond with a 401 Unauthorized error.</p>

          <p>Calling an endpoint that requires authentication involves fishing the token from local storage and
            appending it to the Authorization header of the request. The token is just as good as valid credentials (as
            long as the token hasn't expired).</p>

          <pre><code>// inside the component that requests protected assets
useEffect(() => {
  const token = localStorage.getItem('token') // grab the token
  const fetchTodos = async () => {
    try {
      const { data } = await axios.get(
        '/api/todos', // the endpoint that requires auth
        { headers: { Authorization: token } }, // this appends the header
      )
      setTodos(data) // handle success
    } catch (error) {
      // handle failure
    }
  }
  fetchTodos()
}, [])</code></pre>

          <p>See the Authorization header going out carrying the token:</p>
          <img src="../../assets/images/testing4.png" alt="Authorization Header with Token">
          <div class="video-container">
            <iframe title="Web Unit 3 Sprint 11 Module 2 Video"
              src="https://fast.wistia.net/embed/iframe/3syjzrhqhh?seo=false&videoFoam=false"
              allow="autoplay; fullscreen" loading="lazy"></iframe>
          </div>
        </div>
        <h2>Implementing Protected Routes</h2>
        <p>This learning objective covers how to prevent users that are not logged in from accessing certain parts of
          your app. Real security happens on the back end, with the server refusing access to unauthorized users, but
          it's still important for user experience to be sent to the login screen if an attempt is made to perform an
          operation that requires auth. Let's take a look at how!</p>
        <div class="note-box">
          <h3>How to Build It</h3>
          <h4>Redirecting Back to Login</h4>
          <p>If a component that loads protected assets cannot find a JSON Web Token in local storage, we will send the
            user back to the login screen:</p>

          <pre><code>// inside the component that requests assets that require authentication
const navigate = useNavigate() // navigation hook from React Router

useEffect(() => {
  const token = localStorage.getItem('token') // attempt to get token
  if (!token) { // if there isn't a token
    navigate('/') // redirect to the login screen
  } else {
    // perform the authenticated request
    const fetchTodos = async () => {
      try {
        const response = await axios.get(
          '/api/todos',
          { headers: { Authorization: token } },
        )
        setTodos(response.data)
      } catch (error) {
        // handle error
      }
    }
    fetchTodos()
  }
}, [])</code></pre>

          <h4>Handling Expired Tokens</h4>
          <p>Even if a token exits, it might be stale! If this happens, the request will go out, but the server will
            respond with the dreaded 401 Unauthorized error. In this case, we'd like to flush the stale token from local
            storage and redirect the user to the login screen. These two operations, together, constitute something of a
            "logout flow". Let's implement a function for this:</p>

          <pre><code>const logout = () => {
  localStorage.removeItem('token')
  navigate('/')
}</code></pre>

          <p>On 401, we will use the logout function to send the user back to the login screen. These changes make it so
            that this route cannot be accessed without a token, and also forces users to auth again if the token
            expires:</p>

          <pre><code>export default function Todos() {
  const [todos, setTodos] = useState([])
  const navigate = useNavigate()

  const logout = () => {
    localStorage.removeItem('token')
    navigate('/')
  }

  useEffect(() => {
    const token = localStorage.getItem('token')
    if (!token) {
      navigate('/') // back to login screen
    } else {
      const fetchTodos = async () => {
        try {
          const response = await axios.get(
            '/api/todos',
            { headers: { Authorization: token } }
          )
          setTodos(response.data)
        } catch (error) {
          if (error?.response?.status == 401) logout() // stale token gone, back to login screen
          // we must still handle gracefully errors by other causes...
        }
      }
      fetchTodos()
    }
  }, [])
  // the rest of the Todos component...</code></pre>

          <h4>Manual Logout Functionality</h4>
          <p>The logout function we just implemented can also be wired to a "Logout" button in the user interface, to
            allow users to log out themselves.</p>
          <div class="video-container">
            <iframe title="Web Unit 3 Sprint 11 Module 2 Video"
              src="https://fast.wistia.net/embed/iframe/3n1o8roeiv?seo=false&videoFoam=false"
              allow="autoplay; fullscreen" loading="lazy"></iframe>
          </div>
        </div>
      </div>

      <div class="content-box module2-accent">
        <h2>Guided Project</h2>
        <p><a href="https://github.com/bloominstituteoftechnology/w_s11_frontend_auth_gp" target="_blank"
            rel="noopener">Client Side Auth Starter Code</a></p>
        <p><a href="https://github.com/bloominstituteoftechnology/w_s11_frontend_auth_gp-solution" target="_blank"
            rel="noopener">Client Side Auth Solution</a></p>
        <div class="video-container">
          <iframe title="Web Unit 3 Sprint 11 Guided Project" src="https://fast.wistia.net/embed/iframe/6ra4z4rc71"
            allow="autoplay; fullscreen" loading="lazy"></iframe>
        </div>
      </div>

      <div class="content-box module2-accent">
        <h2>Module 2 Project: Frontend Auth</h2>

        <p>This project will have you build register and sign in functionality to an auth form. On register, you will
          welcome the new user. On login, you will pull an authentication token from the response, and save it to the
          browser's local storage. This token will be used to obtain protected resources from the server, without having
          to provide username and password with each request. You will also implement functionality to log users out,
          and redirect unknown users away from certain routes.</p>

        <p>The Module Project contains advanced problems that will challenge and stretch your understanding of the
          module's content. The solution video is available below in case you need help or want to see how we solved
          each challenge (note: there is always more than one way to solve a problem). If you can successfully complete
          all the Module Projects in a sprint, you are ready for the Sprint Challenge and Assessment.</p>


        <h3>Instructions</h3>

        <p>The link below takes you to Bloom's code repository of the assignment. You'll need to fork the repo to your
          own GitHub account, and clone it down to your computer:</p>
        <p>Starter Repo: <a href="https://github.com/bloominstituteoftechnology/w_s11_frontend_auth_mp_start"
            target="_blank" rel="noopener noreferrer">Frontend Auth</a></p>

        <ul>
          <li>Fork the repository,</li>
          <li>clone it to your machine, and</li>
          <li>open the README.md file in VSCode, where you will find instructions on completing this Project.</li>
          <li>submit your completed project to the BloomTech Portal</li>
        </ul>

        <h3>Solution</h3>
        <div class="video-container">
          <iframe title="Web Unit 3 Sprint 11 Solution Video"
            src="https://fast.wistia.net/embed/iframe/4x6w0wkmh2?seo=false&videoFoam=false" allow="autoplay; fullscreen"
            loading="lazy"></iframe>
        </div>
      </div>

      <div class="content-box">
        <h2>Additional Resources</h2>
        <div class="resource-section">
          <div class="resource-links">
            <a href="https://github.com/bloominstituteoftechnology/w_s11_frontend_auth_gp" class="resource-link">Module
              2 Guided Project</a>
            <a href="https://github.com/bloominstituteoftechnology/w_s11_frontend_auth_gp_end"
              class="resource-link">Solution Guide</a>
          </div>
        </div>
      </div>
    </section>
  </main>
</body>

</html>