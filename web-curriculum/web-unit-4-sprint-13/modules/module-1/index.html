<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 1 - Node.js & Express - Web Unit 4 Sprint 13</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
</head>

<body>
    <header>
        <nav>
            <div class="logo">Web Unit 4 Sprint 13</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module-1/index.html" class="active">Module 1: Node.js & Express Basics</a>
                        <a href="../module-2/index.html">Module 2: Server-Side Routing</a>
                        <a href="../module-3/index.html">Module 3: Express Middleware</a>
                        <a href="../module-4/index.html">Module 4: Deployment & Best Practices</a>
                    </div>
                </li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
                <li class="dropdown">
                    <a href="#">Resources</a>
                    <div class="dropdown-content">
                        <a href="../../learning-resources/important-info.html">Important Info</a>
                        <a href="../../learning-resources/academic-support.html">Academic Support</a>
                    </div>
                </li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            <h1>Introduction to Node.js & Express</h1>

            <div class="content-box module1-accent">
                <h2>What is Node.js</h2>
                <p>Traditionally, developers only used the JavaScript language in web browsers. But, in 2009, Node.js was unveiled, and with it, the developer tool kit expanded greatly. Node.js gave developers the chance to use JavaScript to write software that, up to that point, could only be written using C, C++, Java, Python, Ruby, C#, and the like.</p>

                <p>We will use Node to write server code. Specifically, web services that communicate with clients using the JavaScript Object Notation (JSON) format for data interchange.</p>

                <h3>Advantages of Node.js</h3>
                <ul>
                    <li>Node.js uses the same programming language (JavaScript) and paradigm for both client and server. Using the same language, we minimize context switching and share code between the client and the server.</li>
                    <li>JavaScript is single-threaded, which removes the complexity involved in handling multiple threads.</li>
                    <li>JavaScript is asynchronous, which allows us to take full advantage of the processor it's running on. Taking full advantage of the processor is crucial because the node process will be running on a single CPU.</li>
                    <li>Using JavaScript gives us access to the npm repository. This repository is the largest ecosystem of valuable libraries (most free to use) in npm modules.</li>
                </ul>

                <h3>Disadvantages of Node.js</h3>
                <ul>
                    <li>By strictly using JavaScript on the server, we cannot use the right tool (a particular language) for the job.</li>
                    <li>Because JavaScript is single-threaded, we can't take advantage of servers with multiple cores/processors.</li>
                    <li>Because JavaScript is asynchronous, it is harder to learn for developers that have only worked with languages that default to synchronous operations that block the execution thread.</li>
                    <li>In the npm repository, there are often too many packages that do the same thing. This excess of packages makes it harder to choose one and, in some cases, may introduce vulnerabilities into our code.</li>
                </ul>

                <h3>Writing a Simple Web Server</h3>
                <p>To write a simple web server with Node.js:</p>
                <ul>
                    <li>Use Node's HTTP module to abstract away complex network-related operations.</li>
                    <li>Write the single request handler function to handle all requests to the server.</li>
                </ul>

                <p>The request handler is a function that takes the request coming from the client and produces the response. The function takes two arguments: 1) an object representing the request and 2) an object representing the response.</p>

                <p>This process works, but the resulting code is verbose, even for the simplest of servers. Also, note that when using only Node.js to build a server, we use a single request handler function for all requests.</p>
                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>1. First, create a new folder for your server project and create an index.js file inside it.</p>
                    
                    <p>2. Add this code to index.js:</p>
                    
                    <pre><code>const http = require("http"); // built in node.js module to handle http traffic

const hostname = "127.0.0.1"; // the local computer where the server is running
const port = 3000; // a port we'll use to watch for traffic

const server = http.createServer((req, res) => {
    // creates our server
    res.statusCode = 200; // http status code returned to the client
    res.setHeader("Content-Type", "text/plain"); // inform the client that we'll be returning text
    res.end("Hello World from Node\n"); // end the request and send a response with the specified message
});

server.listen(port, hostname, () => {
    // start watching for connections on the port specified
    console.log(`Server running at http://${hostname}:${port}/`);
});</code></pre>

                    <p>3. Open your terminal, navigate to your project folder, and run:</p>
                    <pre><code>node index.js</code></pre>

                    <p>4. You should see the message: "Server running at http://127.0.0.1:3000"</p>

                    <p>5. Open your browser and visit: <code>http://localhost:3000</code></p>

                    <p>You should see the message "Hello World from Node" displayed in your browser. Congratulations! You've created your first web server using Node.js.</p>
                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/ct95ruopnk" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                <h2>What is Express</h2>
                <p>Node's built-in HTTP module provides a powerful way to build web applications and services. However, it requires a lot of code for everyday tasks like sending an HTML page to the browser.</p>

                <p>Introducing Express, a light and unopinionated framework that sits on top of Node.js, making it easier to create web applications and services. Sending an HTML file or image is now a one-line task with the sendFile helper method in Express.</p>

                <p>Ultimately, Express is just a Node.js module like any other module.</p>

                <h3>What can we do with Express?</h3>
                <ul>
                    <li>Build web applications.</li>
                    <li>Serve Single Page Applications (SPAs).</li>
                    <li>Build RESTful web services that work with JSON.</li>
                    <li>Serve static content, like HTML files, images, audio files, PDFs, and more.</li>
                    <li>Power real-time applications using technologies like Web Sockets or WebRTC.</li>
                </ul>

                <h3>Benefits of Express</h3>
                <ul>
                    <li>Simple</li>
                    <li>Unopinionated</li>
                    <li>Extensible</li>
                    <li>Light-weight</li>
                    <li>Compatible with Connect middleware</li>
                    <li>Clean, intuitive, and easy-to-use API</li>
                    <li>Abstracts away common tasks</li>
                </ul>

                <h3>Drawbacks of Express</h3>
                <ul>
                    <li>It's not a one-stop solution. Because of its simplicity, it does very little out of the boxâ€”especially when compared to frameworks like Ruby on Rails and Django.</li>
                    <li>We are forced to make more decisions due to the flexibility and control it provides.</li>
                </ul>

                <h3>Main Features of Express</h3>
                
                <h4>Middleware</h4>
                <ul>
                    <li>Middleware functions can get the request and response objects, operate on them, and (when specified) trigger some action. Examples are logging or security.</li>
                    <li>Express's middleware stack is an array of functions.</li>
                    <li>Middleware can change the request or response, but it doesn't have to.</li>
                </ul>

                <h4>Routing</h4>
                <p>Routing is a way to select which request handler function is executed. It does so based on the URL visited and the HTTP method used. Thus, routing provides a way to break an application into smaller parts.</p>

                <h4>Routers for Application Modularity</h4>
                <p>We can break up applications into routers. For example, we could have a router to serve our SPA and another router for our API. Each router can have its middleware and routing. This combination provides improved functionality.</p>

                <h4>Convenience Helpers</h4>
                <p>Express has many helpers that provide out-of-the-box functionality to make writing web applications and API servers easier.</p>
                <p>A lot of those helpers are extension methods added to the request and response objects.</p>
                <p>Examples from the Api Reference include: response.redirect(), response.status(), response.send(), and request.ip.</p>

                <h4>Views</h4>
                <p>Views provide a way to dynamically render HTML on the server and even generate it using other languages.</p>
                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>Let's write our first server using Express:</p>

                    <ol>
                        <li>Create a new file called <code>server.js</code> to host our server code.</li>
                        <li>Type <code>npm init -y</code> to generate a package.json.</li>
                        <li>Install the express npm module using: <code>npm install express</code>.</li>
                        <li>Inside <code>server.js</code> add the following code:</li>
                    </ol>

                    <pre><code>const express = require('express'); // import the express package

const server = express(); // creates the server

// handle requests to the root of the api, the / route
server.get('/', (req, res) => {
  res.send('Hello from Express');
});

// watch for connections on port 9000
server.listen(9000, () =>
  console.log('Server running on http://localhost:9000')
);</code></pre>

                    <ol start="5">
                        <li>Run the server by typing: <code>node server.js</code> and visit <code>http://localhost:9000</code> in the browser.</li>
                    </ol>

                    <p>To stop the server, type <code>Ctrl + c</code> at the terminal window.</p>
                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/49e1wq9cgt" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                <h2>Create an API</h2>
                <p>In this overview, we're walking through the steps necessary to build a simple Web API that returns the string "Hello World" on every incoming GET request. The program should return the string every time a request comes into the root route ("/"). For now, you don't need to code along, just read through the steps.</p>

                <p>To make things easier, we'll use an existing repository as the base for our API. Then, later in the week, as we learn more about Node.js and Express, we'll create an API from scratch.</p>

                <p>To build our first API, we will:</p>

                <ol>
                    <li>clone the <a href="https://github.com/LambdaSchool/node-express-mini" target="_blank" rel="noopener noreferrer">node-express-mini repository</a> to a folder on our computer.</li>
                    <li>Navigate into the folder using <code>cd</code>.</li>
                    <li>Use <code>npm install</code> to download all dependencies.</li>
                    <li>Add a file called <code>index.js</code> at the folder's root, next to the <code>package.json</code> file.</li>
                    <li>Open the <code>index.js</code> file using our favorite code editor.</li>
                    <li>Add the following code:</li>
                </ol>

                <pre><code>// require the express npm module, needs to be added to the project using "npm install express"
const express = require('express');

// creates an express application using the express module
const server = express();

// configures our server to execute a function for every GET request to "/"
// the second argument passed to the .get() method is the "Route Handler Function"
// the route handler function will run on every GET request to "/"
server.get('/', (req, res) => {
  // express will pass the request and response objects to this function
  // the .send() on the response object can be used to send a response to the client
  res.send('Hello World');
});

// once the server is fully configured we can have it "listen" for connections on a particular "port"
// the callback function passed as the second argument will run once when the server starts
server.listen(8000, () => console.log('API running on port 8000'));</code></pre>

                <p>make sure to save your changes to <code>index.js</code>.</p>

                <p>We are using the express npm module in our code, so we need to add it as a dependency to our project. To do this:</p>

                <ol>
                    <li>Open a terminal/console/command prompt window and navigate to the root of our project.</li>
                    <li>Add express to our <code>package.json</code> file by typing <code>npm install express</code>.</li>
                </ol>

                <p>Now we're ready to test our API!</p>

                <p>In the terminal, still at the root of our project:</p>

                <ol>
                    <li>Type: <code>npm run server</code> to run our API. The message "Api running on port 8000" should appear on the terminal.</li>
                    <li>Open a web browser and navigate to "http://localhost:8000".</li>
                </ol>

                <p>There we have it, our first API!</p>

                <p>A lot is going on in those few lines of code (only six lines if we remove the comments and white space). We will cover every piece of it in detail over the following modules, but here is a quick rundown of the most important concepts.</p>

                <p>First, we used <code>require()</code> to import the express module and make it available to our application. <code>require()</code> is similar to the import keyword we have used before. The line <code>const express = require('express');</code> is equivalent to <code>import express from 'express';</code> if we were using ES2015 syntax.</p>

                <p>The following line creates our Express application. The return of calling <code>express()</code> is an Express application that we can use to configure our server and, eventually, start listening for and responding to requests. Notice we use the word server, not API. An Express application is generic, which means we can use it to serve static content (HTML, CSS, audio, video, PDFs, and more). We can also use an Express application to serve dynamically generated web pages, build real-time communications servers, and more. Finally, we will use it statically to accept requests from clients and respond with data in JSON format.</p>

                <p>An Express application publishes a set of methods we can use to configure functions. We are using the <code>.get()</code> method to set up a route handler function that will run on every GET request. As a part of this handler function, we specify the URL which will trigger the request. In this case, the URL is the site's root (represented by a /). There are also methods to handle the POST, PUT, and DELETE HTTP verbs.</p>

                <p>The first two arguments passed by express to a route handler function are 1) an object representing the request and 2) an object representing the response. Express expands those objects with a set of useful properties and methods. Our example uses the <code>.send()</code> method of the response object to specify the data we will send to the client as the response body. You can call the first two arguments anything you want, but it is prevalent to see them dubbed <code>req</code> and <code>res</code>. We at BloomTech call them the homies as they always hang out together.</p>

                <p>That's all the configuring we need to do for this first example. We'll see other ways of configuring our server as we go forward.</p>

                <p>After configuring the server, it's time to turn it on. We use the <code>.listen()</code> method to monitor a port on the computer for any incoming connections and respond to those we have configured. Our server will only respond to GET requests made to the / route on port 8000.</p>

                <p>That's it for our first Web API, and now it's time for you to follow along as we add a new endpoint to our server that returns JSON data!</p>
                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>Let's try returning JSON instead of just a simple string.</p>

                    <p>Please follow the steps outlined on the overview, but, to save time, copy and paste the content of index.js instead of typing it. Then run your API through a browser to make sure it works.</p>

                    <p>Now follow along as we code a new endpoint that returns an array of movie characters in JSON format.</p>

                    <p>The first step is to define a new route handler to respond to GET requests at the /hobbits endpoint:</p>

                    <pre><code>server.get('/hobbits', (req, res) => {
  // route handler code here
});</code></pre>

                    <p>Next, we define the return data that our endpoint will send back to the client. We do this inside the newly defined route handler function:</p>

                    <pre><code>const hobbits = [
    { id: 1, name: 'Samwise Gamgee' },
    { id: 2, name: 'Frodo Baggins' },
];</code></pre>

                    <p>Now we can return the hobbits array. We could use .send(hobbits) as we did for the string on the / endpoint, but this time we'll learn about two other useful methods we find in the response object:</p>

                    <pre><code>res.status(200).json(hobbits);</code></pre>

                    <p>We should provide as much useful information as possible to the clients using our API. One such piece of data is the HTTP status code that reflects the client's operation outcome. In this case, the client is trying to get a list of a particular resource, a hobbits list. Sending back a 200 OK status code communicates to the client that the operation was successful.</p>

                    <p>We will see other status codes as we continue to build new endpoints during this week. You can see a list by following this link to the documentation about <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank">HTTP Response Codes on the Mozilla Developer Network site</a>.</p>

                    <p>We can use the .status() method of the response object to send any valid HTTP status code.</p>

                    <p>We are also chaining the .json() method of the response object. We do this to communicate to both the client making the request and the next developer working with this code that we intend to send the data in JSON format.</p>

                    <p>The complete code for index.js should now look like so:</p>

                    <pre><code>const express = require('express');

const server = express();

server.get('/', (req, res) => {
  res.send('Hello World');
});
server.get('/hobbits', (req, res) => {
  const hobbits = [
    { id: 1, name: 'Samwise Gamgee' },
    { id: 2, name: 'Frodo Baggins' },
  ];
  res.status(200).json(hobbits);
});

server.listen(8000, () => console.log('API running on port 8000'));</code></pre>

                    <p>Now we can visit http://localhost:8000/hobbits in our browser, and we should get back our JSON array.</p>

                    <p>If you are using the Google Chrome browser, this <a href="https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa" target="_blank">extension</a> can format the JSON data in a more readable fashion.</p>

                    <p>Besides GET, there also exist POST (for creating), PUT (for updating or replacing) and DELETE actions we can ask the server to perform. Here is our Hobbits API, expanded to support full CRUD (Create, Read, Update and Delete):</p>

                    <pre><code>const express = require('express');

const server = express();
server.use(express.json()); // !! IMPORTANT this teaches express to parse req.body

let id = 0
let getId = () => ++id // helper function to create auto-incrementing ids

let hobbits = [ // our fake hobbits database table
  { id: getId(), name: 'Samwise Gamgee' },
  { id: getId(), name: 'Frodo Baggins' },
];

server.get('/hobbits', (req, res) => { // GET ALL EXISTING HOBBITS
  res.status(200).json(hobbits); // 200 means "OK"
});
server.get('/hobbits/:id', (req, res) => { // GET EXISTING HOBBIT BY id
  // the desired id comes in the URL, and is found in `req.params.id`
  res.status(200).json(hobbits.find(hob => hob.id == req.params.id));
});
server.post('/hobbits', (req, res) => { // POST NEW HOBBIT
  // the desired name comes in the body, and is found in `req.body.name`
  hobbits.push({ id: getId(), name: req.body.name });
  res.status(201).json(hobbits); // 201 means "Created"
});
server.put('/hobbits/:id', (req, res) => { // PUT EXISTING HOBBIT
  // the id to update is in `req.params.id` and the desired name in `req.body.name`
  hobbits = hobbits.map(hob => hob.id == req.params.id
    ? { ...hob, name: req.body.name } : hob);
  res.status(200).json(hobbits);
});
server.delete('/hobbits/:id', (req, res) => { // DELETE EXISTING HOBBIT
  hobbits = hobbits.filter(hob => hob.id != req.params.id);
  res.status(200).json(hobbits);
});

server.listen(8000, () => console.log('API running on port 8000'));</code></pre>
                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/xld7g7jflu" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                <h2>Using Postman to Test Your API</h2>
                <p>Testing APIs is different from testing websites or web applications. A web browser is sufficient to test the latter, but we need to make POST/PUT/PATCH/DELETE requests for APIs and even modify the request headers.</p>

                <p>For testing, we will use a tool called Postman. Postman and other similar tools allow full control when making requests. For example, we can easily change the HTTP Method used, add JSON data to the body, add form data, add headers, examine the response, and more.</p>

                <p>In Postman's case, you can do a lot more. But, for now, we'll limit our discussion to the basics needed to test APIs by passing test data and examining whether we're getting the expected response.</p>

                <p>We recommend installing the native application for your Operating System, however, VS Code has a Postman extension as well that can really speed up the process.</p>
                <div class="video-container">
                    <iframe src="https://fast.wistia.net/embed/iframe/1ac3yzsgxt" allow="autoplay; fullscreen" loading="lazy"></iframe>
                </div>
            </div>
            <div class="content-box module1-accent">
                <h2>Guided Project</h2>
              <p><a href="https://github.com/bloominstituteoftechnology/node-api1-guided" target="_blank" rel="noopener">Intro to Node.js & Express Starter Code</a></p>
              <p><a href="https://github.com/bloominstituteoftechnology/node-api1-guided-solution" target="_blank" rel="noopener">Intro to Node.js & Express Solution</a></p>
              <div class="video-container">
                  <iframe src="https://fast.wistia.net/embed/iframe/8pgwmiga69" title="Guided Project" allow="autoplay; fullscreen" loading="lazy"></iframe>
              </div>
            </div>

            <div class="content-box module1-accent">
                <h2>Module 1 Project: Intro to Node.js & Express</h2>

            
                <p>The module project contains advanced problems that will challenge and stretch your understanding of the module's content. The project has built-in tests for you to check your work, and the solution video is available in case you need help or want to see how we solved each challenge, but remember, there is always more than one way to solve a problem. Before reviewing the solution video, be sure to attempt the project and try solving the challenges yourself.</p>
                

                <h3>Instructions</h3>

                <p>The link below takes you to Bloom's code repository of the assignment. You'll need to fork the repo to your own GitHub account, and clone it down to your computer:</p>
                <p>Starter Repo: <a href="https://github.com/bloominstituteoftechnology/node-api1-project" target="_blank">Node API 1</a></p>

                <ul>
                    <li>Fork the repository,</li>
                    <li>clone it to your machine, and</li>
                    <li>open the README.md file in VSCode, where you will find instructions on completing this Project.</li>
                    <li>submit your completed project to the BloomTech Portal</li>
                </ul>

                <h3>Solution</h3>
                <div class="video-container">
                    <iframe src="https://fast.wistia.net/embed/iframe/ppql0uuoxi" title="Solution Video" allow="autoplay; fullscreen" loading="lazy"></iframe>
                </div>
            </div>

            <section class="resource-section">
                <h2 class="resource-section-title">Additional Resources</h2>
                <div class="resource-links">
                    
                    <a href="https://nodejs.org/en/docs/" target="_blank" rel="noopener noreferrer"
                        class="resource-link">
                        Node.js Documentation
                    </a>
                    <a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer" class="resource-link">
                        Express Documentation
                    </a>
                    <a href="https://nodejs.dev/learn" target="_blank" rel="noopener noreferrer" class="resource-link">
                        Introduction to Node.js
                    </a>
                    <a href="https://www.getpostman.com/docs/v6/" target="_blank" rel="noopener noreferrer" class="resource-link">
                        Postman Documentation
                    </a>
                </div>
            </section>
        </section>
    </main>
</body>

</html>