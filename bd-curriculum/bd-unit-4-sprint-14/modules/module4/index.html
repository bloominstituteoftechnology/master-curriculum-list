<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 4: Linked Lists - BD Unit 4 Sprint 14</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
</head>

<body>
    <header>
        <nav>
            <div class="logo">BD Unit 4 Sprint 14</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module1/index.html">Module 1: Creating Exceptions</a>
                        <a href="../module2/index.html">Module 2: Dependency Injection 1</a>
                        <a href="../module3/index.html">Module 3: Dependency Injection 2</a>
                        <a href="../module4/index.html" class="active">Module 4: Linked Lists</a>
                    </div>
                </li>
                <li><a href="../../code-alongs/index.html">Code-Alongs</a></li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            <h1>Module 4: Linked Lists</h1>

            <div class="content-box">
                <h2>Module Overview</h2>
                <p>Understanding and implementing linked list data structures in Java. Learn about the mechanics,
                    benefits, and trade-offs of using linked lists versus other collection types.</p>
            </div>

            <div class="content-box">
                <h2>Learning Objectives</h2>
                <ul>
                    <li>Design and implement a class that uses a List as a member that maintains an ordered collection
                        of objects</li>
                    <li>Explain why accessing a value by index from a LinkedList runs in linear O(n) time</li>
                    <li>Explain why inserting or removing the first value in a LinkedList runs in constant O(1) time
                    </li>
                    <li>Analyze whether to use a LinkedList or an ArrayList for a provided scenario</li>
                </ul>
            </div>

            <div class="content-box">
                <div class="video-container">
                    <iframe class="wistia_embed" title="Linked Lists Introduction"
                        src="https://fast.wistia.net/embed/iframe/4aeyfcntqa" width="100%" height="360"
                        name="wistia_embed" allowfullscreen="allowfullscreen" allow="fullscreen"
                        loading="lazy"></iframe>
                </div>
                <h3>Video Content: Linked Lists Introduction</h3>
                <p>This video introduces the concept of linked lists, explaining their structure, basic operations, and
                    comparative advantages over array-based lists in certain scenarios.</p>
                <pre><code>// Basic Node class for a singly linked list
public class Node&lt;T&gt; {
    private T data;
    private Node&lt;T&gt; next;
    
    public Node(T data) {
        this.data = data;
        this.next = null;
    }
    
    public T getData() {
        return data;
    }
    
    public void setData(T data) {
        this.data = data;
    }
    
    public Node&lt;T&gt; getNext() {
        return next;
    }
    
    public void setNext(Node&lt;T&gt; next) {
        this.next = next;
    }
}

// Simple LinkedList implementation
public class LinkedList&lt;T&gt; {
    private Node&lt;T&gt; head;
    private int size;
    
    public LinkedList() {
        head = null;
        size = 0;
    }
    
    // Add to the beginning - O(1) operation
    public void addFirst(T data) {
        Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
        newNode.setNext(head);
        head = newNode;
        size++;
    }
    
    // Get element at index - O(n) operation
    public T get(int index) {
        if (index &lt; 0 || index &gt;= size) {
            throw new IndexOutOfBoundsException("Index: " + index);
        }
        
        Node&lt;T&gt; current = head;
        for (int i = 0; i &lt; index; i++) {
            current = current.getNext();
        }
        
        return current.getData();
    }
}</code></pre>
                <p>This example shows a basic implementation of a singly linked list with a Node class and essential
                    operations. Note how adding to the beginning is an O(1) operation (constant time) because it only
                    requires updating the head reference, while accessing an element by index is an O(n) operation
                    (linear time) as we must traverse from the head to the desired index.</p>

                <h3>What is a linked list?</h3>
                <p>A linked list is a series of nodes, each of which contains an associated data element and a pointer
                    to either one or two other nodes. Each node is an object instance that has an associated data
                    element and a reference to the next member.</p>

                <p>A real-life example that illustrates a linked list is a treasure hunt. Treasure hunts are a fun way
                    to get out with friends and do some exploration. All treasure hunts start at a known location that
                    is given to all participants. The "head pointer" of a linked list points to its start location. At
                    each location, you pick up a prize and a clue leading to the next location. The final location of
                    the treasure hunt has a prize, but no clue, since there are no more locations to visit. The "tail
                    pointer" of a linked list points to its end location. In the treasure hunt, you don't necessarily
                    know how many locations there will be, but you always know that each location's clue points to the
                    next location in the hunt. To get a location by its index, you must visit all the previous locations
                    in order; it's not an O(1) lookup like an array.</p>

                <p>Nodes in linked lists are like locations in a treasure hunt. Each node (location) has a bit of data
                    (the prize) and a pointer to the next node (a clue leading to the next location). If you want to
                    locate the first clue you can use the head pointer to find it. However, finding a location in the
                    middle of the treasure hunt would be more work. You would have to start at the head and visit
                    locations one a time, following their clues until you reach the location you are looking for.</p>

                <p>The figure below depicts the data structures that are typically used to represent the linked list.
                    The head node is the leftmost node and the tail node is the rightmost node. There is a pointer to
                    the head node, and some linked lists have a pointer to the tail node. Each node has a pointer to the
                    next node in the linked list, but the tail node's pointer is null. You iterate through a linked list
                    by starting at the head node and traveling toward the tail node.</p>

                <div class="figure">
                    <img src="https://tk-assets.lambdaschool.com/0ad908af-7a04-45ee-a06f-4c292eaa27d1_image1.png"
                        alt="Modeling of a Single linked list. A linked list with 3 nodes: a head node with a data element and a pointer to the next node, a middle node with a data element and a pointer to the next node, and a tail node with a data element and a null pointer. There are also pointers to the head node and tail node."
                        loading="lazy" style="max-width: 100%; height: auto; display: block; margin: 0 auto;">
                </div>

                <div class="figure">
                    <p><strong>Modeling of a Single linked list.</strong> A linked list with 3 nodes: a head node with a
                        data element and a pointer to the next node, a middle node with a data element and a pointer to
                        the next node, and a tail node with a data element and a null pointer. There are also pointers
                        to the head node and tail node.</p>
                </div>

                <h4>Situations well suited for linked lists</h4>
                <p>Linked lists are most useful for a list of objects accessed in order. We add objects to the tail of
                    the list. We call removing objects from the head of the list "First In, First Out" (FIFO). We call
                    removing objects from the tail of the list "Last In, First Out" (LIFO).</p>

                <p>This simplified Amazon call center uses FIFO operations:</p>
                <ul>
                    <li>We take calls in the order they are received, meaning we add new calls to the end of the list
                        and take calls from the front of the list.</li>
                    <li>When we finish helping the customer at the front of the line, we remove them from the front of
                        the list.</li>
                    <li>We do not change the order of the calls, except for adding calls at the end of the list and
                        removing them from the front of the list.</li>
                </ul>

                <p>Recall that removing the head node for an ArrayList is O(n), because we remove the element at index 0
                    and shift all the remaining elements lower by one index. In just a moment, we will describe how a
                    linked list can remove its head node in O(1), making a linked list a better fit for this call
                    center.</p>

                <p>A stack of dinner plates uses LIFO operations:</p>
                <ul>
                    <li>As we wash each plate, we place it on top of the stack (end of the list).</li>
                    <li>As we make each guest's meal, we remove the plate on top of the stack (end of the list).</li>
                </ul>

                <p>Although we can add and remove from the end of an ArrayList in constant time, resizing it whenever it
                    grows larger than its backing array is expensive. While a single family's stack of dinner plates
                    won't grow very large, a stack of dinner plates for a buffet restaurant would be better suited to a
                    linked list.</p>

                <h4>Adding a node to the tail of a linked list</h4>
                <p>Let's consider what operations are necessary to add a new element to the end of a linked list.</p>

                <p>Linked lists don't store their nodes in an array, so we can't just add a node to the last array
                    index. Instead, each node points to the next node in order; therefore we must:</p>
                <ol>
                    <li>Create the new node with its data element</li>
                    <li>Find the tail node</li>
                    <li>Update the tail node to point to the new node</li>
                    <li>If a tail pointer exists, then update it to point at the new node</li>
                </ol>

                <p>If the list does not have a tail pointer, then finding the tail node requires starting at the head
                    and iterating until we reach the last node, making it an O(n) operation. If the list has a tail
                    pointer, then finding the tail node only requires accessing the value in the tail pointer, which is
                    an O(1) operation. The rest of the operations are all O(1), so the time complexity of adding a node
                    to the tail of a linked list is the same as the time complexity of finding the current tail node.
                </p>

                <p>The work required to add to the end of an ArrayList is similar, but includes large penalties for
                    resizing when the list grows larger than its backing array. In use cases that also include adding
                    nodes anywhere other than the end of the list, ArrayList has a penalty for moving all its later
                    items by one index. Linked lists are often more suitable for these use cases.</p>

                <img src="https://tk-assets.lambdaschool.com/e5050c25-c48a-48a1-ac66-aaecdf3b713a_image2.png"
                    alt="A linked list with a new node added to its tail. There are 3 nodes: a head node with a data element and pointer to the next node, the original tail node with a data element and a new pointer to the next node, and the new node which has a data element and null pointer."
                    loading="lazy" style="max-width: 100%; height: auto; display: block; margin: 0 auto;">

                <div class="figure">
                    <p><strong>A linked list with a new node added to its tail.</strong> There are 3 nodes: a head node
                        with a data element and pointer to the next node, the original tail node with a data element and
                        a new pointer to the next node, and the new node which has a data element and null pointer.</p>
                </div>

                <h4>Adding a node to the head of a linked list</h4>
                <p>Adding a new node to the head of a linked list is similar to adding a new tail node:</p>
                <ol>
                    <li>Create the new node with its data element</li>
                    <li>Find the head node</li>
                    <li>Update the new node to point at the head node</li>
                    <li>Update the head pointer to point at the new node</li>
                </ol>

                <p>Because all linked lists have a head pointer, finding the head node is an O(1) operation. The other
                    operations are all O(1). Therefore, adding a new head node is a constant-time operation.</p>

                <img src="https://tk-assets.lambdaschool.com/d62c5daf-6ecd-4685-9277-57d47bbfeb60_add-head-node.png"
                    alt="A linked list with a new node added to the head. There are 3 nodes: a new node a data element and pointer to the original head node, the head node with a data element and a pointer to the tail node, and the tail node with a data element and a null pointer. The head pointer has been updated to point at the new node."
                    loading="lazy" style="max-width: 100%; height: auto; display: block; margin: 0 auto;">

                <div class="figure">
                    <p><strong>A linked list with a new node added to the head.</strong> There are 3 nodes: a new node a
                        data element and pointer to the original head node, the head node with a data element and a
                        pointer to the tail node, and the tail node with a data element and a null pointer. The head
                        pointer has been updated to point at the new node.</p>
                </div>

                <h4>Removing a node from a linked list</h4>
                <p>The time complexity of removing a node from a linked list depends on finding the nodes that need to
                    be updated, just like adding a node to the tail. Up to three nodes can be involved: the preceding
                    node (the node that points to the node to be removed), the node to be removed, and the following
                    node (the node that the node-to-be-removed points at.)</p>

                <ol>
                    <li>Find the preceding node. If you are removing the head node, there is no preceding node.</li>
                    <li>Update the previous node's pointer to point at the following node. (If you are removing the head
                        node, update the head pointer instead.)</li>
                    <li>Set the removed node's pointer to null.</li>
                </ol>

                <p>Consider the time complexity of removing the first element from an ArrayList and from a linked list.
                    An ArrayList would have to shift all other elements one index lower, making it O(n). To remove an
                    element, a linked list only needs to change the head pointer to point at the second node in the
                    list, making it O(1) no matter how many items are in the list. This makes linked lists ideal for
                    FIFO operations, when we add nodes to the tail of the list and remove them from the head of the
                    list.</p>

                <img src="https://tk-assets.lambdaschool.com/2de0dbfa-40a0-44a6-a0e2-0644fd06c0db_image3.png"
                    alt="A linked list after removing the head node. The old head node and the old head pointer are faded out, indicating that the head pointer now points to the new head node. The new head node is unchanged: it still has a data element and pointer to the tail node, which has a data element and a null pointer. "
                    loading="lazy" style="max-width: 100%; height: auto; display: block; margin: 0 auto;">

                <div class="figure">
                    <p><strong>A linked list after removing the head node.</strong> The old head node and the old head
                        pointer are faded out, indicating that the head pointer now points to the new head node. The new
                        head node is unchanged: it still has a data element and pointer to the tail node, which has a
                        data element and a null pointer.</p>
                </div>

                <h4>Accessing nodes in a linked list</h4>
                <p>The efficiency of adding linked list tail nodes and removing linked list head nodes comes at a price.
                    Imagine you're about to start a treasure hunt and your friend calls you up and says they'll meet you
                    at the coffee shop near the 10th location for lunch. They don't want to spoil the hunt, so the only
                    way for you to meet them is to follow the clues through the first nine locations before you can get
                    the clue for the 10th.</p>

                <p>Like the treasure hunt, a linked list has no array index to look up entries in. To access the element
                    at n, we must iterate through the list until we count up to n nodes. Linked lists are well suited to
                    operations at their ends, but far less suited to operations requiring indexing.</p>

                <h4>When to use Java's LinkedList versus ArrayList -- Examples</h4>
                <p>Java uses a "doubly linked list" for its LinkedList implementation. Each node in a doubly linked list
                    has a pointer to its preceding node as well as its following node. Java's LinkedList has both a tail
                    pointer and a head pointer. Remember from our description above that the time complexity of "Adding
                    a node to the tail of a linked list" depends on finding the tail node. Since LinkedList has a tail
                    pointer, adding to its end is O(1).</p>

                <p>Consider the time complexity of removing the tail node in a doubly linked list. Since we have a tail
                    pointer, and the tail node has a pointer to its preceding node, finding the preceding node always
                    requires exactly two O(1) operations. Therefore, removing the tail node is an O(1) operation.</p>

                <p>The LinkedList <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html"
                        target="_blank" rel="noopener noreferrer">JavaDoc</a> shows that LinkedList implements the List
                    interface. Here's a table of the complexity of some List operations for Java's ArrayList and
                    LinkedList:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>LinkedList</th>
                            <th>ArrayList</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>size()</td>
                            <td>O(1)</td>
                            <td>O(1)</td>
                            <td>Number of elements in list</td>
                        </tr>
                        <tr>
                            <td>add(index, ...)</td>
                            <td>O(n)</td>
                            <td>O(n)</td>
                            <td>Add to middle of list</td>
                        </tr>
                        <tr>
                            <td>add(0, ...)</td>
                            <td>O(1)</td>
                            <td>O(n)</td>
                            <td>Add to beginning of list</td>
                        </tr>
                        <tr>
                            <td>add(...) / add(last, ...)</td>
                            <td>O(1)</td>
                            <td>O(1)</td>
                            <td>Add to end of list</td>
                        </tr>
                        <tr>
                            <td>remove(index)</td>
                            <td>O(n)</td>
                            <td>O(n)</td>
                            <td>Remove a middle element</td>
                        </tr>
                        <tr>
                            <td>remove(0)</td>
                            <td>O(1)</td>
                            <td>O(n)</td>
                            <td>Remove first element</td>
                        </tr>
                        <tr>
                            <td>remove(last)</td>
                            <td>O(1)</td>
                            <td>O(1)</td>
                            <td>Remove last element</td>
                        </tr>
                        <tr>
                            <td>get(index)</td>
                            <td>O(n)</td>
                            <td>O(1)</td>
                            <td>Access a middle element</td>
                        </tr>
                        <tr>
                            <td>get(0)</td>
                            <td>O(1)</td>
                            <td>O(1)</td>
                            <td>Access first element</td>
                        </tr>
                        <tr>
                            <td>get(last)</td>
                            <td>O(1)</td>
                            <td>O(1)</td>
                            <td>Access last element</td>
                        </tr>
                    </tbody>
                </table>

                <p>The table shows that LinkedList is typically more efficient than ArrayList unless the use case
                    requires access by index. To choose between List implementations, you must compare the use cases
                    that require accessing an element by index against the ones that require adding or removing elements
                    from the head of the list. If indexing is more common, use an ArrayList. If adding or removing from
                    the head is more common, use a LinkedList.</p>

                <p>We typically use LinkedList when we will always handle items in list order:</p>
                <ul>
                    <li>List of orders to fulfill</li>
                    <li>List of customers to contact</li>
                    <li>Lists of successful and failed calls (almost always added, then printed, with no other access)
                    </li>
                    <li>List of books to be downloaded</li>
                    <li>List of categories (almost always printed together)</li>
                </ul>

                <p>We typically use ArrayList when we may access items arbitrarily or unpredictably, including when we
                    may sort them:</p>
                <ul>
                    <li>List of items in an order (usually small, customers sometimes want to access interior nodes)
                    </li>
                    <li>List of names to sort (sorting accesses items by index)</li>
                    <li>Instructions (often requires interrupting and starting over in the middle)</li>
                    <li>List of lines in a file (editing often accesses lines by index)</li>
                </ul>
            </div>

            <div class="content-box">
                <div class="video-container">
                    <iframe class="wistia_embed" title="Implementing a Linked List"
                        src="https://fast.wistia.net/embed/iframe/bt7hpvyp88" width="100%" height="360"
                        name="wistia_embed" allowfullscreen="allowfullscreen" allow="fullscreen"
                        loading="lazy"></iframe>
                </div>
                <h3>Video Content: Implementing a Linked List</h3>
                <p>This video walks through building a custom linked list implementation, demonstrating key operations
                    and design considerations.</p>
                <pre><code>// More complete linked list implementation
public class CustomLinkedList&lt;E&gt; {
    
    private static class Node&lt;E&gt; {
        E data;
        Node&lt;E&gt; next;
        
        Node(E data) {
            this.data = data;
            this.next = null;
        }
    }
    
    private Node&lt;E&gt; head;
    private Node&lt;E&gt; tail;
    private int size;
    
    public CustomLinkedList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    
    // Add to the end - with tail reference this is O(1)
    public void add(E element) {
        Node&lt;E&gt; newNode = new Node&lt;&gt;(element);
        
        if (head == null) {
            head = newNode;
            tail = newNode;
        } else {
            tail.next = newNode;
            tail = newNode;
        }
        
        size++;
    }
    
    // Add at specific index - O(n) in worst case
    public void add(int index, E element) {
        if (index &lt; 0 || index &gt; size) {
            throw new IndexOutOfBoundsException("Index: " + index);
        }
        
        if (index == 0) {
            addFirst(element);
            return;
        }
        
        if (index == size) {
            add(element);
            return;
        }
        
        Node&lt;E&gt; current = head;
        for (int i = 0; i &lt; index - 1; i++) {
            current = current.next;
        }
        
        Node&lt;E&gt; newNode = new Node&lt;&gt;(element);
        newNode.next = current.next;
        current.next = newNode;
        size++;
    }
    
    // Add to the beginning - O(1)
    public void addFirst(E element) {
        Node&lt;E&gt; newNode = new Node&lt;&gt;(element);
        
        if (head == null) {
            head = newNode;
            tail = newNode;
        } else {
            newNode.next = head;
            head = newNode;
        }
        
        size++;
    }
    
    // Get element at index - O(n)
    public E get(int index) {
        if (index &lt; 0 || index &gt;= size) {
            throw new IndexOutOfBoundsException("Index: " + index);
        }
        
        Node&lt;E&gt; current = head;
        for (int i = 0; i &lt; index; i++) {
            current = current.next;
        }
        
        return current.data;
    }
    
    // Remove first element - O(1)
    public E removeFirst() {
        if (head == null) {
            throw new NoSuchElementException();
        }
        
        E data = head.data;
        head = head.next;
        
        if (head == null) {
            tail = null;
        }
        
        size--;
        return data;
    }
}</code></pre>
                <p>This more comprehensive implementation demonstrates key linked list operations with time complexity
                    analysis. Note the use of tail reference to make adding to the end an O(1) operation. The code
                    includes methods for inserting elements at different positions, retrieving elements by index, and
                    removing elements, each with appropriate time complexity considerations.</p>

                <h3>Call Center Implementation Example</h3>
                <p>This section depicts the implementation of the Call Center from the previous reading. When a customer
                    contacts the Call Center, a separate system creates a "case" for the contact and stores the caller's
                    name, the phone number, the issue details, the time, and other information.</p>

                <p>Our Call Center only uses the ID of each case. A LinkedList uses an object reference as its data
                    element, so it could refer to a more complex class, but our implementation uses only the String case
                    ID to simplify our examination.</p>

                <h4>The Call Center Class</h4>
                <p>The CallCenter class uses the String case ID. CallCenter has one attribute, calls, which is a
                    LinkedList of Strings. We will discuss these Call Center use cases:</p>
                <ul>
                    <li>Main scenario: A new call gets put on hold and enters the line -> receiveCall()</li>
                    <li>Main scenario: The call at the head of the line gets assigned to an agent and removed ->
                        nextCall()</li>
                    <li>Rare scenario: Search for a call by case ID -> findCall()</li>
                    <li>Rare scenario: Handle a call by index -> getCallAt()</li>
                </ul>

                <h4>A Note on LinkedList Methods</h4>
                <p>Since LinkedList is frequently used when we expect to manipulate the ends of a list, it implements
                    methods from the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html"
                        target="_blank" rel="noopener noreferrer">Deque interface</a>. Deque (pronounced "deck") stands
                    for "Double Ended Queue", and defines readable names for these end-related methods. In particular,
                    addFirst(), addLast(), removeFirst(), and removeLast() provide intuitive alternatives for verbose
                    code like dishes.remove(dishes.size() - 1).</p>

                <p>We will not use the other Deque methods in ATA, but we encourage you to read the <a
                        href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank"
                        rel="noopener noreferrer">LinkedList JavaDoc</a> to explore them.</p>

                <p>CallCenter uses addLast() and removeFirst() instead of the List alternatives.</p>

                <pre><code>package com.amazon.ata.deploying.prework;

import java.util.LinkedList;

public class CallCenter {

    // The list of calls. We use a LinkedList for access to the
    // addLast() and removeFirst() methods, which aren't part of List.
    private final LinkedList&lt;String&gt; calls;

    /**
     * Constructor.
     */
    public CallCenter() {
        calls = new LinkedList&lt;&gt;();
    }

    /**
     * A call gets into line to get processed.
     * @param caseId - case ID assigned to this contact
     */
    public void receiveCall(String caseId) {
        calls.addLast(caseId);
    }

    /**
     * The call at the head of the line gets processed.
     * @return call at head of the line
     */
    public String nextCall() {
        return calls.removeFirst();
    }

    /**
     * Handle a call by index.
     * @param index - The desired index of the call to retrieve from the LinkedList
     * @return - The case ID of the call at the index (the data element) 
     */
    public String getCallAt(int index) {
        return calls.get(index);
    }

    /**
     * Search the list and return the first call with a given case ID.
     * @param caseId - The ID of the case we're searching for
     * @return - The first call matching the case ID
     */
    public String findCall(String caseId) {
        for (String call : calls) {
            if (call.equals(caseId)) {
                return call;
            }
        }
        return null;
    }
}</code></pre>

                <h4>Adding a New Call as the Tail Node</h4>
                <p>When a customer calls into the Call Center, we need to add the call to the tail of the list. The
                    receiveCall() method calls the LinkedList method addLast() to add the new call to the tail of the
                    LinkedList. For example, when a call with case ID "A1" gets added to the back of an empty list, then
                    a call with case "B2" gets added to the back of the list, the list order will be ("A1", "B2") as
                    shown below. Adding the call "C3" to the back of the list results in order ("A1", "B2", "C3").</p>

                <img src="https://tk-assets.lambdaschool.com/70e74e75-7726-40e9-aab6-46b2745d1d2a_image1.png"
                    alt="Adding a new Tail node to the list. There are 3 nodes; the first is a node with data element  = &quot;A1&quot; and a pointer to the next node, the second node is the old tail node with data element  = &quot;B2&quot; and a pointer to the next node, and the third node is the new tail node with data element  = &quot;C3&quot; and a null pointer. The tail pointer has been updated to point at the new tail node. "
                    loading="lazy" style="max-width: 100%; height: auto; display: block; margin: 0 auto;">

                <p>Adding a new Tail node to the list. There are 3 nodes; the first is a node with data element = "A1"
                    and a pointer to the next node, the second node is the old tail node with data element = "B2" and a
                    pointer to the next node, and the third node is the new tail node with data element = "C3" and a
                    null pointer. The tail pointer has been updated to point at the new tail node.</p>

                <h4>Processing the Head Node Call</h4>
                <p>When an agent is available, nextCall() removes the head node and returns it. If calls included the
                    case IDs ("A1", "B2", "C3"), nextCall() would remove the case ID "A1" and return it, leaving calls
                    with the case IDs ("B2", "C3").</p>

                <img src="https://tk-assets.lambdaschool.com/63cd0d72-7853-43f2-87a5-c3d171e6c101_image2.png"
                    alt="Removing the Head node. There are 3 nodes; the first node with data element  = &quot;A1&quot; has been removed. The second node is the new head node with data element  = &quot;B2&quot; and a pointer to the next node, and the third node has data element  = &quot;C3&quot; and a pointer to the next node. The head pointer has been updated to point at the new head node. "
                    loading="lazy" style="max-width: 100%; height: auto; display: block; margin: 0 auto;">

                <p>Removing the Head node. There are 3 nodes; the first node with data element = "A1" has been removed.
                    The second node is the new head node with data element = "B2" and a pointer to the next node, and
                    the third node has data element = "C3" and a pointer to the next node. The head pointer has been
                    updated to point at the new head node.</p>

                <h4>Finding a Call by Case ID</h4>
                <p>We can use findCall() to search for a call with a given case ID. In the worst case, the call we're
                    looking for is at the end of the list or doesn't exist, and findCall() must go through the entire
                    list.</p>

                <h4>Handling a Call by Index</h4>
                <p>On the rare occasion when we want to retrieve a call by index, we use getCallAt(). Following the
                    example above, if calls included the case IDs ("A1", "B2", "C3"), then getCallAt(0) would return the
                    case ID "A1". Our code does not remove the call from the LinkedList.</p>

                <h4>Comparing LinkedList and ArrayList implementations for the Call Center</h4>
                <p>What happens to the time complexity if we had decided to use an ArrayList for calls instead of a
                    LinkedList? This table depicts the time complexity of the CallCenter methods for each
                    implementation:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>LinkedList</th>
                            <th>ArrayList</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>receiveCall()</td>
                            <td>O(1)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>nextCall()</td>
                            <td>O(1)</td>
                            <td>O(n)</td>
                        </tr>
                        <tr>
                            <td>findCall()</td>
                            <td>O(n)</td>
                            <td>O(n)</td>
                        </tr>
                        <tr>
                            <td>getCallAt()</td>
                            <td>O(n)</td>
                            <td>O(1)</td>
                        </tr>
                    </tbody>
                </table>

                <p>As discussed in the earlier reading, adding and removing from the ends favor the LinkedList, whereas
                    reading (but not adding or removing) interior nodes by index favors the ArrayList. Time complexity
                    becomes increasingly important with larger size lists.</p>

                <p>Consider what would happen in a Call Center that receives 500,000 calls each day. As calls arrive, we
                    invoke receiveCall(). With either a LinkedList or an ArrayList, this is an O(1) operation. As agents
                    became available, we invoke nextCall(). With a LinkedList, this would be an O(1) operation; with an
                    ArrayList, each call would be O(n), because we need to move all the other calls to a lower index.
                </p>

                <p>If we must invoke getCallAt(425000), the LinkedList implementation would traverse hundreds of
                    thousands of nodes before finding the correct index. The ArrayList would just return the indexed
                    call in O(1).</p>

                <p>Since the use cases indicate that we will invoke nextCall() much more often than getCallAt(), the
                    LinkedList is the most efficient choice.</p>
            </div>

            <div class="content-box">
                <h2>Guided Project</h2>
                <div class="video-container">
                    <iframe class="wistia_embed" title="Sprint 14 Linked Lists Video"
                        src="https://fast.wistia.net/embed/iframe/3km257ox0t" width="100%" height="360"
                        name="wistia_embed" allow="fullscreen" loading="lazy"></iframe>
                </div>
                <h3>Video Content: Sprint 14 Linked Lists Overview</h3>
                <p>This video provides a comprehensive overview of linked lists, summarizing key concepts,
                    implementations, and use cases covered in this module.</p>
                <pre><code>// Example: Choosing the right list implementation for the job
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

public class ListSelectionExample {
    
    // Queue/stack operations (add/remove at ends) - use LinkedList
    public static void queueOperationExample() {
        Deque&lt;String&gt; queue = new LinkedList&lt;&gt;();
        
        // Add to end (enqueue)
        queue.addLast("First");
        queue.addLast("Second");
        queue.addLast("Third");
        
        // Remove from front (dequeue)
        String first = queue.removeFirst();  // "First"
        String second = queue.removeFirst(); // "Second"
    }
    
    // Random access and modification - use ArrayList
    public static void randomAccessExample() {
        List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();
        
        // Fill with data
        for (int i = 0; i &lt; 1000; i++) {
            numbers.add(i);
        }
        
        // Fast random access
        int value = numbers.get(500);  // O(1) operation
        
        // Update value at specific index
        numbers.set(500, 9999);        // O(1) operation
    }
    
    // Frequent insertions/deletions in the middle - consider choices carefully
    public static void frequentModificationExample() {
        // If most operations are at the beginning/end
        LinkedList&lt;String&gt; linkedNames = new LinkedList&lt;&gt;();
        
        // If most operations are random access with occasional insertions
        ArrayList&lt;String&gt; arrayNames = new ArrayList&lt;&gt;();
        
        // LinkedList is better when you have a reference to the node
        // and can directly insert/remove without traversal
        // But often ArrayList is still faster overall due to cache locality
        // and lower overhead, unless insertions/deletions dominate
    }
}</code></pre>
                <p>This code demonstrates practical scenarios for choosing between LinkedList and ArrayList. LinkedList
                    is optimal for queue/stack operations (adding/removing at ends) and for frequent insertions in the
                    middle when you already have a reference to the position. ArrayList excels with random access and
                    performs better overall in many scenarios due to memory locality and lower overhead per element.</p>

                <div class="resource-links">
                    <a href="https://github.com/BloomTechBackend/bd-linked-lists-arraylist-vs-linked-list-showdown"
                        target="_blank" rel="noopener noreferrer" class="resource-link">
                        Array List Showdown
                    </a>
                </div>
            </div>

            <div class="content-box">
                <h2>Mastery Task 4: Without Music, Life Would B-flat</h2>

                <h3>Milestone 1: Implement AddSongToPlaylistActivity</h3>
                <p>We're able to Create, Get, and Update playlists, but they're not very useful without being able to
                    add songs! Let's fix that by implementing the AddSongToPlaylist API. Review the "Music Playlist
                    Service API Implementation Notes" section of the design document for requirements.</p>

                <p><strong>NOTE:</strong> For this task, you don't need to support the queueNext option. We will do that
                    in a future task. We will implement your base API first for this task and add more features later.
                    In the next milestone, we'll do the same thing with the GetPlaylistSongs endpoint.</p>

                <p>Our AlbumTrack java model is empty. We'll need to add the fields matching the data model and stored
                    data in the album_tracks table in your account. Make sure to include annotations to mark the
                    partition key and sort key.</p>

                <p>Notice some attributes in the table are not camelCase, such as track_number. However, we can use the
                    attributeName property of the @DynamoDBAttribute annotation to explicitly set the attribute name.
                </p>

                <p>When the Java model is ready, implement a getAlbumTrack method in AlbumTrackDao that uses the
                    DynamoDBMapper to load an item from the album_tracks table. Add tests for AlbumTrackDao as
                    appropriate.</p>

                <p>As with PlaylistModel for previous APIs, we must convert our AlbumTrack data model to the API-defined
                    SongModel. With the updated AlbumTrack class, create a toSongModel method in ModelConverter to map
                    the new fields from the AlbumTrack object to the SongModel object. Update ModelConverterTest as
                    appropriate.</p>

                <p>Once done, we can implement AddSongToPlaylistActivity's handleRequest method to fetch the album
                    information and add it to the Playlist's songList, save the updated Playlist and return the updated
                    song list from the API. Update the Activity to use the ModelConverter to convert the AlbumTrack's to
                    SongModel's as needed. Make the change, and then uncomment and run the AddSongToPlaylistActivityTest
                    unit tests.</p>

                <p>Since we're only partially implementing the AddSongToPlaylistActivity class in this sprint, you only
                    need the following tests to pass to complete this Mastery Task:</p>
                <ul>
                    <li>handleRequest_validRequest_addsSongToEndOfPlaylist</li>
                    <li>handleRequest_noMatchingPlaylistId_throwsPlaylistNotFoundException</li>
                    <li>handleRequest_noMatchingAlbumTrack_throwsAlbumTrackNotFoundException</li>
                </ul>

                <p>Once your tests pass, upload your code to Lambda and ensure it works.</p>

                <h3>Milestone 2: Implement GetPlaylistSongsActivity</h3>
                <p>Next, let's implement GetPlaylistSongsActivity's handleRequest method to return the song list, along
                    with unit tests as needed. Review the "Music Playlist Service API Implementation Notes" section of
                    the design document for requirements.</p>

                <p>No need to support the order field in the GetPlaylistSongsRequest yet, as you will implement that in
                    a later task. For now, we'll only be able to return songs in the default playlist order. This API
                    only needs to load the Playlist from the playlists table and return the Playlist's song list.</p>

                <p>To return the result of this activity, we'll have to convert the AlbumTrack's to our API defined
                    SongModel class and add them in a list in the GetPlaylistSongsResult.</p>

                <p>Since we're only partially implementing the GetPlaylistSongsActivity class in this sprint, you only
                    need the following tests to pass to complete this Mastery Task:</p>
                <ul>
                    <li>handleRequest_playlistExistsWithSongs_returnsSongsInPlaylist</li>
                    <li>handleRequest_playlistExistsWithoutSongs_returnsEmptyList</li>
                    <li>handleRequest_noMatchingPlaylistId_throwsPlaylistNotFoundException</li>
                </ul>

                <h3>Doneness Checklist</h3>
                <ul>
                    <li>You've implemented AddSongToPlaylist's functionality</li>
                    <li>You've implemented GetPlaylistSongs functionality</li>
                    <li>AddSongsToPlaylistActivityTest tests pass</li>
                    <li>GetPlaylistSongsActivityTest tests pass</li>
                    <li>Both of your Lambda functions are working on AWS</li>
                </ul>
            </div>

            <section class="resource-section">
                <h2 class="resource-section-title">Resources</h2>
                <div class="resource-links">
                    <a href="https://github.com/BloomTechBackend/bd-linked-lists-arraylist-vs-linked-list-showdown"
                        target="_blank" rel="noopener noreferrer" class="resource-link">
                        ArrayList vs LinkedList Showdown Guided Project
                    </a>
                    <a href="https://www.baeldung.com/java-linkedlist" target="_blank" rel="noopener noreferrer"
                        class="resource-link">
                        Guide to LinkedList in Java - Baeldung
                    </a>
                    <a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank"
                        rel="noopener noreferrer" class="resource-link">
                        Java LinkedList Documentation
                    </a>
                </div>
            </section>
        </section>
    </main>
</body>

</html>