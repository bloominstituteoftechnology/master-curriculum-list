<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 4: Inheritance and Polymorphism II - BD Unit 3 Sprint 9</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
</head>
<body>
    <header>
        <nav>
            <div class="logo">BD Unit 3 Sprint 9</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module1/index.html">Module 1: Remote Debugging</a>
                        <a href="../module2/index.html">Module 2: Inheritance and Polymorphism I</a>
                        <a href="../module3/index.html">Module 3: Hashing</a>
                        <a href="../module4/index.html" class="active">Module 4: Inheritance and Polymorphism II</a>
                    </div>
                </li>
                <li><a href="../../code-alongs/index.html">Code-Alongs</a></li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            <h1>Module 4: Inheritance and Polymorphism II</h1>
            
            <div class="content-box">
                <h2>Module Overview</h2>
                <p>Learn Overriding and Extending Behavior for Java applications.</p>
            </div>
            
            <div class="video-container">
                <iframe class="wistia_embed" title="Overriding and Extending Behavior Video" src="https://fast.wistia.net/embed/iframe/ctjl72w8yc" width="100%" height="360" name="wistia_embed" allow="autoplay; fullscreen" loading="lazy"></iframe>
            </div>

            <div class="content-box">
                <h2>Overriding and Extending Behavior</h2>
                <p>In previous sections, we took a look at how different Container subclasses calculate their volume differently, and, as such, each subclass overrode Container's base volume implementation.</p>
                <p>However, it's also possible to extend a superclass's method's behavior in a subclass. Here, we'll take a look at <code>super</code> in more detail.</p>

                <h3>Reference and Instance Types</h3>
                <p>Before we can dive deeper into <code>super</code>, let's recall from polymorphism that we can refer to an object by its superclass. For example, you can refer to a <code>Cylinder</code> which <em>is-a</em> <code>Container</code> as a <code>Container</code>:</p>
                <pre><code>Container cylinder = new Cylinder("beer", 8, 10);</code></pre>
                <p>In this way, the object <code>cylinder</code> can have two types: an implementing type and a reference type.</p>
                <p>The type on the left of the assignment operator, the reference type, defines what can be called on an object. Only the reference type's, i.e. <code>Container</code>'s, methods can be called.</p>
                <p>The type on the right side of the assignment operator, the implementing type, defines how those methods work.</p>
                <p>Repeat this mantra - Left, what. Right, how.</p>

                <h3>Container Recap</h3>
                <p>Let's take another look at our <code>Container</code> class, this time with some added functionality.</p>
                <pre><code>/**
* Container class to serve as a super class for different containers.
*/
public class Container {
    private String contents;

    /**
    * Creates a Container with the given contents.
    *
    * @param contents the contents of this container.
    * @throws IllegalArgumentException if contents is null.
    */
    public Container(String contents) {
        if (contents != null) {
            this.contents = contents;
        } else {
            throw new IllegalArgumentException(
                "Containers must have some contents.");
        }
    }

    /**
    * Calculates and returns the volume of this container;
    * defaults to zero.
    *
    * @return the volume of this container.
    */
    public double volume() {
        return 0.0;
    }

    /**
    * Returns how to open this container. 
    * Defaults to "Puncture"
    *
    * @return directions for opening this container.
    */
    public String openingInstructions() {
        return "Puncture";
    }

    /**
    * Returns a description of how the containers are grouped for sale.
    * Defaults to "Individually"
    *
    * @return a description of how the containers are grouped for sale.
    */
    public String grouping() {
        // most containers can be sold individually
        return "Individually";
    }

    /**
    * Builds and returns a string representation of this container.
    *
    * @return a string representation of this container.
    */
    public String toString() {
        return String.format("%s with %.2f units of %s. /nOpening Instructions: %s. /nSold: %s.",
        this.getClass().getSimpleName(), this.volume(), this.contents, this.openingInstructions(), this.grouping());
    }
}</code></pre>
                <p>All <code>Container</code>s have a <code>contents</code> field that must be non-empty (enforced by <code>Container</code>'s constructor.) We also already know that all <code>Container</code>s can calculate their volume calculated via the <code>volume</code> method.</p>
                <p>We've added the following behaviors: all <code>Container</code>s can be opened, and all <code>Container</code>s can be grouped for sale. Finally, all <code>Container</code>s describe themselves with the <code>toString</code> method.</p>
                <p>Below is a code segment demonstrating the <code>Container</code> class:</p>
                <pre><code>Container container = new Container("Milk");
System.out.println(container);</code></pre>
                <p>The output of the above code shows how a <code>Container</code> describes itself:</p>
                <pre><code>"Container with 0.00 units of Milk.
Opening Instructions: Puncture.
Sold: Individually."</code></pre>
                <p>The following classes build upon the <code>Container</code> class by extending it and adding their unique behaviors.</p>

                <h3>Overriding</h3>
                <p>We've already covered Overriding in previous readings, but let's run through another example of overriding methods here.</p>
                <p>A <code>Cylinder</code> is a <code>Container</code> that can only be sold in six-packs and is opened via a pop-tab:</p>
                <pre><code>/**
* Cylinder shaped Container subclass.
*/
public class Cylinder extends Container {
    private double radius;
    private double height;

    /**
    * Creates a Cylinder with the given contents and dimensions.
    *
    * @param contents the contents of this cylinder.
    * @param radius the radius of this cylinder.
    * @param height the height of this cylinder.
    */
    public Cylinder(String contents, double radius, double height) {
        super(contents);
        this.radius = radius;
        this.height = height;
    }

    /**
    * Calculates and returns the volume of this cylinder.
    *
    * @return the volume of this cylinder.
    */
    @Override
    public double volume() {
        return Math.PI * Math.pow(this.radius, 2) * this.height;
    }

    /**
    * Returns how to open this container. 
    *
    * @return directions for opening this container.
    */
    @Override
    public String openingInstructions() {
        return "Pull on the pop-tab";
    }

    /**
    * Returns a description of how the containers are grouped for sale.
    *
    * @return a description of how the containers are grouped for sale.
    */
    @Override
    public String grouping() {
        return "In six-packs";
    }
}</code></pre>
                <p>Let's create a new <code>Cylinder</code> and call its <code>toString</code> method.</p>
                <pre><code>Container cylinder = new Cylinder("beer", 8, 10);
System.out.println(cylinder.toString());</code></pre>
                <p>The above code would output:</p>
                <pre><code>Cylinder with 2010.62 units of beer
Opening Instructions: Pull on the pop-tab.
Sold: In six-packs.</code></pre>
                <p>Let's trace what methods are called against <code>cylinder</code> when we call <code>cylinder.toString()</code>:</p>
                <ul>
                    <li>The first method called is <code>toString</code>. Because <code>Cylinder</code> does not override the <code>toString</code> method, the JVM uses the implementation from <code>Container</code>.</li>
                    <li>Within <code>toString</code>, the next method called is <code>this.getClass()</code>, which returns the instance type of our Object. In this case, the instance type is <code>Cylinder</code>. We then call <code>getSimpleName()</code> on the <code>Cylinder</code> class, which returns the string "Cylinder".</li>
                    <li>The next method called is <code>this.volume()</code>. Because <code>Cylinder</code> overrides the <code>volume</code> method, the JVM uses the implementation of <code>volume</code> from <code>Cylinder</code>.</li>
                    <li>The next method called is <code>this.openingInstructions()</code>. Because <code>Cylinder</code> overrides the <code>openingInstructions</code> method, the JVM uses <code>Cylinder</code>'s implementation of <code>openingInstructions</code>.</li>
                    <li>The next method called is <code>this.grouping()</code>. Because <code>Cylinder</code> overrides the <code>grouping</code> method, the JVM uses <code>Cylinder</code>'s implementation of <code>grouping</code>.</li>
                </ul>
                <p>Note that every time we call a method, an implementation of that method is first looked for on the instance type. The instance type is the actual type of the object on the heap. It's defined on the right-hand side of the assignment operator (<code>=</code>). If that class doesn't implement the requested method, like the example of <code>toString()</code>, we move up the inheritance chain for that method's implementation.</p>

                <h3>Extending using <code>super()</code></h3>
                <p>A <code>Box</code> <em>is-a</em> <code>Container</code>. It is opened by using a provided spout. It can be sold individually or in pairs.</p>
                <pre><code>/**
* Box shaped Container subclass.
*/
public class Box extends Container {
    private double width;
    private double height;
    private double depth;

    /**
    * Creates a Box with the given contents and dimensions.
    *
    * @param contents the contents of this box.
    * @param width the width of this box.
    * @param height the height of this box.
    * @param depth the depth of this box.
    */
    public Box(String contents, double width, double height, double depth) {
        super(contents);
        this.width = width;
        this.height = height;
        this.depth = depth;
    }

    /**
    * Calculates and returns the volume of this box.
    *
    * @return the volume of this box.
    */
    @Override
    public double volume() {
        return this.width * this.height * this.depth;
    }

    /**
    * Returns how to open this container. 
    *
    * @return directions for opening this container.
    */
    @Override
    public String openingInstructions() {
        return "Attach the provided spout";
    }

    /**
    * Returns a description of how the containers are grouped for sale.
    *
    * @return a description of how the containers are grouped for sale.
    */
    @Override
    public String grouping() {
        // most containers can be sold individually
        return super.grouping() + " and in pairs.";
    }
}</code></pre>
                <p>Let's create a new <code>Box</code> and call it's <code>toString</code> method:</p>
                <pre><code>Container box = new Box("wine", 13, 14, 15);
System.out.println(box.toString());</code></pre>
                <p>The output from this code block would be:</p>
                <pre><code>Box with 2730.00 units of wine.
Opening Instructions: Attach the provided spout.
Sold: Individually and in pairs.</code></pre>
                <p>Let's trace what methods are called against <code>box</code> when we call <code>box.toString()</code>:</p>
                <ul>
                    <li>The first method called is <code>toString</code>. Because <code>Box</code> does not override the <code>toString</code> method, the JVM uses the implementation from <code>Container</code>.</li>
                    <li>Within <code>toString</code>, the next method called is <code>this.getClass()</code>, which returns the instance type of our Object. In this case, the instance type is <code>Box</code>. We then call <code>getSimpleName()</code> on the <code>Box</code> class, which returns the string "Box".</li>
                    <li>The next method called is <code>this.volume()</code>. Because <code>Box</code> overrides the <code>volume</code> method, the JVM uses the implementation of <code>volume</code> from <code>Box</code>.</li>
                    <li>The next method called is <code>this.openingInstructions()</code>. Because <code>Box</code> overrides the <code>openingInstructions</code> method, the JVM uses <code>Box</code>'s implementation of <code>openingInstructions</code>.</li>
                    <li>The next method called is <code>this.grouping()</code>. Because <code>Box</code> overrides the <code>grouping</code> method, the JVM uses <code>Box</code>'s implementation of <code>grouping</code>.</li>
                    <li>Within <code>Box</code>'s implementation of <code>grouping</code>, <code>super.grouping()</code> is called. The JVM calls the <code>grouping</code> method implemented by <code>Box</code>'s superclass, <code>Container</code>.</li>
                </ul>
                <p>Note that the <code>grouping</code> method in the <code>Box</code> class calls <code>super.grouping()</code> so it can add additional ways to be grouped for sale, rather than completely replacing the superclass grouping. This is a convenient thing to be able to do as the alternative would be to repeat code already written in the <code>Container</code> class and repeating identical code is generally best avoided.</p>

                <h3>Subclass trees</h3>
                <p>Note that a class can be a subclass of a class that is, in turn, a subclass of a different superclass.</p>
                <p>In this example, a <code>RecyclableBox</code> <em>is-a</em> <code>Box</code>, which <em>is-a</em> <code>Container</code>. It acts as a box, but it is recyclable after use:</p>
                <pre><code>/**
* Recyclable Box subclass.
*/
public class RecyclableBox extends Box {
    /**
    * Creates a RecyclableBox with the given contents and dimensions.
    *
    * @param contents the contents of this box.
    * @param width the width of this box.
    * @param height the height of this box.
    * @param depth the depth of this box.
    */
    public RecyclableBox(String contents, double width, double height, double depth) {
        super(contents, width, height, depth);
    }

    /**
    * Returns how to open this container. 
    *
    * @return directions for opening this container.
    */
    @Override
    public String openingInstructions() {
        return super.openingInstructions() + ". Recycle after use";
    }
}</code></pre>
                <p>Let's create a new <code>RecyclableBox</code> and call it's <code>toString</code> method:</p>
                <pre><code>Container recyclableBox = new RecyclableBox("wine", 13, 14, 15);
System.out.println(recyclableBox.toString());</code></pre>
                <p>The output from this code block would be:</p>
                <pre><code>RecyclableBox with 2730.00 units of wine.
Opening Instructions: Attach the provided spout. Recycle after use.
Sold: Individually and in pairs.</code></pre>
                <p>Since a <code>RecyclableBox</code> <em>is-a</em> <code>Box</code> and a <code>Box</code> <em>is-a</em> <code>Container</code>, it is also safe to say a <code>RecyclableBox</code> <em>is-a</em> <code>Container</code>. Also, again notice the use of <code>super.openingInstructions()</code>, which allows the <code>RecyclableBox</code> to add to the superclass (<code>Box</code>) behavior. Note that we don't need to re-write <code>grouping</code> or <code>volume</code> methods for <code>RecyclableBox</code>. Because <code>Box</code> is the superclass of <code>RecyclableBox</code>, <code>Box</code>'s implementations of those methods will be used by default.</p>
                <p>Let's trace what methods are called against <code>recyclableBox</code> when we call <code>recyclableBox.toString()</code>:</p>
                <ul>
                    <li>The first method called is <code>toString</code>. Because both <code>RecyclableBox</code> and <code>Box</code> do not override the <code>toString</code> method, the JVM uses the implementation from <code>Container</code>.</li>
                    <li>Within <code>toString</code>, the next method called is <code>this.getClass()</code>, which returns the instance type of our Object. In this case, the instance type is <code>RecyclableBox</code>. We then call <code>getSimpleName()</code> on the <code>RecyclableBox</code> class, which returns the string "RecyclableBox".</li>
                    <li>The next method called is <code>this.volume()</code>. <code>RecyclableBox</code> does not override the <code>volume</code> method, but <code>Box</code> does. As such, the JVM uses the implementation of <code>volume</code> from <code>Box</code>.</li>
                    <li>The next method called is <code>this.openingInstructions()</code>. Because <code>RecyclableBox</code> overrides the <code>openingInstructions</code> method, the JVM uses <code>RecyclableBox</code>'s implementation of <code>openingInstructions</code>.</li>
                    <li>Within <code>RecyclableBox</code>'s implementation of <code>openingInstructions</code>, <code>super.openingInstructions()</code> is called. The JVM calls the <code>openingInstructions</code> method implemented by <code>RecyclableBox</code>'s superclass, <code>Box</code>.</li>
                    <li>The next method called is <code>this.grouping()</code>. <code>RecyclableBox</code> does not override the <code>grouping</code> method, but <code>Box</code> does. Because of this, the JVM uses <code>Box</code>'s implementation of <code>grouping</code>.</li>
                    <li>Within <code>Box</code>'s implementation of <code>grouping</code>, <code>super.grouping()</code> is called. The JVM calls the <code>grouping</code> method implemented by <code>Box</code>'s superclass, <code>Container</code>.</li>
                </ul>
                <p>Note that, when we call the method, if that class doesn't implement the requested method, we move up the inheritance chain for that method's implementation and do so one class at a time. Take, for example, <code>toString</code>. Since <code>RecyclableBox</code> doesn't implement that method, the JVM next checks against its parent class, <code>Box</code>. Since <code>Box</code> doesn't implement <code>toString</code>, the JVM checks its parent class <code>Container</code> for an implementation of <code>toString</code>, which is found and used.</p>
                <p>Similarly, in the case of <code>volume</code>, <code>RecyclableBox</code> doesn't implement it, so the JVM checks its parent, <code>Box</code>. In this case, <code>Box</code> does implement <code>volume</code>, so the JVM will use <code>Box</code>'s implementation of <code>volume</code>. The JVM does not need to travel any higher up the inheritance chain to find an implementation for <code>volume</code>.</p>

                <h3>More <code>super</code> traversals</h3>
                <p>Similarly, when <code>super</code> is called, the JVM will travel up the inheritance chain, one class at a time, to find an implementation of the method by a superclass. In our previous cases, <code>super</code> always called the method of the immediate superclass, but that doesn't need to be the case. Let's take a look at a couple more implementations of <code>Container</code> to explore this concept.</p>
                <p><code>Sphere</code> is a <code>Container</code>, and in turn, has a subclass, <code>CappedSphere</code>. <code>CappedSphere</code> <em>is-a</em> <code>Sphere</code>, so it also <em>is-a</em> <code>Container</code>:</p>
                <pre><code>/**
* Sphere shaped Container subclass.
*/
public class Sphere extends Container {
    private double radius;

    /**
    * Creates a Sphere with the given contents and dimensions.
    *
    * @param contents the contents of this sphere.
    * @param radius the radius of this sphere.
    */
    public Sphere(String contents, double radius) {
        super(contents);
        this.radius = radius;
    }

    /**
    * Calculates and returns the volume of this sphere.
    *
    * @return the volume of this sphere.
    */
    @Override
    public double volume() {
        return 4.0 / 3.0 * Math.PI * Math.pow(this.radius, 3);
    }
}</code></pre>
                <p><code>CappedSphere</code> is a <code>Sphere</code> with a twist-off cap:</p>
                <pre><code>/**
* Capped Sphere subclass.
*/
public class CappedSphere extends Sphere {
    /**
    * Creates a CappedSphere with the given contents and dimensions.
    *
    * @param contents the contents of this sphere.
    * @param radius the radius of this sphere.
    */
    public CappedSphere(String contents, double radius) {
        super(contents, radius);
    }

    /**
    * Returns how to open this container. 
    *
    * @return directions for opening this container.
    */
    @Override
    public String openingInstructions() {
        return "Twist off the cap";
    }
}</code></pre>
                <p>Let's see what happens if we create one <code>Container</code>, one <code>Sphere</code>, and one <code>CappedSphere</code>, and take a look at printing <code>toString</code> for each:</p>
                <pre><code>List&lt;Container&gt; containers = new ArrayList&lt;&gt;();
containers.add(new Container("water"));
containers.add(new Sphere("milk", 8));
containers.add(new CappedSphere("juice", 8));
for (Container container : containers) {
    System.out.println(container);
}</code></pre>
                <p>The above code will print the following:</p>
                <pre><code>Container with 0.00 units of water.
Opening Instructions: Puncture.
Sold: Individually.
Sphere with 2144.66 units of milk.
Opening Instructions: Puncture.
Sold: Individually. 
CappedSphere with 2144.66 units of juice.
Opening Instructions: Twist off the cap.
Sold: Individually.</code></pre>
                <p>Read through this output carefully, trace each bit of output to the methods that produced it, ensuring you understand the trail of method calls. One of the more interesting tidbits is <code>Sphere</code> extends <code>Container</code> but does not override the <code>openingInstructions</code> method, yet <code>CappedSphere</code> extends <code>Sphere</code> and does override the <code>openingInstructions</code> method. In a multi-layer inheritance hierarchy, a method inherited from several levels above can still be overridden in a subclass.</p>

                <h3>Summary</h3>
                <p>We have now seen how the design principles of encapsulation, inheritance, and polymorphism work together to create safe and adaptable software. There are other helpful design strategies used in object-oriented programming. In particular, implementing an interface in Java is closely related to the <em>is-a</em> relationship of inheritance. We will discuss this in more detail in the next reading in this lesson. Also, a design technique called composition establishes a <em>has-a</em> relationship, which is sometimes more appropriate than the <em>is-a</em> relationship. This will be the topic of a future lesson.</p>
            </div>

            <div class="content-box">
                <h2>Implementing equals() and hashCode() with Inheritance</h2>
                <p>We've covered how to implement <code>equals()</code> and <code>hashCode()</code>, and we've covered how to use inheritance, so now let's walk through how to implement <code>equals()</code> and <code>hashCode()</code> with inheritance!</p>
                <p>Our example for today: we want to create spray-on packaging for items of different shapes and sizes. We've developed a <code>SprayableShape</code> base class that contains information on what type of spray to use and defines a method for getting the sprayable area. We also have two subclasses developed, <code>Circle</code> and <code>Rectangle</code>.</p>
                <pre><code class="language-java">enum Spray {
   BLUE_GLOSS,
   RED_MATTE
}

public class SprayableShape {
   private Spray spray;
   
   public SprayableShape(Spray spray) {
        this.spray = spray;
   }
   
   // The base `SprayableShape` has a surface area of 0
   public double getSprayableArea() {
        return 0;
   }
}

public class Circle extends SprayableShape {
   private double radius;
   
   public Circle(Spray spray, double radius) {
        super(spray);
        this.radius = radius;
   }
   
   @Override
   public double getSprayableArea() {
        // We previously wrote some implementation here
   }
}

public class Rectangle extends SprayableShape {
   private double length;
   private double width;
   
   public Rectangle(Spray spray, double length, double width) {
        super(spray);
        this.length = length;
        this.width = width;
   }
   
   @Override
   public double getSprayableArea() {
        // We previously wrote some implementation here
   }
}</code></pre>
                <p>We were able to write code to get the sprayable area of each different shape, but now we want to optimize our system and group the shapes by the <code>Spray</code> type and the dimension so that we can create separate spray-on packaging assembly lines to avoid reconfiguring the machines for each item.</p>
                <p><em>Example diagram showing each spray-on packaging assembly line, grouped by the spray type and the shape's dimensions, so that the machines don't need to be reconfigured for each item that comes on the line.</em></p>
                <p>To do this, we need to check for equality and override <code>Object::equals()</code>, as well as <code>hashCode()</code> as we learned that these two methods are linked.</p>
                <p>Recall from inheritance that the code using our <code>SprayableShape</code> objects can refer to any <code>SprayableShape</code> instance, and Java will call the instance's <code>equals()</code> method. If the instance doesn't override <code>equals()</code>, Java will check its superclass, then its superclass, and continue up the chain until it finds a superclass that implements <code>equals()</code>. Since <code>Object</code> is a superclass of every class, we're guaranteed to find <code>equals()</code> there even if it's not implemented anywhere else.</p>
                <p>Unfortunately, <code>Object::equals()</code> isn't smart enough to check classes or attributes; it only returns true when the references (locations in memory) being compared refer to the same instance.</p>
                <p>Every time we override <code>equals</code>, we want to make sure we are writing code to check for the following:</p>
                <ul>
                    <li>Is the passed-in object null? Since we're in an instance of the class, we know we aren't null, and can't possibly be equal to null. Return false.</li>
                    <li>Is the passed-in object the exact same object? If our reference is pointing to the same object in memory, then the attributes must be equal. Return true.</li>
                    <li>Is the passed-in object a different type? Then we don't have the same set of attributes to compare. Return false.</li>
                    <li>Finally, implement the checks for equality between attributes that make the two objects equal.</li>
                </ul>
                <p>For the <code>SprayableShape</code> base class, the only property we have is the <code>Spray</code> type, so that's all we will check in the <code>equals()</code> method and the <code>hashCode()</code> method.</p>
                <pre><code class="language-java">public class SprayableShape {
   ...
   
   @Override
   public boolean equals(Object o) {
        // An object can't be equal to null.
        if (o == null) {
            return false;
        }

        // If two objects have the same reference, they should be equal.
        if (this == o) {
            return true;
        }
        
        // If the objects are of different types, they shouldn't be equal. 
        if (getClass() != o.getClass()) {
            return false;
        }
            
        SprayableShape that = (SprayableShape) o;
        
        // Finally, implement the checks for equality between attributes that make the two objects equal.
        return spray == that.spray;
   }

   @Override
   public int hashCode() {
        // Use the same properties that make the objects equal to compute a hashCode.
        return Objects.hash(spray);
   }
}</code></pre>
                <p>Let's break down this example.</p>
                <p>This example uses <code>getClass()</code> to check if the object we are comparing to has precisely the same class as our object. <code>getClass()</code> is another method that every object provides. It returns the instance type of the object, the actual type of the object on the heap. Because we compare classes, a subclass can never be equivalent to one of its superclasses. In our example, no <code>Circle</code> can ever be equal to a <code>SprayableShape</code>.</p>
                <p>Instead of using <code>getClass()</code>, you may see people implementing <code>equals</code> using a keyword <code>instanceof</code>:</p>
                <pre><code class="language-java">if (!(obj instanceof SprayableShape)) {
    return false;
}</code></pre>
                <p>We do not recommend using it. <code>instanceof</code> checks if the object is that particular type or a sub-type. So in this snippet, <code>instanceof</code> will return true if <code>obj</code> is an instance of <code>SprayableShape</code> or an instance of any of <code>SprayableShape</code>'s subclasses. This means that an object that is a <code>SprayableShape</code>, <code>Circle</code>, or a <code>Rectangle</code> would all be considered an <code>instanceof SprayableShape</code>, as we established that <code>Circle</code> <em>is-a</em> <code>SprayableShape</code> and <code>Rectangle</code> <em>is-a</em> <code>SprayableShape</code> through inheritance.</p>
                <p>This can cause some weird problems. Check out what happens if we call <code>equals()</code> on the same two objects in a different order:</p>
                <pre><code class="language-java">SprayableShape baseShape = new SprayableShape(Spray.RED_MATTE);
SprayableShape circle = new Circle(Spray.RED_MATTE, 1.25);

// This returns true -- Circle is an instanceof SprayableShape, and they both use RED_MATTE spray.
assertTrue(baseShape.equals(circle));
// This returns false -- SprayableShape is NOT an instanceof Circle, and it doesn't even have a radius.
assertFalse(circle.equals(baseShape));</code></pre>
                <p>By allowing the subclasses to use the superclasses <code>equals()</code> method, we now get inconsistent results. To prevent this, use the <code>getClass()</code> check to make sure we only ever compare two objects of the same type.</p>
                <p>Now for <code>Circle</code> and <code>Rectangle</code>, we have the dimensional properties available to us, which we want to check to avoid reconfiguring our machines frequently. However, we also want to check the <code>Spray</code> type that's stored in the superclass. Since our superclass <code>SprayableShape</code> implements <code>equals()</code> and <code>hashCode()</code> now, we need to reuse that code when implementing <code>equals()</code> and <code>hashCode()</code> in the subclasses, to make sure that those superclass properties are also equal. IntelliJ's auto-generate feature will take care of that for you automatically.</p>
                <pre><code class="language-java">public class Circle {
   ...
   
   @Override
   public boolean equals(Object o) {
        // An object can't be equal to null.
        if (o == null) {
            return false;
        }

        // If two objects have the same reference, they should be equal.
        if (this == o) {
            return true;
        }
        
        // If the objects are of different types, they shouldn't be equal. 
        if (getClass() != o.getClass()) {
            return false;
        }
        
        // Something new! Check that our superclass properties are also equal.
        if (!super.equals(o)) { 
            return false;
        }
        
        // Check that the properties of this class are equal.
        Circle circle = (Circle) o;
        return Double.compare(circle.radius, radius) == 0;
    }

   @Override
   public int hashCode() {
        // Take into account superclass properties in addition to our own class properties.
        return Objects.hash(super.hashCode(), radius);
   }
}</code></pre>
                <p>Our superclass <code>SprayableShape</code> implements <code>equals()</code> and <code>hashCode()</code>, which means we have to add those calls to <code>super.equals()</code> and <code>super.hashCode()</code> in our subclass implementation.</p>
                <p>Check out what would happen if we didn't call <code>super.equals()</code> and <code>super.hashCode()</code> from the subclass implementation:</p>
                <pre><code class="language-java">Circle circle1 = new Circle(Spray.BLUE_GLOSS, 4.5);
Circle circle2 = new Circle(Spray.RED_MATTE, 4.5);

// The radiuses are equal, and that's all the subclass knows about, so it returns true
assertTrue(circle1.equals(circle2));

assertTrue(circle1.hashCode() == circle2.hashCode());</code></pre>
                <p>Now we might decide that we don't care about the superclass properties in's equality check. However, that might bring up the question of whether or not <code>Circle</code> really <em>is-a</em> <code>SprayableShape</code>, and indicate a problem with our inheritance hierarchy.</p>
            </div>

            <div class="content-box">
                <h2>Changing Superclasses</h2>
                <h3>Risky Inheritance</h3>
                <p>So far, we've covered the benefits of inheritance. It is often tempting to use inheritance to solve all your problems, but inheritance isn't always an appropriate approach to problems, as discussed in the last reading. Furthermore, using inheritance carries some risks, the most notable of which is the risk of change to your superclasses.</p>
                <p>Let's take a look at an example of this:</p>

                <h3>Oversized containers, oh my!</h3>
                <p>Let's revisit our Container class and its subclass, Box.</p>
                <pre><code class="language-java">
/**
* Container class to serve as a super class for different containers.
*/
public class Container {
    private String contents;

    /**
    * Creates a Container with the given contents.
    *
    * @param contents the contents of this container.
    * @throws IllegalArgumentException if contents is null.
    */
    public Container(String contents) {
        if (contents != null) {
            this.contents = contents;
        } else {
            throw new IllegalArgumentException(
                "Containers must have some contents.");
        }
    }

    /**
    * Calculates and returns the volume of this container;
    * defaults to zero.
    *
    * @return the volume of this container.
    */
    public double volume() {
        return 0.0;
    }
}
</code></pre>
                <pre><code class="language-java">
/**
* Box shaped Container subclass.
*/
public class Box extends Container {
    private double width;
    private double height;
    private double depth;

    /**
    * Creates a Box with the given contents and dimensions.
    *
    * @param contents the contents of this box.
    * @param width the width of this box.
    * @param height the height of this box.
    * @param depth the depth of this box.
    */
    public Box(String contents, double width, double height, double depth) {
        super(contents);
        this.width = width;
        this.height = height;
        this.depth = depth;
    }

    /**
    * Calculates and returns the volume of this box.
    *
    * @return the volume of this box.
    */
    @Override
    public double volume() {
        return this.width * this.height * this.depth;
    }

}
</code></pre>
                <p>In most cases, the way we've implemented these classes is acceptable, but every once in a while, we see a case where we get a negative volume! Diving deeper, we've realized that for overly large Boxs, the calculation for the volume goes above double's limit ((2^63) - 1), and as such, the result has rolled over to negative values!</p>
                <p>Luckily, we know that BigDecimal can help us store even larger values! So we update our Containers volume method to return a BigDecimal:</p>
                <pre><code class="language-java">
/**
* Container class to serve as a super class for different containers.
*/
public class Container {
    private String contents;

    /**
    * Creates a Container with the given contents.
    *
    * @param contents the contents of this container.
    * @throws IllegalArgumentException if contents is null.
    */
    public Container(String contents) {
        if (contents != null) {
            this.contents = contents;
        } else {
            throw new IllegalArgumentException(
                "Containers must have some contents.");
        }
    }

    /**
    * Calculates and returns the volume of this container;
    * defaults to zero.
    *
    * @return the volume of this container.
    */
    public BigDecimal volume() { // Corrected from Bigdecimal
        return BigDecimal.ZERO; // Corrected from 0.0
    }
}
</code></pre>
                <p>"Awesome!", we think. We save our changes and then try to build our package, and it fails to compile. 😦</p>

                <h3>What broke?</h3>
                <p>When we change a superclass, that change affects all of its subclasses (and their subclasses, and the subclasses of those subclasses, etc., down the inheritance chain).</p>
                <p>In this case, since we changed volume to return a BigDecimal in the Container superclass, the compiler expects the volume method of all classes that inherit from Container to also return BigDecimal.</p>
                <p>So, let's take a look at our class diagram for Container, Box, Cylinder, and Sphere from our earlier reading.</p>
                <p><img src="../../assets/images/module4_figure1_container_uml.png" alt="UML class diagram for the Container, Box, Cylinder, and Sphere classes."></p>
                <p>Figure 1</p>
                <p>Figure 1: UML class diagram for the Container, Box, Cylinder, and Sphere classes.</p>
                <p>From this diagram, we know that Box, Cylinder and Sphere have all overridden volume with their own implementations. Before our code can compile, we need to update the volume method of all these classes to return a BigDecimal. We'll also need to change our code wherever we rely on the result of volume to accept a BigDecimal rather than a double. While we're at it, we should change all of our double members within our Container classes to BigDecimal and use BigDecimals "safe" math operations, like we covered in the "Wrappers" lesson.</p>

                <h3>What else can break?</h3>
                <p>Whenever you change the signatures of public or protected methods of a superclass, you risk causing its consumers, its subclasses (through the entire inheritance chain), and consumers of its subclasses to fail to build. You run the same risk if you change the names or types of public or protected members of a superclass.</p>
                <p>While it typically won't cause builds to fail, it's essential also to recognize that changing the implementation of methods (private, protected, or private) of a superclass might not cause build failures but will still affect all subclasses that rely on those methods.</p>
                <p>Suppose you're modifying a superclass in any way. In that case, it's crucial to thoroughly investigate how it and its subclasses (through the inheritance chain) are used and implemented to avoid causing any undesired side effects.</p>

                <h3>What's the worst that can happen?</h3>
                <p>While the radius of the above fix isn't huge for our codebase as it is now, if we continued to expand with more Container subclasses, we would have a more significant number of places to update. If we exposed any of our Container classes publicly, then packages that depend on our classes will fail to build, too, causing a possible cascade of failures.</p>

                <h3>How do we fix it?</h3>
                <p>The best way to fix these kinds of issues is to nip them in design. Designing inheritance relationships often requires judgment calls as to the risk of needing to change your superclass and the intuitive hierarchy or your classes.</p>
                <p>For example, if we had a Rectangle class which implements Shape, and we wanted to add a Square class, should it extend Shape or Rectangle? Or should we refactor so Rectangle extends Square? How do we expect either of these solutions to impact calculating a shape's area? There's no one correct answer and lots of wrong answers. We must consider what makes for an intuitive class hierarchy, what can be reused, and what will likely need to be changed later.</p>
                <p>Following best practices from the start can also help reduce the need to make changes to your superclasses later. In this example, using "math-safe" operations and wrapper classes like BigDecimal from the start could have prevented the need for this change after that.</p>
                <p>Of course, if you really need to update a superclass, there are ways to do so safely, such as changing major package versions and deprecating previous major versions of your library. We won't cover such approaches in more detail in this lesson, as each development team has its own standards and processes regarding such changes.</p>
            </div>
            
            <div class="content-box">
                <h2>Guided Projects</h2>

                <div class="video-container">
                    <iframe src="https://fast.wistia.net/embed/iframe/xdu9mmc5vu" title="Module 4 Guided Projects Video Content" allowfullscreen></iframe>
                </div>

                <div class="resource-links">
                    <a href="https://github.com/BloomTechBackend/bd-playing-cards-with-relatives" target="_blank" rel="noopener" class="resource-link">
                        Playing Cards with Relatives
                    </a>
                </div>
            </div>

            <div class="content-box">
                <h2>Mastery Task 3: Time is Marching On</h2>
                <h3>Mastery Task Guidelines</h3>
                <p>Mastery Tasks are opportunities to test your knowledge and understanding through code. When a mastery task is shown in a module, it means that we've covered all the concepts that you need to complete that task. You will want to make sure you finish them by the end of the week to stay on track and complete the unit.</p>
                <p>Each mastery task must pass 100% of the automated tests and code styling checks to pass each unit. Your code must be your own. If you have any questions, feel free to reach out for support.</p>
                <p>This is the first Mastery Task in this Sprint associated with with the Sprint project. Be sure you have copied the Sprint Project code down to your local machine.</p>
                <p>Currently, our code only supports a single type of packaging corresponding to corrugate boxes. Amazon's packaging options have expanded to include polybags and may expand to even more types in the future. Your PM has warned your team that the first FC with polybags is going to onboard soon, and we need to prepare.</p>

                <h3>Milestone 1: Design</h3>
                <p>You should plan for at least two new packaging types: <strong>Box</strong> and <strong>PolyBag</strong>. We'd like to update our service to support these new and future packaging types without requiring changes to the <code>PackagingDao</code>, <code>FcPackagingOption</code>, or the <code>ShipmentService</code>. We can do this by extending from the <code>Packaging</code> class. We know that no other teams use our <code>types</code> Java package, so it's safe to change any of its classes. Both <code>Box</code> and <code>PolyBag</code> will need to implement the methods <code>canFitItem()</code> and <code>getMass()</code>, which are used to determine the best shipment option. Below are details about how to calculate each.</p>
                <p>A <strong>Box</strong> is made of <code>CORRUGATE</code>; has fixed length, width, and height (all measured in centimeters); and can fit any item that is smaller in each dimension. (The Amazon catalog standard ensures that each <code>Item</code> is measured with its shortest dimension in width and its longest in height. Boxes are measured the same way, so we can tell an item won't fit if any item dimension is larger than or equal to the same box dimension. Try it out until you're convinced!) A <code>Box</code> has a mass that is about 1 gram per square centimeter. We'll simplify the calculations by ignoring any overlapping flaps and only considering the exposed area, as represented by this pseudo-code:</p>
                <pre><code>endsArea = length * width * 2;
shortSidesArea = length * height * 2;
longSidesArea = width * height * 2;
mass = endsArea + shortSidesArea + longSidesArea;</code></pre>
                <p><strong>HINT:</strong> Remember that with <code>BigDecimal</code>s, we can't use <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code>, etc operators. Instead, we must use the class methods <code>add</code>, <code>multiply</code>, etc. Additionally, we can turn an integer into a <code>BigDecimal</code> using the static <code>valueOf</code> method.</p>
                <p>A <strong>PolyBag</strong> is made of <code>LAMINATED_PLASTIC</code>; has a fixed volume (in cubic centimeters); and can fit any <code>Item</code> whose volume (length * width * height) is smaller than the bag's volume. (The actual formula is quite complicated, but volume is a reasonable approximation in most cases.) Note that a polybag, therefore, should not have a length, width, or height property, so we'll need to remove the fields from the <code>Packaging</code> parent class and move them to the new <code>Box</code> class.</p>
                <p>A <strong>PolyBag</strong> has a mass that is a bit more complicated to derive. The Data Engineering team handed you this code, which they say gets "close enough":</p>
                <pre><code>mass = Math.ceil(Math.sqrt(volume) x 0.6);</code></pre>
                <p><strong>Note:</strong> <code>Math.sqrt()</code> doesn't support accepting a <code>BigDecimal</code>. We'll have to make an approximation using <code>double</code> values, and covert that back to <code>BigDecimal</code>. The Data Engineering team confirms that'll be sufficient.</p>
                <p>Create a new smaller, focused class diagram with the changes you plan to make for this task. The diagram should include the changes you plan to make to the <code>types</code> package. This should include any classes you change or add, and any relationships between them. Create a new file in the <code>src/resources</code> directory called <code>mastery_task_03_CD.puml</code> and add the plant uml source code to the file.</p>
                <p>You can run the <code>MT3DesignIntrospection</code> test to ensure you've met the requirements for this design. Either directly or by running <code>./gradlew -q clean :test --tests 'tct.MT3DesignIntrospectionTests'</code></p>

                <h3>Milestone 2: Implementation</h3>
                <p>Implement your new design. You likely will hit a point where you're not sure what to do about <code>getMass()</code> or <code>canFitItem()</code> in your <code>Packaging</code> class. One way to handle a method that needs to exist, but doesn't have any logical implementation is to just return some default value. However, this allows your methods to be used without the caller knowing they really shouldn't be calling these methods. Another way is to implement it by throwing an exception that says "This method is not supported!". We can do that by throwing a <code>UnsupportedOperationException</code>. Now, if anyone calls these methods, they'll get a strong signal that they shouldn't be!</p>
                <p>In addition to implementing your design you'll need to make a few more changes. You'll need to update the <code>PackagingDatastore</code>. Its <code>createFcPackagingOption()</code> method creates <code>Packaging</code> objects that get used to create <code>FcPackagingOptions</code>. Our service will continue to use boxes as the only packaging option, so let's update the code to create <code>Box</code> objects to pass to the <code>FcPackagingOptions</code>. Remember though, above we mentioned that we did not want to change the <code>FcPackagingOption</code> class, so it will still need to accept an object that <strong>is-A</strong> <code>Packaging</code>.</p>
                <p>Next, we'll need to update our <code>ShipmentOption</code> selection logic. We currently choose the option with the lowest monetary cost. However, we currently only know how to calculate the monetary cost of <code>CORRUGATE</code> packaging. We now have <code>LAMINATED_PLASTIC</code> as well. Let's open up <code>MonetaryCostStrategy</code> and make a couple updates so we can accurately calculate the cost of shipping polybags. The only method here, <code>getCost()</code> multiplies the cost per gram of the packaging material by the mass in grams of the packaging. It then adds in the cost of labor to get the total cost to ship. Next, let's take a look at the variables at the top of the file. We have a class constant, <code>LABOR_COST</code>, that stores the labor cost we mentioned above. You'll be learning about constants in our Statics lesson, but for now you should understand that it is a value that won't change per object. The cost of labor will always be 43 cents every time we use this class. There is also a <code>Map</code> called <code>materialCostPerGram</code>, which is used by the <code>getMass()</code> method to get the cost per gram of the packaging's material. We will also learn about <code>Map</code> in this unit! You might be doing this task before we get there though, so we will walk you through how we need to update it. A map has what we call a key and a value. This map has material type as its key, and a value that represents the cost per gram of that material. We will need to add a new key, value pair, <code>LAMINATED_PLASTIC : 00.25</code>. Polybags are much more expensive per gram, but weigh much less! To add a new key, value pair, or an entry, to the map, you will use the <code>put()</code> method. Add the following line to your constructor:</p>
                <pre><code>materialCostPerGram.put(Material.LAMINATED_PLASTIC, BigDecimal.valueOf(.25));</code></pre>
                <p>Before we are finished with this task we will need to make sure our code is properly tested. This means writing unit tests for new classes, and updating the existing unit tests. In any existing test classes that depended on <code>Packaging</code> you can take a similar approach to the changes you made to <code>FcPackagingOption</code>, using boxes as the packaging object. Please also include a new test in <code>MonetaryCostStrategyTest</code> validating the <code>getCost()</code> method for a polybag.</p>
                <p>You may notice that the <code>PolyBag</code> class isn't referenced anywhere in our code or data yet. That's not a bad thing, since the existing fulfillment centers (FCs) can use our new code and get confident that it works before we introduce any other changes.</p>
                <p><strong>HINTS:</strong> There are some tests in <code>ShipmentOptionTest</code> that check for equality between <code>Packages</code> (which you will be instantiating as <code>Boxs</code>). For these tests to pass you will need to Generate <code>equals</code> and <code>hashcode</code> inside the <code>Box</code> class. Boxes with different dimensions are not equal.</p>
                <p>Once your design is implemented, the <code>MT3</code> tests should pass.</p>

                <h3>Exit Checklist</h3>
                <ul>
                    <li><code>./gradlew -q clean :test --tests 'tct.MT3*'</code> passes</li>
                    <li><code>./gradlew -q clean :test --tests 'com.amazon.ata.*'</code> passes</li>
                    <li>You've pushed to github</li>
                </ul>
            </div>

            <section class="resource-section">
                <h2 class="resource-section-title">Resources</h2>
                <div class="resource-links">
                    <a href="https://junit.org/junit5/docs/current/user-guide/" target="_blank" rel="noopener" class="resource-link">
                        JUnit 5 User Guide
                    </a>
                    <a href="https://site.mockito.org/" target="_blank" rel="noopener" class="resource-link">
                        Mockito Documentation
                    </a>
                </div>
            </section>
        </section>
    </main>
</body>
</html> 