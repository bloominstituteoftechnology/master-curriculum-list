<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Practice Sorting and Hash Tables</title>
  <meta name="identifier" content="gbc8b85acb52b066a82daaf52f2a8d731" />
  <meta name="editing_roles" content="teachers" />
  <meta name="workflow_state" content="active" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#ff5722',
            secondary: '#ff7043',
            dark: '#1a1d23',
            darker: '#222831',
            darkgray: '#2a303c',
            darkborder: '#333a47',
            lighttext: '#b3b3b3',
          }
        }
      }
    }
  </script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      background-color: #1a1d23;
      /* Dark background color */
      color: #ffffff;
    }

    .objectives-section {
      margin-bottom: 20px;
      padding: 15px;
      border-left: 3px solid #ff5722;
      background-color: #222831;
      border-radius: 0 5px 5px 0;
    }

    .content-section {
      margin-bottom: 20px;
      padding: 15px;
      background-color: #2a303c;
      border-radius: 5px;
      border: 1px solid #333a47;
    }

    .code-block {
      background-color: #1a1d23;
      padding: 15px;
      border-radius: 5px;
      margin: 15px 0;
      font-family: 'Courier New', Courier, monospace;
      white-space: pre;
      overflow-x: auto;
      color: #d4d4d4;
      border: 1px solid #333a47;
    }

    .leetcode-link {
      color: #ff5722;
      text-decoration: none;
    }

    .leetcode-link:hover {
      text-decoration: underline;
      color: #ff7043;
    }

    h1,
    h2,
    h3,
    h4,
    h5 {
      color: #ffffff;
    }

    p,
    ul,
    ol {
      color: #b3b3b3;
    }

    hr {
      border-color: #333a47;
      margin: 20px 0;
    }
  </style>
</head>

<body class="min-h-screen">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
    <div class="text-center mb-12">
      <h1 class="text-4xl font-bold text-primary mb-4">Practice Sorting and Hash Tables</h1>
      <p class="text-xl text-white max-w-3xl mx-auto">
        Strengthen your sorting and hash table skills to excel in technical interviews and prepare for advanced DSA
        concepts.
      </p>
    </div>
    <h2 class="text-2xl font-semibold text-primary mb-4">Module Objectives</h2>
    <div class="objectives-section">
      <h3 class="text-lg font-medium text-secondary">Sorting Algorithms</h3>
      <p>Upon completion of the sorting module, you will be able to:</p>
      <ul>
        <li>Understand and implement basic O(n²) sorting algorithms</li>
        <li>Compare different sorting algorithms and their performance characteristics</li>
        <li>Implement Bubble Sort and Insertion Sort</li>
        <li>Analyze time and space complexity of sorting algorithms</li>
      </ul>
    </div>
    <div class="content-section">
      <h3 class="text-lg font-medium text-secondary">Hash Tables</h3>
      <p>Upon completion of the hash tables module, you will be able to:</p>
      <ul>
        <li>Understand how hash tables work internally</li>
        <li>Use hash tables to speed up algorithm performance</li>
        <li>Identify problems that can be efficiently solved using hash tables</li>
        <li>Implement hash table-based solutions</li>
      </ul>
    </div>
    <div class="content-section">
      <h3 class="text-lg font-medium text-secondary">Sorting Fundamentals</h3>
      <p class="mb-4">Sorting is the process of arranging elements in a specific order (usually ascending or
        descending). Efficient sorting is crucial for optimizing search operations and making data easier to process.
      </p>

      <h4 class="text-lg font-medium text-secondary">Bubble Sort</h4>
      <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements,
        and swaps them if they are in the wrong order.</p>

      <div class="code-block">
        # Bubble Sort implementation
        def bubble_sort(arr):
        n = len(arr)

        for i in range(n):
        swapped = False

        for j in range(n - i - 1):
        if arr[j] > arr[j + 1]:
        arr[j], arrj + 1] = arr[j + 1], arr[j]
        swapped = True

        if not swapped:
        break

        return arr

        # Time Complexity:
        # - Best Case: O(n) when array is already sorted
        # - Average Case: O(n²)
        # - Worst Case: O(n²)
        # Space Complexity: O(1 </div>

      <div class="content-section">
        <h3 class="text-lg font-medium text-secondary">Sorting Fundamentals</h3>
        <p class="mb-4">Sorting is the process of arranging elements in a specific order (usually ascending or
          descending). Efficient sorting is crucial for optimizing search operations and making data easier to process.
        </p>

        <h4 class="text-lg font-medium text-secondary">Bubble Sort</h4>
        <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements,
          and swaps them if they are in the wrong order.</p>

        <div class="code-block">
          # Bubble Sort implementation
          def bubble_sort(arr):
          n = len(arr)

          for i in range(n):
          # Flag to optimize if array becomes sorted
          swapped = False

          # Last i elements are already in place
          for j in range(n - i - 1):
          # Compare adjacent elements
          if arr[j] > arr[j + 1]:
          # Swap them if they are in wrong order
          arr[j], arrj + 1] = arr[j + 1], arr[j]
          swapped = True

          # If no swapping occurred in this pass, array is sorted
          if not swapped:
          break

          return arr

          # Time Complexity:
          # - Best Case: O(n) when array is already sorted
          # - Average Case: O(n²)
          # - Worst Case: O(n²)
          # Space Complexity: O(1
        </div>

        <h4 class="text-lg font-medium text-secondary">Insertion Sort</h4>
        <p>Insertion Sort builds the final sorted array one item at a time. It's efficient for small data sets and
          nearly sorted arrays.</p>

        <div class="code-block">
          # Insertion Sort implementation
          def insertion_sort(arr):
          n = len(arr)

          for i in range(1, n):
          # Store current element
          current = arr[i]

          # Find position for current element in the sorted part
          j = i - 1
          while j >= 0 and arr[j] > current:
          arr[j + 1] = arr[j] # Move elements forward
          j -= 1

          # Place current element in its correct position
          arr[j + 1] = current

          return arr

          # Time Complexity:
          # - Best Case: O(n) when array is already sorted
          # - Average Case: O(n²)
          # - Worst Case: O(n²)
          # Space Complexity: O(1
        </div>
      </div>

      <div class="content-section">
        <h3 class="text-lg font-medium text-secondary">Hash Tables</h3>
        <p class="mb-4">A hash table is a data structure that implements an associative array, mapping keys to values.
          It uses a hash function to compute an index into an array of buckets or slots, from which the desired value
          can be found.</p>

        <h4 class="text-lg font-medium text-secondary">Hash Table Concepts</h4>
        <ul>
          <li><strong>Hash Function:</strong> Converts keys into array indices</li>
          <li><strong>Collision:</strong> When two keys hash to the same index</li>
          <li><strong>Collision Resolution:</strong> Techniques like chaining or open addressing</li>
          <li><strong>Load Factor:</strong> Ratio of elements to buckets</li>
        </ul>

        <div class="code-block">
          # Simple Hash Table implementation with chaining
          class HashTable:
          def __init__(self, size=53):
          self.key_map = [None] * size

          def _hash(self, key):
          total = 0
          PRIME = 31

          # Hash only the first 100racters for better performance
          for i in range(min(len(key), 100)):
          char = key[i]
          value = ord(char) - 96
          total = (total * PRIME + value) % len(self.key_map)

          return total

          def set(self, key, value):
          index = self._hash(key)

          if not self.key_map[index]:
          self.key_map[index] = []

          # Check if key already exists to update
          for i in range(len(self.key_map[index])):
          if self.key_map[index][i][0] == key:
          self.key_map[index][i][1] = value
          return

          # Key doesn't exist, add new key-value pair
          self.key_map[index].append([key, value])

          def get(self, key):
          index = self._hash(key)

          if not self.key_map[index]:
          return None

          for i in range(len(self.key_map[index])):
          if self.key_map[index][i][0] == key:
          return self.key_map[index][i][1]

          return None

          # Time Complexity:
          # - Average Case for get/set: O(1
          # - Worst Case (hash collisions): O(n)
        </div>

        <h4>Using Hash Tables to Solve Problems</h4>
        <p>Hash tables are excellent for quick lookups and can optimize many algorithms:</p>

        <div class="code-block">
          # Find the first non-repeating character in a string
          def first_non_repeating_char(s):
          char_count =[object Object]}

          # Count occurrences of each character
          for char in s:
          char_count[char] = char_count.get(char, 0) + 1 # Find first character with count 1
          for i in range(len(s)):
          if char_count[s[i]] == 1:
          return s[i]

          return None # No non-repeating character found

          # Time Complexity: O(n)
          # Space Complexity: O(k) where k is the size of the character set
        </div>
      </div>

      <p><strong>Now it's time to practice what you learned!</strong></p>
      <p class="mb-4">You should have already created your Code Signal account. If you have not done so yet, please
        follow these instructions <a title="What is CodeSignal and How to Create Your Account"
          href="$WIKI_REFERENCE$/pages/g0f9edee9d9bad727f053555cc74965dd"
          data-api-endpoint="https://bloomtech.instructure.com/api/v1/courses/2482/pages/what-is-codesignal-and-how-to-create-your-account"
          data-api-returntype="Page">What is CodeSignal and How to Create Your Account</a>.</p>
      <p class="mb-4"><em>Tip:&nbsp; Before you dive into the practice tasks, revisit the core competency and guided
          project videos in this sprint.</em></p>
      <hr>
      <p class="mb-4">Complete these tasks in CodeSignal:</p>
      <p><a class="leetcode-link" href="https://app.codesignal.com/public-test/azqEu2QDZfBwsuakz/EJsRhkstAmZuDQ"
          target="_blank" rel="noopener noreferrer">ACS2M4</a></p>
      <p><a class="leetcode-link" href="https://app.codesignal.com/public-test/dfGtZxm6289jjD8ns/snHo2H5N2PMKi8"
          target="_blank" rel="noopener noreferrer">ACS2M5</a></p>
      <p><a class="leetcode-link" href="https://app.codesignal.com/public-test/d8ZaBTiF7PPmG8oNB/Spk5zCuFnKN3Kh"
          target="_blank" rel="noopener noreferrer">ACS2M6</a></p>
      <hr>
      <ol class="list-decimal list-outside text-lighttext space-y-2 pl-5 mt-4 mb-4">
        <li>Login to CodeSignal</li>
        <li>Click on the task links above</li>
        <li>Select your preferred language</li>
        <li>Click on NEXT to begin</li>
        <li>Agree with the Terms and Pledges and click START</li>
      </ol>
      <hr>
      <p>Once all the questions for each task are completed in Code Signal, click on&nbsp;<strong>Finish the
          Test</strong>.</p>
</body>

</html>