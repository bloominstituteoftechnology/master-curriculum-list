<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Module 4 - RTK Query</title>
    <link rel="stylesheet" href="../../assets/css/style.css" />
  </head>
  <body>
    <header>
      <nav>
        <div class="logo">Web Unit 3 Sprint 10</div>
        <ul>
          <li><a href="../../index.html">Home</a></li>
          <li class="dropdown">
            <a href="#" class="active">Modules</a>
            <div class="dropdown-content">
              <a href="../module1/index.html">Module 1: The Reducer Pattern</a>
              <a href="../module2/index.html">Module 2: The Context API</a>
              <a href="../module3/index.html">Module 3: Redux Toolkit</a>
              <a href="../module4/index.html" class="active"
                >Module 4: RTK Query</a
              >
            </div>
          </li>
          <li><a href="../../code-alongs/index.html">Code-Alongs</a></li>
          <li>
            <a href="../../sprint-challenge/index.html">Sprint Challenge</a>
          </li>
        </ul>
      </nav>
    </header>

    <main class="container">
      <section class="welcome">
        <h1>Web Unit 3 Sprint 10 - Redux & State Management</h1>

        <div class="content-box module4-accent">
          <h2>Module 4: RTK Query</h2>
          <p>
            In this module, you'll learn about RTK Query, a powerful data
            fetching and caching tool included in Redux Toolkit. You'll explore
            how to efficiently manage API requests, cache responses, and handle
            loading and error states.
          </p>
        </div>

        <div class="content-box">
          <h3>Learning Objectives</h3>
          <ul>
            <li>Explain what RTK Query is and the problems it solves</li>
            <li>Create an API slice using createApi</li>
            <li>Define endpoints and transformations</li>
            <li>Implement data fetching and caching strategies</li>
            <li>Set up automatic re-fetching and cache invalidation</li>
          </ul>
        </div>

        <div class="content-box module4-accent">
          <h3>Introduction to RTK Query</h3>

          <p>
            RTK Query is an essential tool in a developer's arsenal for
            efficient data management. Let's dive right in!
          </p>

          <p><strong>Why RTK Query?</strong></p>
          <p>
            RTK Query is a powerful data fetching and caching solution that is
            part of the Redux Toolkit. It provides a succinct API to simplify
            asynchronous data fetching, caching, and state management in React
            applications. Here's why it's becoming a go-to for many developers:
          </p>

          <p><strong>Simplified Data Fetching</strong></p>
          <p>
            Gone are the days of manually setting up actions, reducers, and
            middleware for each API request. RTK Query abstracts these
            complexities, allowing developers to declare what data they need,
            not how to fetch it.
          </p>

          <p><strong>Built-in Caching and Automatic Refetching</strong></p>
          <p>
            RTK Query automatically caches your data and provides intelligent
            re-fetching. It knows when to fetch new data and when to provide
            cached data, optimizing your application's performance and reducing
            unnecessary network requests.
          </p>

          <p><strong>Seamless Integration with Redux</strong></p>
          <p>
            As a part of Redux Toolkit, RTK Query integrates seamlessly with the
            Redux ecosystem, allowing for centralized state management and easy
            access to data throughout your application.
          </p>

          <p><strong>Streamlined State Management</strong></p>
          <p>
            RTK Query reduces the need for boilerplate code and streamlines
            state management. It manages loading states and error handling,
            freeing developers to focus on building features.
          </p>

          <p><strong>How does RTK Query Fit In?</strong></p>
          <p>
            Understanding where RTK Query fits in your application architecture
            is crucial. It acts as a middleware between your React application
            and your backend APIs. Instead of writing fetch calls and managing
            states manually, RTK Query provides hooks that handle the lifecycle
            of API calls, including caching, updating, and error handling.
          </p>

          <p><strong>RTK Query in Action</strong></p>
          <p>
            Through this module, we'll see RTK Query in action, demonstrating
            how to set up queries to fetch data, how to use mutations to send
            data, and how tags can be used to manage automatic re-fetching of
            data. This practical approach ensures that by the end of this
            module, you'll have a solid understanding and hands-on experience
            with RTK Query.
          </p>
          <p>
            RTK Query is the gateway to adopting a more efficient and modern
            approach to handling data in React applications. It's designed to
            make server-state management more accessible and less error-prone,
            thereby increasing developer productivity and application
            reliability.
          </p>
          <p>
            In the upcoming objectives, we will dive deeper into each aspect of
            RTK Query, providing you with the knowledge and skills needed to
            leverage its full potential.
          </p>

          <div class="video-container">
            <iframe
              src="https://fast.wistia.net/embed/iframe/8p96nwphv3?seo=false&videoFoam=false"
              title="Introduction to RTK Query"
              allow="autoplay; fullscreen"
              frameborder="0"
              scrolling="no"
              class="wistia_embed"
              name="wistia_embed"
              width="100%"
              height="100%"
              loading="lazy"
            ></iframe>
          </div>
        </div>

        <div class="content-box module4-accent">
          <h3>Setting up RTK Query</h3>

          <p>
            This objective is dedicated to mastering the setup of RTK Query
            within a React application. RTK Query is a powerful data fetching
            and caching tool provided by the Redux Toolkit, which simplifies
            server-state management in modern applications. Our objective is to
            construct an API slice to handle user data requests and seamlessly
            integrate this service into our Redux store, paving the way for
            efficient data management.
          </p>

          <h3>How to Build It</h3>

          <p><strong>Setting Up the API Service</strong></p>

          <p>
            Our journey begins with the establishment of an API slice. The
            <code>createApi</code> function from RTK Query is a factory that
            generates an object containing a set of tools designed for data
            fetching. We'll configure our slice with a
            <code>reducerPath</code> that uniquely identifies the slice within
            our store and initiate our <code>baseQuery</code> with the root URL
            of our backend API.
          </p>

          <pre><code>
// frontend/state/usersApi.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

// The usersApi slice - handling API interactions for user data
export const usersApi = createApi({
// Unique key that defines where the data will be stored in the Redux state
reducerPath: 'usersApi',
// Setting up the base query with the base URL pointing to the backend service
baseQuery: fetchBaseQuery({ baseUrl: 'http://localhost:9009/api' }),
// Placeholder for our endpoint definitions - to be implemented
endpoints: builder => ({
// Endpoints will be defined here in future steps
})
})
                </code></pre>

          <p><strong>Integrating the API Service with the Store</strong></p>
          <p>
            Now, let's weave our <code>usersApi</code> into the fabric of our
            Redux store configuration. We incorporate our API slice's reducer
            into the store's root reducer. Additionally, we infuse the store's
            middleware chain with the API slice's middleware to ensure that it
            can intercept and handle any relevant actions.
          </p>
          <pre><code>
// frontend/state/store.js
import { configureStore } from '@reduxjs/toolkit'
import { usersApi } from './usersApi'

// Configuring the Redux store, adding in our API slice and middleware
export const store = configureStore({
    // The root reducer object where we mount our slice reducers
    reducer: {
    // Other reducers might exist
    // Mounting the API reducer under a dynamic key generated by the API slice
    [usersApi.reducerPath]: usersApi.reducer,
    },
    // Customizing the store's middleware chain
    middleware: getDefaultMiddleware =>
    // Adding the API middleware to the default middleware chain
    getDefaultMiddleware().concat(usersApi.middleware),
})
                </code></pre>

          <p><strong>RTK Query in Action</strong></p>
          <p>
            With our <code>usersApi</code> slice and store configuration in
            place, the stage is set for us to define specific endpoints. These
            endpoints are akin to doorways that our components will use to send
            and receive data, carrying out actions such as fetching user lists,
            creating new users, or updating existing user information.
          </p>
          <p><strong>Observing the Behavior</strong></p>
          <p>
            With RTK Query operational, we can turn our attention to the Redux
            DevTools to check the states that are set up for us.
          </p>

          <div class="video-container">
            <iframe
              src="https://fast.wistia.net/embed/iframe/sw6iebwxba?seo=false&videoFoam=false"
              title="Creating API Slices"
              allow="autoplay; fullscreen"
              frameborder="0"
              scrolling="no"
              class="wistia_embed"
              name="wistia_embed"
              width="100%"
              height="100%"
              loading="lazy"
            ></iframe>
          </div>
        </div>

        <div class="content-box module4-accent">
          <h3>Creating Queries</h3>

          <p>
            In this objective we delve into how RTK Query enables us to retrieve
            data using simple yet powerful query definitions. We'll flesh out
            our usersApi slice to include a query endpoint for fetching user
            data and then utilize this in a component to display a list of
            users.
          </p>

          <h3>How to Build It</h3>

          <p><strong>Defining a Query Endpoint</strong></p>

          <p>
            We expand our <code>usersApi</code> slice by adding a query
            endpoint. This endpoint represents a specific data retrieval
            operation—fetching users in this case. We define a query function
            that tells RTK Query what to fetch and how to fetch it.
          </p>

          <pre><code>
// frontend/state/usersApi.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

// This is the centralized API slice for user-related data fetching
export const usersApi = createApi({
  // Identifies the API slice's place in the global state structure
  reducerPath: 'usersApi',
  // Sets up the base query with the root URL to the backend server
  baseQuery: fetchBaseQuery({ baseUrl: 'http://localhost:9009/api' }),
  // The endpoints represent operations our components can invoke
  endpoints: builder => ({
    // 'getUsers' is a query operation to fetch user data
    getUsers: builder.query({
      // Pointing to the 'users' endpoint on our server
      query: () => 'users',
    }),
  })
})

// Auto-generated hook for the 'getUsers' query
export const {
  useGetUsersQuery,
} = usersApi
                </code></pre>

          <p><strong>Consuming the Query in a Component</strong></p>
          <p>
            With the query endpoint in place, we can now use the auto-generated
            <code>useGetUsersQuery</code> hook in our components. This hook
            takes care of the data fetching lifecycle, including loading and
            error states.
          </p>

          <pre><code>
// frontend/components/App.js
import React from 'react'
import { useGetUsersQuery } from '../state/usersApi'

// This component displays a list of users utilizing data fetched with RTK Query
export default function Todo() {
  // Destructuring 'data' from the query hook, aliased as 'users' for clarity
  const { data: users } = useGetUsersQuery()

  return (
    &lt;div&gt;
      &lt;h2&gt;Users&lt;/h2&gt;
      &lt;h3&gt;Managed with RTK Query&lt;/h3&gt;
      &lt;ul&gt;{
        // Rendering a list item for each user if the data is available
        users?.map(user => (
          &lt;div key={user.id}&gt;
            {user.username}
          &lt;/div&gt;
        ))
      }
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}
                </code></pre>

          <p><strong>Visualizing the Data</strong></p>
          <p>
            Once the <code>Todo</code> component mounts,
            <code>useGetUsersQuery</code> is invoked, initiating the data
            fetching process. The list of users is then rendered on the screen
            as soon as the data is available, demonstrating the seamless
            integration of data fetching with RTK Query.
          </p>
          <div class="video-container">
            <iframe
              src="https://fast.wistia.net/embed/iframe/859bepz3iy?seo=false&videoFoam=false"
              title="Creating API Slices"
              allow="autoplay; fullscreen"
              frameborder="0"
              scrolling="no"
              class="wistia_embed"
              name="wistia_embed"
              width="100%"
              height="100%"
              loading="lazy"
            ></iframe>
          </div>
        </div>

        <div class="content-box module4-accent">
            <h3>Mutations and Cache Invalidation</h3>

            <p>"Creating Mutations" guides us through the process of altering server-side data using RTK Query. Unlike queries, which request data without causing changes to the server state, mutations are used for creating, updating, or deleting data—essentially any operation that modifies server-side data. This module teaches how to define and use mutations within our application.</p>

            <h3>How to Build It</h3>

            <p><strong>Understanding Queries vs. Mutations</strong></p>

            <p>Before diving into the code, let's clarify the difference between queries and mutations within the context of RTK Query and data fetching:</p>

            <ul>
                <li><strong>Queries</strong> are operations that retrieve data from an API without causing side effects. They are meant for "GET" operations and are typically used to sync the server state with the client.</li>
                <li><strong>Mutations</strong>, on the other hand, are operations that modify server-side data. They encompass "POST", "PUT", "PATCH", or "DELETE" operations and often result in changes to the data the server returns.</li>
            </ul>

            <p>The distinction is crucial for understanding how to structure interactions with an API in a Redux application.</p>

            <p><strong>Setting Up a Mutation Endpoint</strong></p>

            <p>Building on our existing <code>usersApi</code>, we add a mutation endpoint. This <code>createUser</code> mutation allows us to send a new user's username to the server, requesting the creation of a new user entity.</p>

            <pre><code>
// src/api/usersApi.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const usersApi = createApi({
  reducerPath: 'usersApi',
  baseQuery: fetchBaseQuery({ baseUrl: 'http://localhost:9009/api' }),
  endpoints: builder => ({
    getUsers: builder.query({
      query: () => 'users',
    }),
    createUser: builder.mutation({
      // Specifies the query for the mutation, including the URL, HTTP method, and body
      query: username => ({
        url: 'users',
        method: 'POST',
        body: { username },
      }),
    }),
  }),
})

// Hooks automatically generated by RTK Query for our endpoints
export const {
  useGetUsersQuery,
  useCreateUserMutation,
} = usersApi
            </code></pre>

            <p><strong>Implementing Mutations in Components</strong></p>

            <p>With the mutation endpoint ready, we employ the <code>useCreateUserMutation</code> hook in our <code>App</code> component. This hook provides us with a <code>create</code> function that we can call to trigger the mutation.</p>

            <pre><code>
// src/components/App.js
import React from 'react'
import { useGetUsersQuery, useCreateUserMutation } from '../state/usersApi'

export default function App() {
  const { data: users } = useGetUsersQuery()
  const [createUser] = useCreateUserMutation()

  return (
    &lt;div&gt;
      &lt;h2&gt;Users&lt;/h2&gt;
      &lt;h3&gt;Managed with RTK Query&lt;/h3&gt;
      &lt;ul&gt;{
        users?.map(user => (
          &lt;div key={user.id}&gt;{user.username}&lt;/div&gt;
        ))
      }&lt;/ul&gt;
      {/* Button to trigger the mutation */}
      &lt;button onClick={() => createUser('Test User')}&gt;
        Create test user
      &lt;/button&gt;
    &lt;/div&gt;
  )
}
            </code></pre>

            <p>The <code>createUser</code> function can be called with the new user's username as an argument. When invoked, it performs a "POST" request to the server's 'users' endpoint, which is expected to handle the user creation logic.</p>
            <p>When we call <code>createUser</code>, RTK Query automatically manages the lifecycle of the mutation. It optimizes the request process, handles potential loading states, and updates the cache upon completion. This way, the component stays declarative, and the data flow remains clear and predictable.</p>

          <div class="video-container">
            <iframe
              src="https://fast.wistia.net/embed/iframe/0tlv7qs8md?seo=false&videoFoam=false"
              title="Mutations and Cache Invalidation"
              allow="autoplay; fullscreen"
              frameborder="0"
              scrolling="no"
              class="wistia_embed"
              name="wistia_embed"
              width="100%"
              height="100%"
              loading="lazy"
            ></iframe>
          </div>
        </div>

        <div class="content-box module4-accent">
          <h3>Using Tags</h3>

            <p>In this objective, we're exploring the use of 'tags' in RTK Query. Tags are a feature of RTK Query that facilitate automatic re-fetching of data when performing actions that may change the data on the server side, such as mutations. This is part of RTK Query's advanced cache management capabilities, ensuring that the UI is kept up-to-date with the latest server state.</p>

            <h3>How to Build It</h3>

            <p><strong>What are Tags></strong></p>

            <p>Tags in RTK Query are identifiers associated with query results. They play a crucial role in cache invalidation strategies, which determine when to fetch fresh data. Here's a quick breakdown:</p>

            <ul>
                <li><code>providesTags</code>: This is used in a query to define which tags the query's result will provide. When data is fetched using this query, RTK Query will keep track of the provided tag as being "available".</li>
                <li><code>invalidatesTags</code>: Used in a mutation to specify which tags should be invalidated when the mutation is successfully executed. If a mutation invalidates a tag, RTK Query will mark it as "outdated", and any queries providing that tag will be re-fetched to provide fresh data.</li>
            </ul>

            <p><strong>Adding Tags to Our Endpoints</strong></p>

            <p>We'll modify our <code>usersApi</code> service to utilize tags for cache control. By specifying <code>providesTags</code> in the <code>getUsers</code> query and <code>invalidatesTags</code> in the <code>createUser</code> mutation, we inform RTK Query about the relationships between our operations and the cached data.</p>

            <pre><code>
// frontend/state/usersApi.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

export const usersApi = createApi({
  reducerPath: 'usersApi',
  baseQuery: fetchBaseQuery({ baseUrl: 'http://localhost:9009/api' }),
  tagTypes: ['Users'], // Declaring the types of tags we'll use for invalidation
  endpoints: builder => ({
    getUsers: builder.query({
      query: () => 'users',
      providesTags: ['Users'], // The 'getUsers' query provides the 'Users' tag
    }),
    createUser: builder.mutation({
      query: username => ({
        url: 'users',
        method: 'POST',
        body: { username },
      }),
      invalidatesTags: ['Users'], // Invalidate 'Users' tag upon mutation
    }),
  }),
})

export const {
  useGetUsersQuery,
  useCreateUserMutation,
} = usersApi
            </code></pre>

            <p><strong>Using Tagged Endpoints in Components</strong></p>
            <p>Within our components, we use the queries and mutations just as before, but now RTK Query will automatically re-fetch the <code>getUsers</code> query whenever we call the <code>createUser</code> mutation, thanks to the tags.</p>

            <pre><code>
// frontend/components/App.js
import React from 'react'
import { useGetUsersQuery, useCreateUserMutation } from '../state/usersApi'

export default function App() {
  const { data: users } = useGetUsersQuery()
  const [createUser] = useCreateUserMutation()

  return (
    &lt;div&gt;
      &lt;h2&gt;Users&lt;/h2&gt;
      &lt;h3&gt;Managed with RTK Query&lt;/h3&gt;
      &lt;ul&gt;{
        users?.map(user => (
          &lt;div key={user.id}&gt;{user.username}&lt;/div&gt;
        ))
      }&lt;/ul&gt;
      &lt;button onClick={() => createUser('New User')}&gt;
        Add New User
      &lt;/button&gt;
    &lt;/div&gt;
  )
}
            </code></pre>

            <p><strong>The Power of Tags</strong></p>
            <p>By leveraging tags, we greatly simplify the logic around maintaining fresh data within our application. With RTK Query handling the complexities of invalidating and re-fetching queries, developers can focus more on building out the UI and user experience, trusting that the data presented is current and consistent with the server state.</p>
            <p>Understanding and using tags is a powerful aspect of RTK Query that optimizes data synchronization across our application. It's an example of how RTK Query abstracts away complex caching logic and provides developers with intuitive tools to maintain data consistency.</p>

          <div class="video-container">
            <iframe
              src="https://fast.wistia.net/embed/iframe/nggaw17zwr?seo=false&videoFoam=false"
              title="Mutations and Cache Invalidation"
              allow="autoplay; fullscreen"
              frameborder="0"
              scrolling="no"
              class="wistia_embed"
              name="wistia_embed"
              width="100%"
              height="100%"
              loading="lazy"
            ></iframe>
          </div>
        </div>

        <div class="content-box module4-accent">
          <h3>Monitoring Requests</h3>

            <p>This objective focuses on how to track the status of asynchronous operations in RTK Query. Using RTK Query's hooks, we can access the state of each request, including loading, success, and error states, which can be used to inform the UI and enhance user experience.</p>

            <h3>How to Build It</h3>

            <p><strong>Extracting Request Status from RTK Query</strong></p>

            <p>When we use RTK Query's hooks for fetching data (<code>useGetUsersQuery</code>) or performing mutations (<code>useCreateUsersMutation</code>), we get several pieces of state that describe the status of the associated request. This status can be used to display loaders, success messages, or error messages.</p>
            <p>In the provided screenshot of App.js, we can observe the usage of destructuring to extract various states from RTK Query's hooks:</p>

            <pre><code>
// frontend/components/App.js
import React from 'react'
import { useGetUsersQuery, useCreateUserMutation } from '../state/usersApi'

export default function App() {
  // Destructuring the state and functions from the useGetUsersQuery hook
  const {
    data: users,
    error: usersError,
    isLoading: usersLoading,
    isFetching: usersFetching,
  } = useGetUsersQuery()

  // Destructuring the mutation function and related state from useCreateUserMutation
  const [createUser, {
    error: creationError,
    isLoading: userCreating,
  }] = useCreateUserMutation()

  // Rest of the component
}
            </code></pre>

            <p><strong>Understanding the Destructured State</strong></p>

            <ul>
                <li><code>data</code>: This is the response from our query or mutation. In the case of <code>useGetUsersQuery</code>, it would be the list of users returned from our server.</li>
                <li><code>isLoading</code>: A boolean that indicates if the query/mutation has been initiated but a response has not yet been received.</li>
                <li><code>isFetching</code>: Similar to <code>isLoading</code>, but specifically for queries, it remains true for as long as a request is in-flight, including background refetching.</li>
                <li><code>error</code>: Contains error information if the query or mutation fails.</li>
            </ul>

            <p><strong>Usage in UI</strong></p>

            <p>We can use these states to provide feedback in the UI, such as displaying loading indicators or error messages. For example, we could render a spinner while <code>usersLoading</code> or <code>userCreating</code> is true, and display <code>creationError.message</code> if an error occurs during user creation.</p>

            <pre><code>
// Inside the App component's return statement

{
  usersLoading ? &lt;p&gt;Loading users...&lt;/p&gt; : (
    &lt;ul&gt;
      {users?.map(user => &lt;div key={user.id}&gt;{user.username}&lt;/div&gt;)}
    &lt;/ul&gt;
  )
}

{
  userCreating && &lt;p&gt;Creating user...&lt;/p&gt;
}

{
  creationError && &lt;p&gt;Error creating user: {creationError.message}&lt;/p&gt;
}
            </code></pre>

            <p>By monitoring the request status provided by RTK Query hooks, we gain fine-grained control over the user interface, allowing us to react to changes in request state and provide a responsive and informative experience for the end-user.</p>

          <div class="video-container">
            <iframe
              src="https://fast.wistia.net/embed/iframe/3ilmf2knxr?seo=false&videoFoam=false"
              title="Mutations and Cache Invalidation"
              allow="autoplay; fullscreen"
              frameborder="0"
              scrolling="no"
              class="wistia_embed"
              name="wistia_embed"
              width="100%"
              height="100%"
              loading="lazy"
            ></iframe>
          </div>
        </div>

        <div class="content-box">
          <h3>Additional Resources</h3>
          <div class="resource-links">
            <a
              href="https://redux-toolkit.js.org/rtk-query/overview"
              target="_blank"
              rel="noopener"
              class="resource-link"
            >
              RTK Query Documentation
            </a>
            <a
              href="https://redux-toolkit.js.org/rtk-query/usage/mutations"
              target="_blank"
              rel="noopener"
              class="resource-link"
            >
              RTK Query Mutations Guide
            </a>
            <a
              href="https://redux-toolkit.js.org/rtk-query/usage/cache-behavior"
              target="_blank"
              rel="noopener"
              class="resource-link"
            >
              RTK Query Cache Behavior Guide
            </a>
          </div>
        </div>
      </section>
    </main>
  </body>
</html>
