<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 4 - Introduction to Testing</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
</head>
<body>
    <header>
        <nav>
            <div class="logo">Web Unit 2 Sprint 7</div>
            <ul>
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#" class="active">Modules</a>
                    <div class="dropdown-content">
                        <a href="../module1/index.html">Module 1: React Router</a>
                        <a href="../module2/index.html">Module 2: Form Management</a>
                        <a href="../module3/index.html">Module 3: Advanced Form Management</a>
                        <a href="../module4/index.html" class="active">Module 4: Introduction to Testing</a>
                    </div>
                </li>
                <li><a href="https://github.com/bloominstituteoftechnology/web-s07-practice-problems">Practice Problems</a></li>
                <li><a href="../../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            <h1>Introduction to Testing</h1>
            <div class="content-box module4-accent">
                <h2>Testing Basics</h2>
                <p>Testing is an essential quality assurance step in the software development process. It serves to verify that your code functions correctly and reliably.</p>

                <p>Proficiency in testing distinguishes adept developers and successful companies from their counterparts. An effective testing strategy should encompass a wide range of scenarios while remaining efficient to optimize resource allocation.</p>

                <p>In this session, we will delve into the significance of testing, elucidate the consequences of neglecting it, and explore the various categories of software tests at your disposal. Please join us in examining the critical role that testing plays in software development!</p>

                <h2>Understanding the risk of not testing</h2>

                <h3>The impact of skipping automated tests</h3>
                <p>Let's explore two fundamental tasks commonly encountered by software developers: fixing bugs and adding features.</p>

                <p>When the codebase remains modest, such as a small application started on a given morning, adding a feature or correcting a bug is relatively quick. Testing these alterations, often performed manually by simulating user interactions, appears efficient. This practice, called manual testing, proves effective within small-scale codebases.</p>

                <p>However, as the codebase expands in size and complexity, issues inevitably emerge. Any modification within the application could introduce bugs elsewhere, a phenomenon aggravated in monolithic codebases. Even seemingly minor changes, like rectifying a typo, can yield unexpectedly widespread repercussions — the "blast radius" — all while the original code authors may no longer be available for consultation.</p>

                <h3>How does manual testing perform in this scenario?</h3>

                <p>For substantial applications, manual testing becomes a lengthy effort, requiring an individual several days or even weeks to complete. This meticulous process involves scrutinizing a thorough checklist of numerous tasks, each demanding precise verification: "Register a new user, perform a series of specific actions, log out, log back in, execute particular operations, and inspect the inbox to ensure the correct arrival and formatting of specific emails." Each task is just one entry on this extensive list. It's a demanding and error-prone undertaking that no one wishes upon their worst adversary.</p>

                <p>Owing to the time-intensive nature of manual testing, it becomes unfeasible to comprehensively test individual work units in isolation. The cost associated with manual testing gets exponentially higher due to the increased communication needed, the number of people involved, and the tight timeline testing is typically constrained to (the tight timeline is usually brought about by a misunderstanding of how long and crucial good testing takes).</p>

                <p>One of the most costly issues of manual testing is the inability to test everything after each change. Imagine a developer effectively addresses a bug. The bug fix is deployed, and time passes until a prominent customer directly reports a problem to the CEO — an embarrassing predicament. Astonishingly, the prior "fix" introduced a new bug elsewhere in the application, a connection that remained unnoticed.</p>

                <p>A new ticket is generated and assigned to a different developer, who identifies and rectifies the issue. However, this new "fix" inadvertently reverts the original bug, leading to a regression detected only later.</p>

                <p>Externally, significant codebase enhancements appear to be underway. In reality, an undisclosed number of defects resurrect, incurring hidden costs of tens of thousands of dollars.</p>

                <p>After years of such practices, incorporating new features into the application becomes exceedingly daunting. Developers hesitate to make alterations due to uncertainties about potential repercussions. Productivity diminishes, customer satisfaction weakens, and management grapples with frustration. Simply increasing the number of developers on the team does not mitigate the relentless influx of defects (in fact, increasing developer sizes can perpetuate the issue further if the issue is not properly identified and managed).</p>

                <p>Ultimately, manual testing accrues millions of dollars in expenses, all factors considered.</p>

                <h3>The Impact of Embracing Automated Testing</h3>
                <p>If the challenges above seem daunting (which they indeed are), let's explore a vision of an alternative reality that automated testing can bring — an aspirational scenario.</p>

                <p>Automated tests are code artifacts framed to verify that specific sections of your code function as intended. Various testing philosophies, approaches, and frameworks abound. Still, the fundamental principle remains consistent: if you create a function that returns "Hello World," you'll also compose an automated test that executes the function and verifies that the outcome equals "Hello World." In the event of this correspondence, the test succeeds; otherwise, it fails.</p>

                <p>Indeed, producing one or more automated tests for each feature or bug fix can seem time-consuming, especially for those with limited experience. This lures many junior developers to forgo test writing, often with the implied approval of misguided managers. However, it's vital to recognize that the perceived time savings in skipping testing are unreal.</p>

                <p>As tests accumulate, the codebase becomes increased with thousands of individual validations. Each test executes swiftly, with the complete suite taking only seconds. Consequently, it becomes entirely practical to assess the entirety of the codebase each time an alteration is made, regardless of its scale. It's akin to having a magical button that, when pressed, instantly informs us of any application issues introduced during development. This button remains endless and is available for frequent use at critical milestones, such as merging commits into the main branch or deploying the latest app version to production.</p>

                <p>A growing repertoire of automated tests significantly reduces the occurrence of bugs, preventing the need for a dedicated manual testing team. The product becomes substantially more robust and predictable, facilitating iterative development. Developers can confidently make code changes, knowing that automated tests will detect any unexpected disruptions in distant corners of the application.</p>

                <p>A virtuous cycle emerges as well. Developers who consistently craft tests for their code recognize that the same functionality can be implemented in two ways: one that is easy to test and another that is challenging. Consequently, they gravitate toward coding practices that enhance testability to save time. Significantly, code that is easy to test is invariably more robust than code that is not.</p>

                <p>If a codebase proves challenging to test automatically, it often signifies suboptimal code quality. It could indicate entangled problems within a complex code web or huge functions tasked with various responsibilities. Regardless of the specific issues, refactoring to enhance testability invariably results in better, more understandable, and maintainable code (editor's note: I cannot express how true everything on this page is.).</p>

                <p>Moreover, tests function as living documentation that remains consistently accurate. Sometimes, understanding a code segment's intended behavior is simpler by studying its tests rather than relying on its potentially lacking documentation.</p>

                <h3>Frequently Asked Questions</h3>
                <p><strong>Is a program shielded from defects when extensively tested?</strong> Absolutely not, but testing substantially reduces bugs at a modest cost. The benefits are so significant that testing is an unquestionable necessity.</p>

                <p><strong>Isn't it tedious to create tests for every feature or bug fix?</strong> Writing tests is akin to delaying a purchase for a few minutes to pay with cash instead of immediately resorting to a high-interest credit card. Over time, the interest cost far exceeds the expense of the items purchased.</p>

                <p><strong>Do software development teams create tests for their clients?</strong> Occasionally, they do not. However, this is equivalent to transmitting a ticking time bomb to every individual who will work on the project in the future. Skipping tests is as unprofessional for a developer as disregarding hygiene practices for a doctor or a chef. Moreover, if the product endures without tests, it inevitably becomes rigid, fragile, and challenging, as discussed above.</p>

                <p><strong>How do we ensure the tests themselves are accurate?</strong> Although tests are not subject to testing, poorly constructed tests may yield false positives as the application evolves. This is considerably less detrimental than having no tests.</p>

                <p><strong>Shouldn't a testing specialist be responsible for creating all tests?</strong> Given that the author of the feature or bug fix possesses the most context, they are the best-equipped individuals to incorporate tests as part of the task. With modern tools like chatGPT, tests can be written expeditiously if the code adheres to sound practices. There is simply no justification for neglecting testing.</p>

                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>In this Learning Objective, instead of building code, you are building a mindset!</p>

                    <p>Here's a list of all the advantages of testing software. Perhaps you want to print it and leave it under your pillow:</p>

                    <ul>
                        <li><strong>Bug Detection:</strong> Testing helps identify and rectify bugs early in the development process, reducing the cost of fixing issues in later stages.</li>

                        <li><strong>Improved Quality:</strong> Rigorous testing leads to higher software quality and reliability, resulting in greater customer satisfaction.</li>

                        <li><strong>Cost-Efficiency:</strong> Early bug detection and resolution are more cost-effective than addressing issues post-release when they can be more complex and expensive to fix.</li>

                        <li><strong>Enhanced Security:</strong> Security testing helps uncover vulnerabilities and weaknesses in software, ensuring it is less susceptible to cyberattacks.</li>

                        <li><strong>Increased Confidence:</strong> Testing provides stakeholders with confidence that the software functions as expected, reducing anxiety and uncertainty.</li>

                        <li><strong>Better User Experience:</strong> Thorough testing ensures that the user interface is intuitive and responsive, leading to a better user experience.</li>

                        <li><strong>Faster Development:</strong> Automated testing can accelerate the development process by quickly validating code changes and reducing manual testing efforts.</li>

                        <li><strong>Documentation:</strong> Tests serve as living documentation, providing insights into the expected behavior of the software for both developers and other stakeholders.</li>

                        <li><strong>Regression Prevention:</strong> Regular testing prevents the introduction of regressions — previously fixed issues that reappear in later versions.</li>

                        <li><strong>Competitive Advantage:</strong> High-quality, well-tested software sets companies (and developers!) apart from competitors and can attract more customers.</li>

                        <li><strong>Compliance:</strong> Testing helps ensure that software complies with industry regulations and standards.</li>

                        <li><strong>Saves Time:</strong> Although testing requires an initial investment, it saves time by reducing the need for extensive debugging and rework.</li>

                        <li><strong>Maintenance:</strong> Easier maintenance and code modification, as well-tested code is easier to understand and modify.</li>
                    </ul>
                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/0gf32wod6e?seo=false&videoFoam=false" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                <h3>Differentiating the types of testing</h3>
                <p>Software testing is typically categorized into three distinct scopes, each serving unique purposes and frequently conducted during different phases of the development process. Moreover, these testing activities are often assigned to different developers or teams.</p>

                <h4>Unit Testing</h4>
                <p>Imagine you're building a robot, and you want to make sure that each tiny part of the robot works perfectly before assembling it. Unit testing is a lot like that. It focuses on testing individual pieces or units of your software, like small functions or methods. The goal is to ensure that each part works correctly on its own. If you're writing a calculator app, unit tests might check if addition, subtraction, multiplication, and division functions all give the right answers. Unit tests are like the building blocks of testing, helping you catch bugs early and making it easier to fix them.</p>

                <ul>
                    <li><strong>Purpose:</strong> To test the smallest pieces of code in isolation (e.g., individual functions, methods).</li>
                    <li><strong>Scope:</strong> Limited to a single "unit" like a function or method within a class.</li>
                    <li><strong>Isolation:</strong> External dependencies are generally mocked or stubbed out.</li>
                    <li><strong>Speed:</strong> Typically very fast.</li>
                    <li><strong>Examples:</strong> Testing if a sorting algorithm returns a sorted array, checking if a utility function correctly validates email formats.</li>
                    <li><strong>Geeky Detail:</strong> Unit tests should be deterministic, meaning given the same input, they'll produce the same output every time.</li>
                </ul>

                <h4>Integration Testing</h4>
                <p>Now, think about putting your robot together. You want to be sure that all the parts work well together. Integration testing is similar – it checks if different units or components of your software can collaborate effectively. For example, in a video game, integration tests might ensure that characters, items, and the game world interact smoothly. This type of testing helps you catch issues that might arise when different parts of your software communicate or connect. It's like making sure all the gears in your robot fit together perfectly.</p>

                <ul>
                    <li><strong>Purpose:</strong> To test the interaction between multiple pieces of code or system components.</li>
                    <li><strong>Scope:</strong> Covers multiple units, but not necessarily the whole system.</li>
                    <li><strong>Isolation:</strong> May or may not mock external services, depending on what is being integrated.</li>
                    <li><strong>Speed:</strong> Generally slower than unit tests, but faster than end-to-end tests.</li>
                    <li><strong>Examples:</strong> Testing if a React component correctly fetches and displays data from an API, verifying if a database layer correctly saves data to an actual database.</li>
                    <li><strong>Geeky Detail:</strong> These tests can help catch issues like incorrect data flow between functions, timing issues, or inconsistencies between different parts of a system.</li>
                </ul>

                <h4>End-to-End Testing</h4>
                <p>Imagine your robot is now ready to perform a real task, like cleaning a room. End-to-end testing is like observing your robot in action to see if it completes the entire job correctly. In software, this means testing the entire application from start to finish, just like a user would. For a website, it could involve checking if a user can sign up, log in, browse content, and make a purchase seamlessly. End-to-end testing ensures that your software functions as a whole and provides a great user experience. It's like watching your robot clean an entire room without missing a spot.</p>

                <ul>
                    <li><strong>Purpose:</strong> To test a flow from start to finish in a system as a user would experience it.</li>
                    <li><strong>Scope:</strong> The entire application and its associated components, often including third-party services.</li>
                    <li><strong>Isolation:</strong> Usually no mocking; tests interact with the real system.</li>
                    <li><strong>Speed:</strong> Typically slow due to complex setups and teardowns.</li>
                    <li><strong>Examples:</strong> Testing an entire login flow, including filling out fields in a web browser, clicking buttons, and verifying outcomes.</li>
                    <li><strong>Geeky Detail:</strong> E2E tests can be "flaky" (i.e., prone to random failures) due to their complexity and the number of moving parts.</li>
                </ul>

                <p>In summary, unit testing focuses on testing individual parts of your software, integration testing checks how those parts work together, and end-to-end testing evaluates the entire application from a user's perspective. Each type of testing plays a crucial role in ensuring your software is reliable and works as intended. Just like building a robot, these testing approaches help you create software that performs its tasks flawlessly and delivers a great user experience.</p>
                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>In the next Core Competency, you will learn how to actually test software using the Jest library. For now, let's use some pseudo-code examples to better understand how unit testing and integration testing work.</p>

                    <h4>Unit Testing Example (Pseudo-code):</h4>
                    <pre><code>Function add(a, b):
    Return a + b

Test "Adding two numbers":
    Result = add(5, 3)
    Assert(Result, 8)  // Ensures that the result of the add function is 8 when passing 5 and 3</code></pre>

                    <p>Unit tests like the above focus on individual units of code, such as functions or methods, ensuring they work as intended in isolation. Typically, the test will call the unit (function) and assert that the result matches what is expected.</p>

                    <h4>Integration Testing Example (Pseudo-code):</h4>
                    <pre><code>Function connectToDatabase():
    // Logic to connect to the database
    Return connection

Function fetchData(connection):
    // Logic to fetch data from the connected database
    Return data

Test "Fetching data from the database":
    Connection = connectToDatabase()
    Data = fetchData(Connection)
    Assert(Data, ExpectedData)  // Ensures that the fetched data matches the expected data</code></pre>

                    <p>Integration tests, as depicted above, examine interactions between multiple units or components, verifying they operate seamlessly together.</p>

                    <p>Remember, these are simplified pseudo-code examples. In practice, with tools like Jest, you'll have a variety of methods and functionalities at your disposal to structure and run your tests effectively.</p>

                    <h4>End-to-End Testing (Pseudo-code):</h4>
                    <p>With a frontend and backend working together, you can perform end-to-end tests and verify the application works across all of its integrated systems. This may involve using a tool that interacts with your website (e.g, clicking on buttons, scrolling the page, enter data, etc.), but there are simpler ways you can accomplish this as well by writing tests on the frontend similar to unit tests. The goal is to ensure that the backend is getting called and the expected data is being returned.</p>

                    <pre><code>Function OnPageLoad():
    // get data needed for this page
    userData = getUserData()
    menuData = getMenuData()

Function getUserData():
    // makes a call to the backend database for the user's data
    return fetchdData("users/1")

Function getPageData():
    //make a call to the backend database for the page's data
    return fetchData("menu")

Function fetchData(path):
    // Logic to fetch data from the connected database
    Return backend.fetchData(path)

Test "Fetching data from the backend server":
    OnPageLoad()
    waitForFetchesToComplete()
    Assert(userData, ExpectedUserData)  // Ensures that the fetched data matches the expected data
    Assert(menuData, ExpectedMenuData)</code></pre>
                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/sshqu7cmj5?seo=false&videoFoam=false" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                <h3>Conclusion</h3>
                <p>In recognizing the perils of an inadequate or absent testing strategy, it becomes evident that testing is a cornerstone of the software development process. Embracing this practice not only ensures robust software but also distinguishes you as a diligent team member.</p>

                <p>Software testing encompasses a diverse range of categories and tools. It's essential to grasp that coding transcends mere logic formulation. As applications undergo evolution and maintenance—sometimes by various teams over extended periods—it's invaluable to document and test your code thoroughly during its creation. This proactive approach ensures longevity and ease of future adaptations.</p>
            </div>
            <div class="content-box module4-accent">
                <h2>Tests in Action</h2>
                <p>One of the most popular testing libraries for JavaScript is JEST. Created by Facebook, JEST is versatile, fast, and comes with everything you need out of the box. Whether you're testing simple JavaScript functions or complex interactions in your applications, JEST provides an intuitive syntax and a robust set of features to help you.</p>

                <p>While JEST focuses on the general JavaScript testing ecosystem, the React Testing Library (often just called RTL) narrows its sights on React components. Rather than dealing with component instances or trying to manipulate the state directly, RTL encourages you to test your components in a way your users would use them. This leads to more reliable, maintainable tests that ensure your UI works as expected.</p>

                <p>Together, JEST and the React Testing Library form a powerful duo, enabling you to write tests that are both comprehensive and user-centric. As you embark on this Core Competency, remember that while writing tests might seem like extra work initially, they often save time and stress in the long run by catching issues before they become problems.</p>

                <p>Let's embark on this exciting journey to ensure our applications not only function but thrive in the real world. Happy testing!</p>

                <h3>Unit testing with Jest</h3>
                <p>Unit testing is a software testing method that focuses on individual components or functions within a program. These components are isolated and tested independently to verify their correctness. Unit testing involves creating small, specific tests that assess the behavior of these components, ensuring they perform as intended and catch any bugs early in the development process.</p>

                <p>The primary goal of unit testing is to confirm that each piece of code functions correctly in isolation before integrating it into the more extensive system. This approach provides rapid feedback and improves code maintainability, ultimately enhancing overall software quality and reducing the likelihood of defects in complex applications.</p>

                <p>Jest is a widely used testing framework that provides all the tools to create unit tests easily. Here is a table that outlines some of the most frequently used (conditionals called "matchers") in the JestJS testing library:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Syntax</th>
                            <th>Test Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>toBe(value)</td>
                            <td>expect(true).toBe(true);</td>
                        </tr>
                        <tr>
                            <td>toEqual(value)</td>
                            <td>expect({ a: 1 }).toEqual({ a: 1 });</td>
                        </tr>
                        <tr>
                            <td>toBeNull()</td>
                            <td>expect(null).toBeNull();</td>
                        </tr>
                        <tr>
                            <td>toBeDefined()</td>
                            <td>expect(someVar).toBeDefined();</td>
                        </tr>
                        <tr>
                            <td>toBeUndefined()</td>
                            <td>expect(someVar).toBeUndefined();</td>
                        </tr>
                        <tr>
                            <td>toBeTruthy()</td>
                            <td>expect(true).toBeTruthy();</td>
                        </tr>
                        <tr>
                            <td>toBeFalsy()</td>
                            <td>expect(false).toBeFalsy();</td>
                        </tr>
                        <tr>
                            <td>toBeGreaterThan(number)</td>
                            <td>expect(10).toBeGreaterThan(9);</td>
                        </tr>
                        <tr>
                            <td>toBeGreaterThanOrEqual(number)</td>
                            <td>expect(10).toBeGreaterThanOrEqual(10);</td>
                        </tr>
                        <tr>
                            <td>toBeLessThan(number)</td>
                            <td>expect(5).toBeLessThan(10);</td>
                        </tr>
                        <tr>
                            <td>toBeLessThanOrEqual(number)</td>
                            <td>expect(5).toBeLessThanOrEqual(5);</td>
                        </tr>
                        <tr>
                            <td>toContain(item)</td>
                            <td>expect([1,2,3]).toContain(2);</td>
                        </tr>
                        <tr>
                            <td>toHaveLength(length)</td>
                            <td>expect([1,2,3]).toHaveLength(3);</td>
                        </tr>
                    </tbody>
                </table>
                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>While you can certainly install and import the Jest library using different approaches, let's go ahead and use the "bloomtools" npm package, which will ensure that you are using a specific version of Jest. This package will also create a sample React app, although you don't need to worry about it for now.</p>

                    <p>In your terminal, type:</p>

                    <pre><code>npx @bloomtools/react@0.1.16 unit-tests
cd unit-tests
npm install
npm run dev</code></pre>

                    <p>After running the commands above, you should have a page on your browser displaying the app. Open the project directory in the code editor and create a file called unit.test.js at the root of the directory. Test files are actually JS files that use the Jest library and syntax:</p>

                    <pre><code>test("sanity", () => {
  // a single unit test
  let expected = 5; // setting up our expectation
  let actual = 2 + 2; // computing the actual value, which might meet expectations or not
  expect(actual).toBe(expected); // a single assertion inside the test (there can be multiple assertions)
});</code></pre>

                    <p>Get back to the terminal (you can use VSCode by clicking Menu -> Terminal -> New Terminal), and run the test:</p>

                    <pre><code>npx jest unit.test.js</code></pre>

                    <p>Check the feedback messages at the terminal. The test should have failed, with a very clear message. The failed assertion (condition) fails the whole test. Jest expected 5 but received 4. Fix the test (let actual = 2 + 3), execute it again, and it should pass!</p>

                    <p>Now, let's rewrite unit.test.js so it can test something more exciting. Do not rush; read the comments, and you will master Jest fundamentals quickly!</p>

                    <pre><code>function mathematize(num1, num2) {
  // normally this is imported from another module
  num1 = parseInt(num1);
  num2 = parseInt(num2);
  if (isNaN(num1) || isNaN(num2)) throw new Error("cannot sum those numbers");
  return {
    addition: num1 + num2,
    subtraction: num1 - num2,
    divisible: num1 % num2 === 0,
  };
}

describe("mathematize function", () => {
  // the describe is used to organize groups of tests
  // Test case 1: Any input numbers
  test("returns an object with addition, subtraction and divisible keys", () => {
    const result = mathematize(1, 2);
    expect(result).toHaveProperty("addition");
    expect(result).toHaveProperty("subtraction");
    expect(result).toHaveProperty("divisible");
  });
  // Test case 2: Valid input numbers
  test("correctly calculates addition, subtraction, and divisibility", () => {
    let result = mathematize(10, 3);
    expect(result.addition).toBe(13);
    expect(result.subtraction).toBe(7);
    expect(result.divisible).toBe(false);
    // IMPORTANT: to assert that objects have the same shape, use `toEqual` instead of `toBe`:
    expect(result).toEqual({ addition: 13, subtraction: 7, divisible: false });
    // trying different numbers
    result = mathematize(6, -2);
    expect(result.addition).toBe(4);
    expect(result.subtraction).toBe(8);
    expect(result.divisible).toBe(true);
  });
  // Test case 3: Input numbers that are not integers
  test("throws an error for non-integer input", () => {
    const message = "cannot sum those numbers";
    // the code we expect to throw must be wrapped inside a callback:
    expect(() => mathematize("abc", 5)).toThrowError(message);
    expect(() => mathematize(10, "xyz")).toThrowError(message);
    expect(() => mathematize("yes", "no")).toThrowError(message);
    expect(() => mathematize(10, NaN)).toThrowError(message);
    expect(() => mathematize(15, undefined)).toThrowError(message);
    expect(() => mathematize(null, 7)).toThrowError(message);
  });
  // Test case 4: Division by zero scenario
  test("checks divisibility with divisor being zero", () => {
    const result = mathematize(20, 0);
    expect(result.addition).toBe(20);
    expect(result.subtraction).toBe(20);
    expect(result.divisible).toBe(false); // Division by zero is not possible
  });
});</code></pre>

                    <p>Run the test again and notice that all four tests pass. The "Test Suite" also pass, because it is composed of the four unit tests, as declared by the describe keyword.</p>

                    <p>Take a moment to study the code and read the comments. You can have multiple calls to the mathematize function (and several corresponding expect statements) inside the same test. Also, notice how sometimes you want to force a fail (throw an error, in this case) to make sure the unit handles issues correctly. Jest makes it very intuitive to write and read tests!</p>

                    <p>There are several ways you can run tests:</p>

                    <pre><code>npx jest unit.test.js # runs the one file and exits
npm test # uses the "test" script in the package.json (check it!) and runs all test files in the project, watching for changes in the code (You can edit the JS file and trigger an automatic re-test, pretty cool!)
npm test -- unit.tests.js # uses the "test" script in the package.json and runs the one file, watching for changes in the code</code></pre>
                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/y96k8undq0?seo=false&videoFoam=false" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>

                <h3>Integration testing with RTL</h3>
                <p>Conducting tests on components using React Testing Library (RTL) is generally classified as UI (User Interface) testing, and more precisely, it falls under the category of integration testing. This distinction arises because components are not as straightforward and isolated as typical functions subjected to unit testing.</p>

                <p>UI testing places its focus on examining the interplay among various components and how they collaborate to construct the user interface. React Testing Library is intentionally crafted to evaluate how components behave within a real-world context. It promotes the creation of tests that closely mimic a user's interaction with the application.</p>

                <p>However, it's important to note that these tests do not qualify as end-to-end tests. This is because they scrutinize only portions of the application within a simulated DOM, rather than launching a full-fledged web browser to assess the entire application.</p>

                <p>Given that React Testing Library assesses component interactions and their contribution to the overall user interface, it falls under the realm of integration testing.</p>

                <p>It's worth mentioning that React Testing Library does not delve into inspecting the internal implementation details of components. Consequently, developers may still need to resort to unit testing for evaluating specific functions within the application before proceeding with RTL testing.</p>

                <div class="note-box">
                    <h3>How to Build It</h3>
                    <p>You are going to use the same npm package to spin-up a React App ready to be tested with RTL:</p>

                    <pre><code>npx @bloomtools/react@0.1.16 rtl-tests
cd rtl-tests
npm install
npm run dev</code></pre>

                    <p>Your browser should open up with the app page, although you don't need it running (live in the browser) to work with RTL. Proceed to edit the App.js file (inside /frontend/components):</p>

                    <pre><code>import React, { useState } from "react";

export default function App() {
  const [friends] = useState(["Cynthia", "Fish", "Alex"]);
  return (
    &lt;div data-testid="friends"&gt;
      &lt;h2&gt;Friends App&lt;/h2&gt;
      &lt;div&gt;
        {friends.map((friend, idx) => (
          &lt;div key={idx}&gt;My friend {friend}&lt;/div&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

                    <p>The App component renders a header and three sentences. The outer &lt;div&gt; has a special attribute data-testid which will be used by the tests later! Other than that, it is a very basic component.</p>

                    <p>Create a file called App.test.js inside the frontend/components/__tests__ folder:</p>

                    <pre><code>import React from "react";
import { render, screen } from "@testing-library/react";
import "@testing-library/jest-dom";
import App from "../App";

test("the container div is present", () => {
  render(&lt;App /&gt;); // we need to render App for each test
  const div = screen.queryByTestId("friends"); // note the &lt;div data-testid="friends"&gt; in the JSX above
  expect(div).toBeInTheDocument(); // here is an assertion
});</code></pre>

                    <p>Let's study the code above.</p>

                    <p>Before writing your tests, you need to import a couple of objects from @testing-library/react which will be used in the code, and also import the jest-dom library, which is specially written to test React Apps in a virtual DOM and contains assertions like .toBeInTheDocument().</p>

                    <p>The render function will execute (render) the App component, just like the render function normally does inside the index.js file, but you don't need to specify a root node here.</p>

                    <p>Next, we use the screen object, which represents the virtual DOM, to select an element by "test id".</p>

                    <p>Finally, the code asserts (tests a condition) that the element targeted in the previous line exists in the document.</p>

                    <p>The RTL syntax is a bit different from traditional Jest, but it's still quite intuitive!</p>

                    <p>Execute the tests from the command line:</p>

                    <pre><code>npm test -- App.test.js</code></pre>

                    <p>It's not necessary that your app be running in order to test, so you can kill your "dev" script if you wish.</p>

                    <p>Add a new test that checks that the "Friends App" text is present in the DOM and visible. Just paste the code below at the end of the file and the tests will automatically run:</p>

                    <pre><code>test('the text "Friends App" renders', () => {
  render(&lt;App /&gt;);
  const heading = screen.queryByText("Friends App", { exact: false });
  expect(heading).toBeInTheDocument();
  expect(heading).toBeVisible(); // a node could be in the DOM but not be visible
});</code></pre>

                    <p>Remember to render the component before each test!</p>

                    <p>Similarly, this last test is selecting an element "by text" and asserting that it exists and is visible. The screen object exposes different types of queries which are not present in vanilla JavaScript.</p>

                    <p>Since you are dealing with React Apps and user interfaces, in practice a lot of your tests will probably consist in locating specific pieces of text on the page.</p>

                    <p>Some notes about screen.queryByText:</p>
                    <ul>
                        <li>If a single node containing the text is found, it is assigned into the heading variable</li>
                        <li>If no node is found with the given text, the heading variable will be null</li>
                        <li>If multiple nodes with the same text are found, the test will fail outright</li>
                        <li>The exact: false configuration admits differences in capitalization and partial matches</li>
                    </ul>

                    <p>If you need to log out the "fake" DOM tree, you can use screen.debug():</p>

                    <pre><code>test("inspecting the rendered DOM", () => {
  render(&lt;App /&gt;);
  screen.debug();
});</code></pre>

                    <p>You can also write tests using iteration:</p>

                    <pre><code>test("using a loop", () => {
  render(&lt;App /&gt;);
  ["Cynthia", "Fish", "Alex"].forEach((name) => {
    const friend = screen.queryByText(name, { exact: false });
    expect(friend).toBeVisible();
  });
});</code></pre>

                    <p>Some query methods can select multiple nodes at once:</p>

                    <pre><code>test("using queryAllByText", () => {
  render(&lt;App /&gt;);
  // friends is a collection of HTML nodes
  const friends = screen.queryAllByText("My friend", { exact: false });
  expect(friends).toHaveLength(3);
});</code></pre>

                    <p>Besides text and test-id, you can select elements using multiple criteria. In the App.js file, add the following section inside the outer JSX div:</p>

                    <pre><code>&lt;form&gt;
  &lt;img alt="cute cat" src="./cat.jpg" data-testid="catImg" /&gt;
  &lt;input type="text" placeholder="Type cat name" role="textbox" /&gt;
&lt;/form&gt;</code></pre>

                    <p>Add some more tests using different selection methods:</p>

                    <pre><code>test("capturing nodes in different ways besides text content", () => {
  render(&lt;App /&gt;);
  let img = screen.queryByAltText("cute cat"); // by alt attribute
  expect(img).toBeInTheDocument();
  img = screen.queryByTestId("catImg"); // by a data attribute "testid"
  expect(img).toBeInTheDocument();
  let input = screen.queryByPlaceholderText("Type cat name"); // by placeholder
  expect(input).toBeInTheDocument();
  input = screen.queryByRole("textbox"); // by role
  expect(input).toBeInTheDocument();
});</code></pre>

                    <p>In general, RTL encourages capturing DOM elements that are visible, as part of the user interface. You should avoid capturing nodes that users and screen readers don't care about (like class names), which are also liable to change without notice.</p>

                    <div class="video-container">
                        <iframe src="https://fast.wistia.net/embed/iframe/tr5fj75t92?seo=false&videoFoam=false" allow="autoplay; fullscreen" loading="lazy"></iframe>
                    </div>
                </div>
                <h3>Conclusion</h3>
                <p>React Testing Library (RTL) emphasizes the importance of testing your components in a manner that resembles how users interact with them. One of the crucial aspects to bear in mind is the careful design of your document tree and associated tests. Minor alterations in the HTML structure or class names can lead to test failures. By being diligent in your test design, you shield yourself from these potential pitfalls, ensuring that your tests remain resilient against superficial changes in your codebase.</p>

                <p>Furthermore, adopting a test-first or test-driven mindset fosters the creation of high-quality, maintainable code. RTL serves as a powerful tool in a developer's arsenal!</p>
            </div>

            <div class="content-box module4-accent">
                <h2>Guided Project</h2>
              <p><a href="https://github.com/bloominstituteoftechnology/web-guided-project-intro-to-testing-gp" target="_blank" rel="noopener">Intro to Testing Starter Code</a></p>
              <p><a href="https://github.com/bloominstituteoftechnology/web-guided-project-intro-to-testing-gp-solution" target="_blank" rel="noopener">Intro to Testing Solution</a></p>
              <div class="video-container">
                  <iframe src="https://fast.wistia.net/embed/iframe/m9gojmiv1v?seo=false&videoFoam=false" title="Guided Project" allow="autoplay; fullscreen" loading="lazy"></iframe>
              </div>
            </div>

            <div class="content-box module4-accent">
                <h3>Module 4 Project: Introduction to Testing</h3>

                <p>This project will have you implement internationalization on a site! In particular you will make a form display in Spanish and in English. You will also use Jest to test some logic, and React Testing Library to test that the form renders correctly in both languages. By the end, you will have a fully functioning form that can switch languages, and unit tests and integration tests passing in your terminal.</p>
                <p>The module project contains advanced problems that will challenge and stretch your understanding of the module's content. The project has built-in tests for you to check your work, and the solution video is available in case you need help or want to see how we solved each challenge, but remember, there is always more than one way to solve a problem. Before reviewing the solution video, be sure to attempt the project and try solving the challenges yourself.</p>
                

                <h3>Instructions</h3>

                <p>The link below takes you to Bloom's code repository of the assignment. You'll need to fork the repo to your own GitHub account, and clone it down to your computer:</p>
                <p>Starter Repo: <a href="https://github.com/bloominstituteoftechnology/W_S7M4_Project" target="_blank">Introduction to Testing</a></p>

                <ul>
                    <li>Fork the repository,</li>
                    <li>clone it to your machine, and</li>
                    <li>open the README.md file in VSCode, where you will find instructions on completing this Project.</li>
                    <li>submit your completed project to the BloomTech Portal</li>
                </ul>

                <h3>Solution</h3>
                <div class="video-container">
                    <iframe src="https://fast.wistia.net/embed/iframe/jrlib73x4s?seo=false&videoFoam=false" title="Solution Video" allow="autoplay; fullscreen" loading="lazy"></iframe>
                </div>
            </div>

            <div class="content-box">
                <h2>Resources</h2>
                <div class="resource-links">
                    <a href="https://testing-library.com/docs/react-testing-library/intro/" target="_blank" rel="noopener noreferrer" class="resource-link">
                        React Testing Library Documentation
                    </a>
                    <a href="https://jestjs.io/docs/getting-started" target="_blank" rel="noopener noreferrer" class="resource-link">
                        Jest Documentation
                    </a>
                    <a href="https://kentcdodds.com/blog/common-mistakes-with-react-testing-library" target="_blank" rel="noopener noreferrer" class="resource-link">
                        Common Mistakes with React Testing Library
                    </a>
                    <a href="https://www.robinwieruch.de/react-testing-library/" target="_blank" rel="noopener noreferrer" class="resource-link">
                        React Testing Library Tutorial
                    </a>
                    <a href="https://github.com/mswjs/msw" target="_blank" rel="noopener noreferrer" class="resource-link">
                        Mock Service Worker
                    </a>
                </div>
            </div>
        </section>
    </main>
</body>
</html> 