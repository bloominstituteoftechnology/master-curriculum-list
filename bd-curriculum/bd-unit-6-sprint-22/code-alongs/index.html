<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code-Alongs - BD Unit 6 Sprint 22</title>
    <link rel="stylesheet" href="../assets/css/style.css">
</head>
<body>
    <header>
        <nav>
            <div class="logo">BD Unit 6 Sprint 22</div>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#">Modules</a>
                    <div class="dropdown-content">
                        <a href="../modules/module1/index.html">Module 1 - Stacks and Queues</a>
                        <a href="../modules/module2/index.html">Module 2 - Computer Hardware and OS</a>
                        <a href="../modules/module3/index.html">Module 3 - Immutability and Final</a>
                        <a href="../modules/module4/index.html">Module 4 - In-Memory Caching</a>
                    </div>
                </li>
                <li><a href="../code-alongs/index.html" class="active">Code-Alongs</a></li>
                <li><a href="../sprint-challenge/index.html">Sprint Challenge</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <section class="welcome">
            <h1>Code-Alongs</h1>

            <div class="content-box code-along-accent">
                <h2>Code-Along 1: Stacks and Queues</h2>
                <p>This code-along will guide you through implementing stacks and queues in Java, focusing on their operations, use cases, and implementation details.</p>
                
                <div class="note-box">
                    <h3>What You'll Learn</h3>
                    <ul>
                        <li>Practical implementation of Stack and Queue data structures in Java</li>
                        <li>Understanding LIFO (Last-In-First-Out) and FIFO (First-In-First-Out) principles</li>
                        <li>Time and space complexity analysis of stack and queue operations</li>
                        <li>Real-world applications of stacks and queues</li>
                        <li>Common implementation patterns and best practices</li>
                    </ul>
                </div>
                
                <p>Stacks are used when you need to handle data in a Last-In-First-Out manner, making them perfect for scenarios like tracking undo operations, managing function calls, and parsing expressions. Queues shine in First-In-First-Out scenarios like print job management, task scheduling, and breadth-first search algorithms.</p>
                
                <p>During this code-along, you'll implement both data structures and see how their distinct behaviors serve different purposes in application design. You'll also learn how to choose between Java's built-in implementations depending on your specific requirements.</p>
                
                <div class="video-container">
                    <iframe class="wistia_embed" title="Stacks and Queues Code-Along" src="https://fast.wistia.net/embed/iframe/m3huj6opvn" allow="autoplay; fullscreen" allowfullscreen></iframe>
                </div>
                
                <pre><code>// Stack example - tracking application state
Stack&lt;String&gt; undoStack = new Stack&lt;&gt;();
undoStack.push("action1");
undoStack.push("action2");

// Last action performed can be undone first
String lastAction = undoStack.pop(); // Returns "action2"

// Queue example - processing tasks in order
Queue&lt;PrintJob&gt; printQueue = new LinkedList&lt;&gt;();
printQueue.add(new PrintJob("doc1.pdf"));
printQueue.add(new PrintJob("doc2.pdf"));

// First job added will be processed first
PrintJob nextJob = printQueue.remove(); // Returns doc1.pdf job</code></pre>
                
                <div class="resource-section">
                    <h3 class="resource-section-title">Resources</h3>
                    <div class="resource-links">
                        <a href="https://github.com/BloomTechBackend/bd-stacks-and-queues-codealong-starter" target="_blank" rel="noopener" class="resource-link">Starter Repository</a>
                        <a href="https://github.com/BloomTechBackend/bd-stacks-and-queues-codealong-solution" target="_blank" rel="noopener" class="resource-link">Solution Repository</a>
                    </div>
                </div>
            </div>

            <div class="content-box code-along-accent">
                <h2>Code-Along 2: In-Memory Caching</h2>
                <p>This code-along will guide you through implementing an in-memory caching solution to improve application performance, focusing on caching strategies and implementation techniques.</p>
                
                <div class="note-box">
                    <h3>What You'll Learn</h3>
                    <ul>
                        <li>Designing and implementing a custom in-memory cache in Java</li>
                        <li>Handling cache hits, misses, and evictions effectively</li>
                        <li>Implementing time-based expiration with TTL (Time-To-Live)</li>
                        <li>Choosing appropriate eviction policies based on use cases</li>
                        <li>Testing and optimizing cache performance</li>
                    </ul>
                </div>
                
                <p>In-memory caching is a powerful technique for improving application performance by storing frequently accessed data in memory. This approach significantly reduces the need to perform expensive operations like database queries, API calls, or complex calculations repeatedly.</p>
                
                <p>During this code-along, you'll build a custom caching solution that balances memory usage with performance gains. You'll learn to predict cache behavior and make informed decisions about cache size and TTL settings based on application requirements.</p>
                
                <div class="video-container">
                    <iframe class="wistia_embed" title="In-Memory Caching Code-Along" src="https://fast.wistia.net/embed/iframe/m3huj6opvn" allow="autoplay; fullscreen" allowfullscreen></iframe>
                </div>
                
                <pre><code>// Basic cache implementation with TTL
public class SimpleCache&lt;K, V&gt; {
    private final Map&lt;K, CacheEntry&lt;V&gt;&gt; cache = new HashMap&lt;&gt;();
    private final long defaultTtlMillis;
    
    // Cache hit example
    public V get(K key) {
        CacheEntry&lt;V&gt; entry = cache.get(key);
        if (entry == null) {
            return null; // Cache miss
        }
        if (entry.isExpired()) {
            cache.remove(key);
            return null; // Expired entry
        }
        return entry.getValue(); // Cache hit
    }
    
    // Cache miss handling
    public V getOrCompute(K key, Function&lt;K, V&gt; computeFunction) {
        V value = get(key);
        if (value == null) {
            value = computeFunction.apply(key);
            put(key, value);
        }
        return value;
    }
}</code></pre>
                
                <div class="resource-section">
                    <h3 class="resource-section-title">Resources</h3>
                    <div class="resource-links">
                        <a href="https://github.com/BloomTechBackend/bd-in-memory-caching-codealong-starter" target="_blank" rel="noopener" class="resource-link">Starter Repository</a>
                        <a href="https://github.com/BloomTechBackend/bd-in-memory-caching-codealong-solution" target="_blank" rel="noopener" class="resource-link">Solution Repository</a>
                    </div>
                </div>
            </div>
        </section>
    </main>
</body>
</html> 